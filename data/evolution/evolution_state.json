{
  "round_number": 391,
  "total_benchmarks_run": 1109,
  "total_passed": 815,
  "best_score": 8.75,
  "best_round": 220,
  "improvements_applied": 201,
  "improvements_failed": 176,
  "rounds": [
    {
      "round": 1,
      "timestamp": 1771009552.861863,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，通过递归地将数组分成两半，\n    然后将已排序的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 已排序的左列表\n        right: 已排序的右列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 15.942615032196045
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率：大数值测试\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 16.87453007698059
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 示例用法\nif __name__ == \"__main__\":\n    # 创建一个容量为2的LRU缓存\n    cache = LRUCache(2)\n    \n    # 测试基本功能\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # 输出: 1\n    \n    # 测试容量限制\n    cache.put(\"c\", 3)  # 应该删除最久未使用的项\"a\"\n    print(cache.get(\"a\"))  # 输出: None\n    \n    # 测试TTL过期\n    cache.put(\"d\", 4, ttl=1)  # 1秒后过期\n    print(cache.get(\"d\"))  # 输出: 4\n    time.sleep(1.1)\n    print(cache.get(\"d\"))  # 输出: None (已过期)\n    \n    # 测试重复更新\n    cache.put(\"e\", 5)\n    cache.put(\"e\", 6)  # 更新已存在的键\n    print(cache.get(\"e\"))  # 输出: 6\n",
          "time_taken": 21.460202932357788
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \n            Args:\n                *args: 函数参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常，如果重试次数用完\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                        raise e\n                    \n                    logger.warning(\n                        f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试中失败: {e}, \"\n                        f\"将在 {current_delay:.2f} 秒后重试\"\n                    )\n                    \n                    await asyncio.sleep(current_delay)\n           ",
          "time_taken": 35.992084980010986
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[s",
          "time_taken": 22.695459127426147
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 244, in <module>\n  File \"<string>\", line 205, in __exit__\n  File \"<string>\", line 192, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: TaskPriority = TaskPriority.NORMAL\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数值越大优先级越高\"\"\"\n        # Handle comparison with None (for shutdown sentinels)\n        if other is None:\n            return False\n        return self.priority.value > other.priority.value\n\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    支持：\n    - 提交单个任务\n    - 批量执行任务\n    - 优雅关闭\n    - 超时控制\n    - 优先级支持\n    \"\"\"\n    \n    def __init__(self, max_workers: int = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为CPU核心数\n        \"\"\"\n        if max_workers is None:\n            import multiprocessing\n            max_workers = multiprocessing.cpu_count()\n        \n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._work_queue = queue.PriorityQueue()\n        self._threads = set()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._started = False\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        if self._started:\n            return\n            \n        for i in range(self.max_workers):\n            t = threading.Thread(target=self._worker, name=f\"TaskPool-Worker-{i}\")\n            t.daemon = True\n            t.start()\n            self._threads.add(t)\n            \n        self._started = True\n    \n    def _worker(self):\n        \"\"\"工作线程执行函数\"\"\"\n        while True:\n          ",
          "time_taken": 150.23997592926025
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果是普通类型，使用 isinstance 检查\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, items: list[int], data: dict[str, int]) -> str:\n        return f\"{x",
          "time_taken": 48.50789189338684
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Tuple\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序处理和并发批量处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_func = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await se",
          "time_taken": 25.298709869384766
        }
      ],
      "elapsed_seconds": 607.3
    },
    {
      "round": 2,
      "timestamp": 1771009931.513613,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\n\ndef merge_sort(arr: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的数字列表（支持整数和浮点数）\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([3.14, 2.71, 1.41])\n        [1.41, 2.71, 3.14]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[Union[int, float]], right: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序列表\n        right: 右侧已排序列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],  # 空列表\n        [42],  # 单元素\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通情况\n        [5, 4, 3, 2, 1],  # 逆序\n        [1, 2, 3, 4, 5],  # 已排序\n        [1, 1, 1, 1],  # 重复元素\n        [3.14, 2.71, 1.41, 0.57],  # 浮点数\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_arr}\")",
          "time_taken": 19.22162103652954
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算（索引为2）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证函数的正确性\n    assert fibonacci(0) == []\n    assert fibonacci(1) == [0]\n    assert fibonacci(5) == [0, 1, 1, 2, 3]\n    assert fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    print(\"所有测试通过！\")\n",
          "time_taken": 15.585425853729248
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic functionality\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to LRU)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 20.99149489402771
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\nfrom typing_extensions import ParamSpec\n\nT = TypeVar('T')\nP = ParamSpec('P')\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    自动重试装饰器，支持指数退避和可配置异常类型\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间会乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @functools.wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (attempt {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"等待 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败 (attempt {attempt + 1}/{max_retries + 1}): {e}\"\n                        )\n                        raise\n            raise last_exception  # 理论上不会到达这里，但为了类型检查添加\n            \n        return wrapper\n    return decorator\n\ndef auto_retry_async(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exc",
          "time_taken": 28.459887266159058
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                value = float(self.expression[start:self.position])\n                self.tokens.append(Token('NUMBER', value))\n            elif char == '+':\n                self.tokens.append(Token('+', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Parse the following number\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position += 1\n                    value = fl",
          "time_taken": 23.644185066223145
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭、超时控制和任务优先级。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> result = future.result()\n        >>> print(result)  # 10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高，默认为0）\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Retur",
          "time_taken": 34.9737651348114
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: x}\n    \n    # 正确调用\n    tr",
          "time_taken": 18.840269088745117
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages = {}  # {name: function}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return resul",
          "time_taken": 24.48197603225708
        }
      ],
      "elapsed_seconds": 378.6
    },
    {
      "round": 3,
      "timestamp": 1771010570.4149802,
      "passed": 6,
      "total": 8,
      "avg_score": 7.0,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef merge_sort(arr: List[T]) -> List[T]:\n    \"\"\"\n    对输入列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的列表，元素类型可以是任意可比较的类型\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort(['c', 'a', 'b'])\n        ['a', 'b', 'c']\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两部分\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两部分\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[T], right: List[T]) -> List[T]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试字符串列表\n    assert merge_sort(['c', 'a', 'b']) == ['a', 'b', 'c']\n    \n    # 测试原列表不变\n    original = [3, 1, 4, 1, 5]\n    sorted_arr",
          "time_taken": 19.388713836669922
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算剩余的数\n    # 从第三个数开始计算\n    for i in range(2, n):\n        # 当前数 = 前一个数 + 前两个数\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 17.245052814483643
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\"\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (still in cache)\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 22.56750202178955
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义装饰器参数类型\nRetryConfig = Tuple[int, float, float, Tuple[Type[Exception], ...]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise  # 重新抛出原始异常\n                    \n                    logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                    logger.info(f\"将在 {current_delay:.2f} 秒后重试...\")\n                    \n                    time.sleep(current_delay)\n                    current_delay *= backoff\n                    \n            # 理论上不会到达这里\n            raise RuntimeError(\"重试逻辑异常\")\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.err",
          "time_taken": 31.05202603340149
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"+\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in \"(+-*/\":\n                    # It's a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position += 1\n                    number_str = self.expression[start:self.po",
          "time_taken": 22.92976474761963
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 257, in <module>\n  File \"<string>\", line 212, in __exit__\n  File \"<string>\", line 192, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator, Tuple\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass Priority(Enum):\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: Priority = Priority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        # Handle comparison with None (used for shutdown signals)\n        if other is None:\n            return False\n        if self.priority == other.priority:\n            # 如果优先级相同，按提交时间排序\n            return id(self) < id(other)\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self._max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._worker_threads: List[threading.Thread] = []\n        self._started = False\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        if self._started:\n            return\n            \n        # 启动工作线程\n        for _ in range(self._max_workers or 4):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n        \n        self._started = True\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从队列中获取任务\n                task = self._",
          "time_taken": 139.6880760192871
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况，对于其他泛型类型如 tuple, set 等\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        带类型检查的包装函数\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_fu",
          "time_taken": 20.650196075439453
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 638.9
    },
    {
      "round": 4,
      "timestamp": 1771011099.583036,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余的元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([2, 2, 2, 2]) == [2, 2, 2, 2]\n    \n    # 测试负数\n    assert merge_sort([-1, -5, 3, 0, 2]) == [-5, -1, 0, 2, 3]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 17.147218942642212
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(1) (不包括结果列表)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 17.29479694366455
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"one\")\n    cache.put(2, \"two\")\n    print(cache.get(1))  # Should return \"one\"\n    \n    cache.put(3, \"three\")  # This should evict key 2\n    print(cache.get(2))  # Should return None\n    \n    # Test TTL functionality\n    cache.put(4, \"four\", ttl=1)  # 1 second TTL\n    print(cache.get(4))  # Should return \"four\"\n    time.sleep(1.1)\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test updating existing key\n    cache.put(1, \"one_updated\")\n    print(cache.get(1))  # Should return \"one_updated\"\n",
          "time_taken": 20.5178279876709
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义异步和同步函数的类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Any]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            \"\"\"\n            异步函数包装器\n            \n            Args:\n                *args: 函数位置参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常，如果重试次数用尽\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                       ",
          "time_taken": 32.45869588851929
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                self._parse_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._parse_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n    \n    def _parse_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expr",
          "time_taken": 21.47270703315735
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 247, in <module>\n  File \"<string>\", line 203, in __exit__\n  File \"<string>\", line 187, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        # 优先级越小越先执行\n        # 处理 None 值的比较\n        if other is None:\n            return False\n        if self.priority == other.priority:\n            # 如果优先级相同，按提交时间排序（先提交的先执行）\n            return self.submit_time < other.submit_time\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 任务超时\n    - 任务优先级\n    - 线程安全\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        if max_workers is None:\n            import multiprocessing\n            max_workers = multiprocessing.cpu_count()\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._work_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._workers.append(thread)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while True:\n            try:\n                # 从优先级队列中获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 收到关闭信号\n                    break\n                \n                # 执行任务\n                try:\n                    result = task.func(*task.args, **task.kwargs)",
          "time_taken": 166.74818587303162
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(\n            _matches_type(k, args[0]) and _matches_type(v, args[1]) \n            for k, v in value.items()\n        )\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n  ",
          "time_taken": 19.825565099716187
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n    ",
          "time_taken": 25.41851019859314
        }
      ],
      "elapsed_seconds": 529.1
    },
    {
      "round": 5,
      "timestamp": 1771011468.0571141,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序后:   {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 16.71891212463379
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证错误处理\n    print(f\"fibonacci(-1) = {fibonacci(-1)}\")  # []\n",
          "time_taken": 17.25054693222046
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (still in cache)\n",
          "time_taken": 21.050975799560547
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Coroutine, Type, Tuple, Union\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[Callable, Coroutine]) -> Union[Callable, Coroutine]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功\")\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}，\"\n                            f\"将在 {current_delay:.2f} 秒后重试\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(f\"函数 {func.__name__} 重试 {max_retries} 次后仍然失败: {e}\")\n                        raise\n            raise last_exception\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n            ",
          "time_taken": 27.21402597427368
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.current_char = self.expression[self.position] if self.expression else None\n    \n    def advance(self):\n        \"\"\"移动到下一个字符\"\"\"\n        self.position += 1\n        if self.position >= len(self.expression):\n            self.current_char = None\n        else:\n            self.current_char = self.expression[self.position]\n    \n    def skip_whitespace(self):\n        \"\"\"跳过空白字符\"\"\"\n        while self.current_char and self.current_char.isspace():\n            self.advance()\n    \n    def read_number(self) -> float:\n        \"\"\"读取数字（包括小数）\"\"\"\n        number_str = \"\"\n        while self.current_char and (self.current_char.isdigit() or self.current_char == '.'):\n            number_str += self.current_char\n            self.advance()\n        return float(number_str)\n    \n    def tokenize(self) -> List[Token]:\n        \"\"\"将表达式转换为token列表\"\"\"\n        tokens = []\n        \n        while self.current_char:\n            self.skip_whitespace()\n            \n            if self.current_char is None:\n                break\n                \n            if self.current_char.isdigit() or self.current_char == '.':\n                # 读取数字\n                tokens.append(Token(TokenType.NUMBER, self.read_number()))\n            elif self.current_char == '+':\n                tokens.append(Token(TokenType.PLUS, '+'))\n                self.advance()\n            elif self.current_char == '-':\n                # 检查是否为负号\n                if len(tokens) ",
          "time_taken": 26.809444904327393
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 任务超时控制\n    - 任务优先级控制\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为CPU核心数\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._running = True\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级 (数值越小优先级越高)\n            timeout: 任务超时时间 (秒)\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"TaskPool has been shut down\")\n            \n        task = Task(fn, args, kwargs, priority, timeout)\n        self._task_queue.put(task)\n        return task.future\n   ",
          "time_taken": 35.10901927947998
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果是普通类型，使用 isinstance 检查\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 被装饰的函数\n        \n    Returns:\n        带类型检查功能的包装函数\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example",
          "time_taken": 19.623908758163452
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序和并发处理数据。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_func = self.stages[stage_name]\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_",
          "time_taken": 28.475415229797363
        }
      ],
      "elapsed_seconds": 368.4
    },
    {
      "round": 6,
      "timestamp": 1771011854.339464,
      "passed": 7,
      "total": 8,
      "avg_score": 8.25,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本，确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序列表\n        right: 右侧已排序列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 16.454834938049316
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 处理n=1的特殊情况\n    if n == 1:\n        return [0]\n    \n    # 初始化结果列表\n    result = [0, 1]\n    \n    # 使用迭代方式计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能（大数值测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 16.38833522796631
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        \"\"\"\n        初始化LRU缓存\n        \n        Args:\n            capacity: 缓存的最大容量\n        \"\"\"\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        \"\"\"\n        获取缓存中的值\n        \n        Args:\n            key: 要获取的键\n            \n        Returns:\n            如果键存在且未过期，返回对应的值；否则返回None\n        \"\"\"\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        \"\"\"\n        向缓存中添加或更新键值对\n        \n        Args:\n            key: 键\n            value: 值\n            ttl: 过期时间（秒），如果为None则永不过期\n        \"\"\"\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为3的LRU缓存\n    cache = LRUCache(3)\n    \n    # 测试基本功能\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    cache.put(\"c\", 3)\n    \n    print(\"初始状态:\", cache.get(\"a\"))  # 应该返回1\n    print(\"初始状态:\", cache.get(\"b\"))  # 应该返回2\n    \n    # 测试LRU淘汰机制\n    cache.put(\"d\", 4)  # 应该淘汰\"a\"\n    print(\"淘汰测试:\", cache.get(\"a\"))  # 应该返回None\n    print(\"淘汰测试:\", cache.get(\"b\"))  # 应该返回2\n    \n    # 测试TTL功能\n    cache.put(\"e\", 5, ttl=1)  # 1秒后过期\n    print(\"TTL测试:\", cache.get(\"e\"))  # 应该返回5\n    time.sleep(1.1)  # 等待过期\n    print(\"TTL过期测试:\", cache.get(\"e\"))  # 应该返回None\n    \n    # 测试更新操作\n    cache.put(\"b\", 20)\n    print(\"更新测",
          "time_taken": 22.586239099502563
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\nfrom typing_extensions import ParamSpec\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\nP = ParamSpec('P')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    自动重试装饰器，支持指数退避和可配置异常类型\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @functools.wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        # 最后一次尝试失败，直接抛出原始异常\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise e\n                    \n                    # 记录重试日志\n                    logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次尝试失败: {e}\")\n                    \n                    # 等待指定时间\n                    logger.info(f\"等待 {current_delay} 秒后重试...\")\n                    time.sleep(current_delay)\n                    \n                    # 更新下一次延迟时间\n                    current_delay *= backoff\n            \n            # 这行代码实际上不会执行到\n            raise RuntimeError(\"Unexpected execution path\")\n        \n        return wrapper\n    \n    return decorator\n\n# 异步版本的装饰器\ndef auto_retry_async(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[C",
          "time_taken": 31.507144927978516
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                value = float(self.expression[start:self.pos])\n                self.tokens.append(Token('NUMBER', value))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    # This is a negative sign, not a subtraction\n                    start = self.pos\n                    self.pos += 1\n                    # Parse the following number\n                    while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                        self.pos += 1\n                    value = float(self.expression[start:self.pos])\n                    self.tokens.append(Token('NUMBER', value))\n                else:\n                    self.tokens.append(Token('-', '-'))\n                    self.pos += 1\n      ",
          "time_taken": 21.93496298789978
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 204, in <module>\n  File \"<string>\", line 173, in __exit__\n  File \"<string>\", line 160, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        elif other is None:\n            # Handle comparison with None (shutdown signal)\n            return False\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级、超时等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        if max_workers is None:\n            import multiprocessing\n            max_workers = multiprocessing.cpu_count()\n        \n        self.max_workers = max_workers\n        self._work_queue = queue.PriorityQueue()\n        self._threads: List[threading.Thread] = []\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.append(thread)\n    \n    def _worker(self) -> None:\n        \"\"\"工作线程函数\"\"\"\n        while True:\n            try:\n                # 从队列中获取任务，如果队列为空会阻塞等待\n                task = self._work_queue.get(timeout=1)\n                if task is None:  # 收到关闭信号\n                    break\n                \n                # 执行任务\n                try:\n                    result = task.fn(*task.args, **task.kwargs)\n                    task.future.set_result(result)\n                except Exception as e:\n                    t",
          "time_taken": 111.48238706588745
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, items: list[int], data: dict[str, int]) -> str:\n        return f\"Name: {name}, Age: {",
          "time_taken": 17.896865129470825
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self._stages[name] = fn\n    \n    def stats(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        获取各阶段的统计信息。\n        \n        Returns:\n            包含每个阶段调用次数、平均耗时、错误数的字典\n        \"\"\"\n        result = {}\n        for stage_name, stats in self._stats.items():\n            calls = stats['calls']\n            total_time = stats['total_time']\n            errors = stats['errors']\n            avg_time = total_time / calls if calls > 0 else 0.0\n            result[stage_name] = {\n                'calls': calls,\n                'avg_time': avg_time,\n                'errors': errors\n            }\n        return result\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name, stage_fn in self._stages.items():\n            start_time = time.time()\n            try:\n                if asyncio.iscoroutinefunction(stage_fn):\n                    result = await stage_fn(result)\n                else:\n                    result = stage_fn(result)\n                self._stats[stage_name]['calls'] += 1\n                self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            except Exception as e:\n               ",
          "time_taken": 27.584288120269775
        }
      ],
      "elapsed_seconds": 386.2
    },
    {
      "round": 7,
      "timestamp": 1771012316.2538931,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    它将数组递归地分成两半，分别排序后合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试一般情况\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试重复元素\n    assert merge_sort([2, 2, 2, 2]) == [2, 2, 2, 2]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 16.023473978042603
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 16.68752384185791
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (still in cache)\n",
          "time_taken": 20.563496828079224
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义装饰器参数类型\nRetryConfig = Tuple[int, float, float, Tuple[Type[Exception], ...]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败，\"\n                            f\"将在 {current_delay:.2f} 秒后重试 (尝试 {attempt + 1}/{max_retries})，\"\n                            f\"异常: {type(e).__name__}: {e}\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败，\"\n                            f\"已重试 {max_retries} 次，\"\n                            f\"异常: {type(e).__name__}: {e}\"\n                        )\n                        raise e\n            raise last_exception\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n           ",
          "time_taken": 33.467530965805054
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                self.tokens.append(Token('MINUS', '-'))\n                self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n            self.position += 1\n        number_str = self.expression[start:self.position]\n        try:\n            if '.' in number_str:\n                number = float(number_str)\n            else:\n                ",
          "time_taken": 22.08237910270691
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时等特性。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        thread_name_prefix: 线程名称前缀\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> result = future.result()\n        >>> print(result)  # 输出: 10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, thread_name_prefix: str = \"TaskPool\"):\n        if max_workers is None:\n            import multiprocessing\n            max_workers = multiprocessing.cpu_count()\n        \n        self.max_workers = max_workers\n        self.thread_name_prefix = thread_name_prefix\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._work_queue = queue.PriorityQueue()\n        self._threads: List[threading.Thread] = []\n        self._idle_lock = threading.Lock()\n        self._idle_workers = 0\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            thread = threading.Thread(\n                target=self._worker,\n                name=f\"{thread_name_prefix}-{i}\",\n                daemon=True\n            )\n            thread.start()\n            self._threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数值越小优先级越高）\n            timeout: 任",
          "time_taken": 32.80204486846924
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, items: list[int], mapping: dict[str, int]) -> str:\n        return f\"{x}: {y} - {items} - {",
          "time_taken": 19.08216094970703
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 461.8
    },
    {
      "round": 8,
      "timestamp": 1771012997.225436,
      "passed": 6,
      "total": 8,
      "avg_score": 7.69,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组分成两半，\n    递归地对两半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余的元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([5, 2, 8, 2, 1]) == [1, 2, 2, 5, 8]\n    \n    # 测试原列表不被修改\n    original = [3, 1, 4, 1, 5]\n    sorted_result = merge_sor",
          "time_taken": 18.984816074371338
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的效率问题\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 16.585262060165405
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 20.498499155044556
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数重试包装器\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 重试 {max_retries} 次后仍然失败: {e}\")\n                        raise\n                    logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                    logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n            raise RuntimeError(\"不应该到达这里\")\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            同步函数重试包装器\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as ",
          "time_taken": 31.85874104499817
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 64, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 155, in <module>\n  File \"<string>\", line 145, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 67, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        number_str = self.ex",
          "time_taken": 22.00667095184326
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)  # Fixed: was time.time (function) instead of time.time() (call)\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"用于优先级队列比较\"\"\"\n        # First compare by priority value (lower value = higher priority)\n        if self.priority.value != other.priority.value:\n            return self.priority.value < other.priority.value\n        # If priorities are equal, compare by submission time (earlier = higher priority)\n        return self.submit_time < other.submit_time\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池实现并发执行任务，支持任务优先级、超时控制和优雅关闭。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello World\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._queue_lock = threading.Lock()\n        self._worker_threads: List[threading.Thread] = []\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(tar",
          "time_taken": 302.70051193237305
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果无法识别的类型，尝试使用 isinstance 检查\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        retur",
          "time_taken": 19.56136202812195
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（同步或异步）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 阶段函数\n            data: 输入数据\n            \n        Returns:\n            处理结果\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concur",
          "time_taken": 24.549965143203735
        }
      ],
      "elapsed_seconds": 680.9
    },
    {
      "round": 9,
      "timestamp": 1771013373.101891,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 20.094743967056274
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 16.8867928981781
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 20.41097402572632
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\nfrom typing_extensions import ParamSpec\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\nP = ParamSpec('P')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间会乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"等待 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败，已达到最大重试次数 {max_retries + 1}: {e}\"\n                        )\n                        raise\n            raise last_exception  # 这行代码实际上不会被执行\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in rang",
          "time_taken": 25.367478847503662
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, not a subtraction operator\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position += 1\n                    number_str = self.expression[start:sel",
          "time_taken": 25.44145679473877
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable[..., Any]\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行任务、优雅关闭等功能。\n    使用线程池实现并发执行。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        self._running = False\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        if not self._running:\n            self._running = True\n            # 创建工作线程\n            for _ in range(self.max_workers or 1):\n                thread = threading.Thread(target=self._worker_loop, daemon=True)\n                thread.start()\n                self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                \n                # 执行任务\n                try:\n                    if task.timeout is not None:\n                        result = task.future.result(timeout=task.timeout)\n            ",
          "time_taken": 40.214168071746826
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: x}\n    \n    # 正确调",
          "time_taken": 21.325722694396973
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self._stages[name] = fn\n    \n    def _get_stage_stats(self, stage_name: str) -> Dict[str, Any]:\n        \"\"\"获取阶段统计信息\"\"\"\n        return self._stats[stage_name]\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name, stage_fn in self._stages.items():\n            start_time = time.time()\n            try:\n                if asyncio.iscoroutinefunction(stage_fn):\n                    result = await stage_fn(result)\n                else:\n                    result = stage_fn(result)\n                self._get_stage_stats(stage_name)['calls'] += 1\n                self._get_stage_stats(stage_name)['total_time'] += (time.time() - start_time)\n            except Exception as e:\n                self._get_stage_stats(stage_name)['errors'] += 1\n                self._get_stage_stats(stage_name)['total_time'] += (time.time() - start_time)\n                raise  # 重新抛出异常\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        \"\"\"\n        并发处理一批数据\n        \n        Args:\n            items: 数据列表\n            concurrency: 最大并发数\n            \n        Returns:\n ",
          "time_taken": 24.960818767547607
        }
      ],
      "elapsed_seconds": 375.8
    },
    {
      "round": 10,
      "timestamp": 1771013781.1767309,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的整数列表（升序）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 19.907660961151123
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(1) (不包括结果列表)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 17.533500909805298
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 20.36432695388794
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional, Coroutine\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Coroutine[Any, Any, T]]\nFunc = Union[SyncFunc, AsyncFunc]\n\nasync def async_sleep(delay: float) -> None:\n    \"\"\"异步睡眠\"\"\"\n    await asyncio.sleep(delay)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Func], Func]:\n    \"\"\"\n    自动重试装饰器\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避倍数\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n        \n    Example:\n        @auto_retry(max_retries=3, delay=1.0, backoff=2.0, exceptions=(ValueError, TimeoutError))\n        def risky_function():\n            # 可能失败的函数\n            pass\n    \"\"\"\n    \n    def decorator(func: Func) -> Func:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"异步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {type(e).__name__}: {e}\")\n                        raise e\n                    \n                    logger.warning(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试失败: {type(e).__name__}: {e}\")\n                    logger.info(f\"等待 {current_delay:.2f} 秒后进行第 {attempt + 2} 次重试\")\n                    \n                    await async_s",
          "time_taken": 55.91276025772095
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 140, in <module>\n  File \"<string>\", line 131, in evaluate\n  File \"<string>\", line 33, in tokenize\n  File \"<string>\", line 58, in _read_number\nValueError: could not convert string to float: ''",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        value = self.expression[start:self.pos]\n       ",
          "time_taken": 21.856284141540527
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列排序\"\"\"\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行异步任务，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown = False\n        self._lock = threading.Lock()\n        \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL,\n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数位置参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 当任务池已关闭时抛出\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"TaskPool has been shut down\")\n            \n        task = Task(fn, args, kwargs, priority, timeout)\n        \n        def run_task():\n            try:\n                result = ",
          "time_taken": 44.40056300163269
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"\n    检查值是否匹配期望的类型\n    \n    Args:\n        value: 要检查的值\n        expected_type: 期望的类型\n        \n    Returns:\n        bool: 如果值匹配类型返回True，否则返回False\n    \"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 如果没有原型（普通类型）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:  # 如果没有参数类型，只检查是否为list\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:  # 如果没有参数类型，只检查是否为dict\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类",
          "time_taken": 22.767277002334595
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功执行的统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n            \n        except Exception as e:\n            # 记录错误统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n    ",
          "time_taken": 25.34556794166565
        }
      ],
      "elapsed_seconds": 408.0
    },
    {
      "round": 11,
      "timestamp": 1771014466.322419,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 已排序的左列表\n        right: 已排序的右列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素并合并\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 19.845699787139893
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算（索引为2）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 17.040602207183838
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为2的LRU缓存\n    cache = LRUCache(2)\n    \n    # 测试基本功能\n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    print(cache.get(1))  # 应该输出 \"value1\"\n    \n    # 测试容量限制\n    cache.put(3, \"value3\")  # 应该淘汰key=2\n    print(cache.get(2))  # 应该输出 None\n    \n    # 测试TTL过期\n    cache.put(4, \"value4\", ttl=1)  # 1秒后过期\n    print(cache.get(4))  # 应该输出 \"value4\"\n    time.sleep(1.1)  # 等待过期\n    print(cache.get(4))  # 应该输出 None\n    \n    # 测试线程安全\n    def test_thread_safety():\n        for i in range(100):\n            cache.put(i, f\"value{i}\")\n            if i > 50:\n                cache.get(i-50)\n    \n    # 创建多个线程测试\n    threads = []\n    for _ in range(5):\n        t = threading.Thread(target=test_thread_safety)\n        threads.append(t)\n        t.start()\n    \n    for t in threads:\n        t.join()\n    \n    print(\"所有测试完成\")\n",
          "time_taken": 19.58541178703308
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Coroutine, Type, Tuple, Union, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"等待 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败: {e}\"\n                        )\n                        raise\n            raise last_exception\n            \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n          ",
          "time_taken": 29.04613494873047
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                self.tokens.append(Token('MINUS', '-'))\n                self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        value = self.expression[start:self.pos]\n        self.tokens.append(Token('NUMBER', float(value)))\n\nclass Parser:\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.pos = 0\n    \n    ",
          "time_taken": 22.304179191589355
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    fn: Callable[..., Any]\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"用于优先级队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持任务提交、批量执行、优雅关闭等功能，基于线程实现。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._queue_lock = threading.Lock()\n        self._worker_threads: List[threading.Thread] = []\n        self._initialize_workers()\n    \n    def _initialize_workers(self) -> None:\n        \"\"\"初始化工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self) -> None:\n ",
          "time_taken": 42.84616422653198
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型 (包括 Optional)\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:  # 没有指定元素类型\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:  # 没有指定键值类型\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数，会进行运行时类型检查\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名并绑定参数\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise Type",
          "time_taken": 22.552736043930054
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self._stages[name] = fn\n    \n    def _get_stage_stats(self, name: str):\n        \"\"\"获取阶段统计信息\"\"\"\n        return self._stats[name]\n    \n    async def _process_stage(self, name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_func = self._stages[name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 更新统计信息\n            stats = self._get_stage_stats(name)\n            stats['calls'] += 1\n            stats['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            stats = self._get_stage_stats(name)\n            stats['calls'] += 1\n            stats['total_time'] += (time.time() - start_time)\n            stats['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n         ",
          "time_taken": 28.696391820907593
        }
      ],
      "elapsed_seconds": 685.1
    },
    {
      "round": 12,
      "timestamp": 1771015061.8229601,
      "passed": 7,
      "total": 8,
      "avg_score": 7.81,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\n\ndef merge_sort(arr: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    对输入列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的数字列表（支持整数和浮点数）\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([3.14, 2.71, 1.41])\n        [1.41, 2.71, 3.14]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两部分\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两部分\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[Union[int, float]], right: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 已排序的左列表\n        right: 已排序的右列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [3.14, 2.71, 1.41, 0.57],  # 浮点数列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge",
          "time_taken": 22.441927909851074
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算剩余的斐波那契数\n    # 避免指数级递归，时间复杂度O(n)，空间复杂度O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证函数正确性\n    assert fibonacci(0) == []\n    assert fibonacci(1) == [0]\n    assert fibonacci(2) == [0, 1]\n    assert fibonacci(5) == [0, 1, 1, 2, 3]\n    assert fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    print(\"所有测试通过！\")\n",
          "time_taken": 15.125782012939453
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 16.800107955932617
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \n            Args:\n                *args: 函数参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常，如果重试次数用尽\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 重试 {max_retries} 次后仍然失败，抛出原始异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试中失败: {e}\")\n           ",
          "time_taken": 33.953852891922
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (se",
          "time_taken": 24.873516082763672
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator, Tuple\nfrom collections import deque\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池，基于线程实现。\n    \n    支持提交单个任务、批量执行任务、优雅关闭、超时控制和任务优先级。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池。\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._work_queue = queue.PriorityQueue()\n        self._threads = set()\n        self._idle_semaphore = threading.Semaphore(0)\n        self._worker_count = 0\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.add(thread)\n            self._worker_count += 1\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池。\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        Raises:\n            RuntimeError: 如果任务池已经关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"Cannot submit tasks to a shutdown pool\")\n        \n        future = Future()\n        task = _Task(fn, args, kwargs, future, priority, timeout)\n        self._work_queue.put(task)\n        self._",
          "time_taken": 54.452521085739136
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果origin不是已知的容器类型，尝试使用isinstance\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, hobbies: list[str], info: dict[str, int]) -> str:\n     ",
          "time_taken": 18.426440000534058
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": false,
          "score": 2.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 55, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/runners.py\", line 44, in run\n    return loop.run_until_complete(main)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py\", line 642, in run_until_complete\n    return future.result()\n  File \"<string>\", line 41, in test\nNameError: name 'AsyncPipeline' is not defined",
          "code_generated": "# Assuming results should be defined somewhere, here's a complete corrected version\n# This appears to be part of a larger function that processes results and handles exceptions\n\ndef process_stage_results(stage_name, start_time, results):\n    # Process results and handle exceptions\n    for i, result in enumerate(results):\n        if isinstance(result, Exception):\n            # Handle the exception properly\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise result  # Re-raise the exception\n    \n    # If we get here, no exceptions were raised\n    self.stats_data[stage_name]['calls'] += 1\n    self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n\n# Alternative version if results is already defined in context\ndef process_stage_results_v2(stage_name, start_time, results):\n    # Ensure results is defined and not empty\n    if not results:\n        return\n    \n    # Process results and handle exceptions\n    for i, result in enumerate(results):\n        if isinstance(result, Exception):\n            # Handle the exception properly\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise result  # Re-raise the exception\n    \n    # If we get here, no exceptions were raised\n    self.stats_data[stage_name]['calls'] += 1\n    self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n",
          "time_taken": 200.8800127506256
        }
      ],
      "elapsed_seconds": 595.4
    },
    {
      "round": 13,
      "timestamp": 1771016087.77509,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度为 O(n log n)，空间复杂度为 O(n)。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以保证纯函数特性\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [1, 1, 1, 1],          # 重复元素\n        [-3, -1, -4, -1, -5]   # 负数列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {test_case} -> {sorted_result}\")\n        \n        # 验证原列表未被修改\n        print(f\"原列表未变: {test_case}\")\n        print()\n",
          "time_taken": 19.461597204208374
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算（索引为2）\n    for i in range(2, n):\n        # 当前数 = 前一个数 + 前两个数\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 16.51590609550476
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 19.699260711669922
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器函数\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            重试包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数重试包装器\n            \n            Args:\n                *args: 函数参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常，如果重试次数用尽\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                        logger",
          "time_taken": 28.051992893218994
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "class Tokenizer:\n    def __init__(self, expression):\n        self.expression = expression\n        self.position = 0\n    \n    def tokenize(self):\n        tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isdigit() or char == '.':\n                # Parse number\n                start = self.position\n                while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                    self.position += 1\n                tokens.append(('NUMBER', float(self.expression[start:self.position])))\n            elif char == '+':\n                tokens.append(('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign or minus operator\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, but we need to be careful about parentheses\n                    self.position += 1\n                    # Look at the next character to determine what to do\n                    if self.position < len(self.expression):\n                        next_char = self.expression[self.position]\n                        if next_char.isdigit() or next_char == '.':\n                            # Parse the following number with negative sign\n                            start = self.position\n                            while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                                self.position += 1\n                            tokens.append(('NUMBER', -float(self.expression[start:self.position])))\n                        elif next_char == '(':\n                            # This is a case like -(3+2), we'll treat the minus as operator and let the parser handle it\n                            tokens.append(",
          "time_taken": 210.36000275611877
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom queue import PriorityQueue\nimport functools\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行任务、优雅关闭等操作。\n    使用线程池实现并发执行，支持任务优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self._max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._tasks: List[Task] = []\n        self._task_queue = PriorityQueue()\n        self._task_count = 0\n        self._task_lock = threading.Lock()\n        self._queue_processor = None\n        self._queue_processor_lock = threading.Lock()\n        self._queue_processor_stop_event = threading.Event()\n        \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已经关闭\n        \"\"\"\n        with self._shutdown_lock:\n            if self._shutdown:\n                raise RuntimeError(\"TaskPool has been shutdown\")\n        \n        future = Future()\n        task = Task(fn, args, kwargs, future, priority, timeout)\n        \n        # 将任务放入优先级队列\n        with self._task_lock:\n            self._task_queue.put((priority, self._",
          "time_taken": 283.1477460861206
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（包括 Optional）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配第一个参数类型\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配参数类型\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名和绑定参数\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查每个参数的类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n         ",
          "time_taken": 21.220285892486572
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发批量处理\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self._stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_func = self._stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 更新统计信息\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += time.time() - start_time\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['errors'] += 1\n            self._stats[stage_name]['total_time'] += time.time() - start_time\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._process_stage(stage_name, result)\n       ",
          "time_taken": 50.26770496368408
        }
      ],
      "elapsed_seconds": 1025.9
    },
    {
      "round": 14,
      "timestamp": 1771016597.785782,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组分成两半，\n    递归地对两半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([2, 2, 2, 2]) == [2, 2, 2, 2]\n    \n    # 测试原列表不被修改\n    original = [3, 1, 4, 1, 5]\n    sorted_result = merge_sort(original)\n ",
          "time_taken": 19.214402198791504
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算剩余的斐波那契数\n    # 从第3个数开始计算\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 17.309133052825928
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 17.61016869544983
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                retries = 0\n                current_delay = delay\n                \n                while True:\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        retries += 1\n                        if retries > max_retries:\n                            logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                            raise e\n                        \n                        logger.warning(\n                            f\"函数 {func.__name__} 第 {retries} 次重试失败: {e}，\"\n                            f\"将在 {current_delay:.2f} 秒后重试\"\n                        )\n                        \n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                        \n            return async_wrapper\n        else:\n            # 同步函数处理\n            @functools.wraps(func)\n            def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n                retries ",
          "time_taken": 30.410168886184692
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 158, in <module>\n  File \"<string>\", line 148, in evaluate\n  File \"<string>\", line 37, in tokenize\n  File \"<string>\", line 75, in _read_number\nValueError: could not convert string to float: ''",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_number(is_negative=True)\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Invalid character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self, is_negative: bool = False):\n        start = self.pos\n        dot_count = 0\n        \n        while self.pos < len(self.expression):\n            char ",
          "time_taken": 22.168334007263184
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union, Tuple\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优雅关闭、超时控制和优先级支持。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count()\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)\n        self._lock = threading.Lock()\n        self._active_workers = 0\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数值越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n        \"\"\"\n        if self._shutdown_event.is_set():\n            raise RuntimeError(\"TaskPool已关闭，无法提交新任务\")\n        \n        task = Task(fn, args, kwargs, priority, timeout)\n        self._task_queue.put(task)\n        return task.future\n    \n    def map(s",
          "time_taken": 41.00466704368591
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例使用\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, z: typing.Optional[typing.List[int]] = None) -> str:\n        return f\"x={x}, y={y}, z={",
          "time_taken": 17.644554138183594
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持按顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage_name, resu",
          "time_taken": 25.84667706489563
        }
      ],
      "elapsed_seconds": 509.9
    },
    {
      "round": 15,
      "timestamp": 1771017151.4658859,
      "passed": 8,
      "total": 8,
      "avg_score": 8.69,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的排序算法，采用分治法思想。\n    将数组递归地分成两半，分别排序后再合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 2, 8, 1],          # 小列表\n        [1, 1, 1, 1],          # 重复元素\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5]        # 已排序列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_arr}\")\n        # 验证原列表未被修改\n        assert test_case == or",
          "time_taken": 17.902225017547607
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 16.89503812789917
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 20.63722515106201
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间会乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        # 检查是否为异步函数\n        if asyncio.iscoroutinefunction(func):\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.warning(\n                                f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries}): {e}. \"\n                                f\"将在 {current_delay:.2f} 秒后重试...\"\n                            )\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.error(\n                                f\"函数 {func.__name__} 最终失败 (已重试 {max_retries} 次): {e}\"\n                            )\n                            raise\n                raise last_exception  # 这一行实际上不会执行到\n        ",
          "time_taken": 26.410071849822998
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n        self.current_char = self.expression[self.pos] if self.expression else None\n\n    def advance(self):\n        \"\"\"移动到下一个字符\"\"\"\n        self.pos += 1\n        if self.pos >= len(self.expression):\n            self.current_char = None\n        else:\n            self.current_char = self.expression[self.pos]\n\n    def skip_whitespace(self):\n        \"\"\"跳过空白字符\"\"\"\n        while self.current_char and self.current_char.isspace():\n            self.advance()\n\n    def read_number(self) -> float:\n        \"\"\"读取数字（包括浮点数）\"\"\"\n        num_str = \"\"\n        while self.current_char and (self.current_char.isdigit() or self.current_char == '.'):\n            num_str += self.current_char\n            self.advance()\n        return float(num_str)\n\n    def tokenize(self) -> List[Token]:\n        \"\"\"将表达式转换为token列表\"\"\"\n        self.pos = 0\n        self.current_char = self.expression[self.pos] if self.expression else None\n        tokens = []\n\n        while self.current_char:\n            self.skip_whitespace()\n\n            if self.current_char is None:\n                break\n\n            if self.current_char.isdigit() or self.current_char == '.':\n                # 读取数字\n                num = self.read_number()\n                tokens.append(Token(\"NUMBER\", num))\n            elif self.current_char == '+':\n                tokens.append(Token(\"+\", \"+\"))\n                self.advance()\n            elif self.current_char == '-':\n                # 检查是否是负号\n                if not tokens or tokens[-1].type in [\"+\", \"-\", \"*\", \"/\", \"(\"]:\n                    # 这是一个负号，读取后面跟着的数字\n                    self.advance()\n                 ",
          "time_taken": 27.7084801197052
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom collections import defaultdict\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池，使用线程实现。\n    \n    该类提供了一个可复用的线程池，支持提交单个任务、批量任务执行，\n    并支持任务超时和优先级功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        if max_workers is None:\n            import multiprocessing\n            max_workers = multiprocessing.cpu_count()\n        \n        self.max_workers = max_workers\n        self._work_queue = queue.PriorityQueue()\n        self._threads = set()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            t = threading.Thread(target=self._worker, daemon=True)\n            t.start()\n            self._threads.add(t)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池。\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，可用于获取任务结果或检查任务状态\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"Cannot schedule new tasks after shutdown\")\n        \n        future = Future()\n        # 使用计数器确保相同优先级的任务按提交顺序执行\n        task = (priority, self._counter, fn, args, kwargs, future, timeout)\n        self._counter += 1\n        self._work_queue.put(task)\n        return future\n    \n    def map(self, fn: Callable, iterable: Iterator, timeout: Optional[float] = None) -> List[Any]:\n        \"\"\"\n        批量执行任务，返回结果列表。\n        \n        Args:\n            fn: 要执行的函数\n            iterable: 参数迭代器\n      ",
          "time_taken": 133.25655794143677
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, items: list[int], mapping: dict[str, int]) -> str:\n        return f\"{x}: {y} -",
          "time_taken": 19.768715143203735
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发批量处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concu",
          "time_taken": 28.81722593307495
        }
      ],
      "elapsed_seconds": 553.6
    },
    {
      "round": 16,
      "timestamp": 1771017558.387721,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治策略的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 已排序的左列表\n        right: 已排序的右列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原列表: {original}\")\n        print(f\"  排序后: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 19.389515161514282
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算后续的斐波那契数\n    # 使用两个变量来存储前两个数，避免存储整个列表，节省空间\n    prev2, prev1 = 0, 1\n    \n    # 从第3个数开始计算\n    for i in range(2, n):\n        current = prev1 + prev2\n        result.append(current)\n        # 更新前两个数\n        prev2, prev1 = prev1, current\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 17.446423053741455
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 20.21465516090393
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise  # 重新抛出原始异常\n                    \n                    logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次尝试失败: {e}\")\n                    logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                    \n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n            \n            # 理论上不会执行到这里，但为了类型检查添加\n            raise RuntimeError(\"重试逻辑异常\")\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            同步函数包装器\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n  ",
          "time_taken": 28.614423036575317
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 177, in <module>\n  File \"<string>\", line 167, in evaluate\n  File \"<string>\", line 37, in tokenize\n  File \"<string>\", line 77, in _read_number\nValueError: invalid literal for int() with base 10: '-'",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_number(is_negative=True)\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self, is_negative: bool = False):\n        start = self.position\n        has_decimal = False\n      ",
          "time_taken": 24.238935708999634
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n\n@total_ordering\n@dataclass\nclass PriorityTask:\n    \"\"\"带优先级的任务包装类\"\"\"\n    priority: int\n    task_id: int\n    future: Future\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float] = None\n\n    def __lt__(self, other):\n        if self.priority == other.priority:\n            return self.task_id < other.task_id\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优雅关闭、超时控制和优先级管理。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._task_counter = 0\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_threads: List[threading.Thread] = []\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for i in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown:\n            try:\n                # 从优先级队列获取任务\n                priority_task = self._task_queue.get(timeout=1.0)\n                try:",
          "time_taken": 39.232985973358154
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例使用\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(name: str, age: int, scores: list[int], data: dict[str, int]) -> str:\n        return f\"Name: {name}, Ag",
          "time_taken": 20.584182024002075
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持按顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self._stages[name] = fn\n    \n    async def _process_single_stage(self, name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            name: 阶段名称\n            fn: 阶段函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self._stats[name]['calls'] += 1\n            self._stats[name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self._stats[name]['calls'] += 1\n            self._stats[name]['total_time'] += (time.time() - start_time)\n            self._stats[name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for name, fn in self._stages.items():\n            result = await self._process_single_stage(name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        \"\"\"\n        并发处理一批数据\n    ",
          "time_taken": 27.67192816734314
        }
      ],
      "elapsed_seconds": 406.9
    },
    {
      "round": 17,
      "timestamp": 1771018023.763507,
      "passed": 7,
      "total": 8,
      "avg_score": 8.19,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([2, 2, 2, 2]) == [2, 2, 2, 2]\n    \n    # 测试原列表不被修改\n    original = [3, 1, 4, 1, 5]\n    sorted_result = merge_sort(original)\n    assert original == [3, 1, 4, 1, 5]  # 原列表不变\n    assert sorted_result == [1, 1, 3,",
          "time_taken": 18.518274784088135
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 16.917503118515015
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    \n    print(cache.get(1))  # Should return \"value1\"\n    \n    cache.put(3, \"value3\")  # This should evict key 2\n    print(cache.get(2))  # Should return None (evicted)\n    \n    # Test TTL functionality\n    cache.put(4, \"value4\", ttl=1)  # 1 second TTL\n    print(cache.get(4))  # Should return \"value4\"\n    \n    time.sleep(1.1)  # Wait for TTL to expire\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test thread safety\n    import concurrent.futures\n    \n    def worker(thread_id):\n        for i in range(10):\n            cache.put(f\"{thread_id}-{i}\", f\"value-{thread_id}-{i}\")\n            cache.get(f\"{thread_id}-{i}\")\n    \n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        futures = [executor.submit(worker, i) for i in range(5)]\n        for future in futures:\n            future.result()\n    \n    print(f\"Cache size",
          "time_taken": 22.324514865875244
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                retries = 0\n                current_delay = delay\n                \n                while True:\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        retries += 1\n                        if retries > max_retries:\n                            logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                            raise e\n                        \n                        logger.warning(\n                            f\"函数 {func.__name__} 第 {retries} 次重试失败: {e}. \"\n                            f\"等待 {current_delay:.2f} 秒后重试...\"\n                        )\n                        \n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                        \n            return async_wrapper\n        else:\n            # 同步函数处理\n            @functools.wraps(func)\n            def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            ",
          "time_taken": 28.09388518333435
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 70, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 175, in <module>\n  File \"<string>\", line 165, in evaluate\n  File \"<string>\", line 36, in tokenize\n  File \"<string>\", line 73, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative number\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        \n        while self.position < len(self.expression) and (\n            self.exp",
          "time_taken": 23.33234214782715
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        # Handle comparison with None values (sentinel for shutdown)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现并发执行任务，支持任务优先级、超时控制和优雅关闭。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._lock = threading.Lock()\n        self._running = False\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        if self._running:\n            return\n            \n        self._running = True\n        for i in range(self.max_workers):\n            thread = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            thread.daemon = True\n            thread.start()\n            self._workers.append(thread)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 使用超时机制避免无限等待\n                task = self._task_queue.get(timeout=1.0)\n                if task is None:  # 退出信号\n                    break\n                \n                # 执行任务\n             ",
          "time_taken": 128.94435620307922
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    # 测试基本类型\n    @type_check\n    def add(a: int, b: int) -> int:\n        return a + b\n    \n    print(add(1, 2))  # 正常运行\n    \n    # 测试列表",
          "time_taken": 23.266005039215088
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段并记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功执行的统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, res",
          "time_taken": 31.45024800300598
        }
      ],
      "elapsed_seconds": 465.3
    },
    {
      "round": 18,
      "timestamp": 1771018718.354026,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法\n    \n    归并排序是一种基于分治思想的稳定排序算法。它将数组分成两半，\n    递归地对两半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([5, 2, 8, 2, 1]) == [1, 2, 2, 5, 8]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 17.106341123580933
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个斐波那契数\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 16.61039900779724
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (still in cache)\n",
          "time_taken": 17.9290668964386
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \n            Args:\n                *args: 函数参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常（如果重试次数用尽）\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                    \n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 重试 {max_retries} 次后仍然失败: {e}\")\n                        raise\n                    \n                    logger.warning(f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_ret",
          "time_taken": 35.608154296875
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                value = float(self.expression[start:self.position])\n                self.tokens.append(Token('NUMBER', value))\n            \n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.position += 1\n            \n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Parse the following number\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position",
          "time_taken": 23.616328954696655
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import ThreadPoolExecutor\nfrom threading import Event\n\n@dataclass\nclass Task:\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int\n    timeout: Optional[float] = None\n    \n    def __lt__(self, other):\n        # Handle None comparisons\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = Event()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._initialize_workers()\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从优先队列中获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 关闭信号\n                    # Put back the sentinel None to maintain queue size\n                    self._task_queue.put(task)\n                    break\n                \n                # 执行任务\n                try:\n                    if task.timeout:\n                        result = self._executor.submit(\n   ",
          "time_taken": 164.5005989074707
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:  # 无参数的 List\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:  # 无参数的 Dict\n            return True\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例使用\nif __name__ == \"__main__",
          "time_taken": 18.767212867736816
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持添加处理阶段、顺序执行和批量并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n        return result\n    \n    async def process_batch(self, it",
          "time_taken": 25.67928385734558
        }
      ],
      "elapsed_seconds": 694.5
    },
    {
      "round": 19,
      "timestamp": 1771031885.2417521,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度：O(n)，空间复杂度：O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 168.06630086898804
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序结果: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 179.99697184562683
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 174, in <module>\n  File \"<string>\", line 166, in evaluate\n  File \"<string>\", line 58, in tokenize\nTypeError: peek() takes 1 positional argument but 2 were given",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    END = \"END\"\n\nclass Token:\n    def __init__(self, type_: str, value: Union[float, str]):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens: List[Token] = []\n    \n    def peek(self) -> str:\n        if self.pos < len(self.expression):\n            return self.expression[self.pos]\n        return \"\"\n    \n    def consume(self) -> str:\n        if self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            self.pos += 1\n            return char\n        return \"\"\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.pos = 0\n        \n        while self.pos < len(self.expression):\n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                number_str = \"\"\n                while self.pos < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                    number_str += self.consume()\n                self.tokens.append(Token(TokenType.NUMBER, float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(TokenType.PLUS, '+'))\n                self.consume()\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.peek(1) == '(' or self.peek(1) == '+' or self.peek(1) == '-' or self.peek(1) == '*' or self.peek(1) == '/':\n                    # This is a negative sign, parse the following number\n                    self.consume()  # consume '-'\n                    number_str = \"-\"\n      ",
          "time_taken": 117.76044797897339
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（如 Optional[X] 等价于 Union[X, None]）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有泛型参数，只检查是否为 list\n        if not args:\n            return isinstance(value, list)\n        # 检查每个元素是否匹配泛型参数\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有泛型参数，只检查是否为 dict\n        if not args:\n            return isinstance(value, dict)\n        # 检查每个键值对是否匹配泛型参数\n        return all(\n            _matches_type(k, args[0]) and _matches_type(v, args[1]) \n            for k, v in value.items()\n        )\n    \n    # 兜底处理：如果是普通类型则使用 isinstance 检查\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    \n    # 其他情况返回 True（不进行严格检查）\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检",
          "time_taken": 35.59381914138794
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Union\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持添加阶段、顺序执行和批量并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name, stage_fn in self.stages.items():\n            start_time = time.time()\n            try:\n                if asyncio.iscoroutinefunction(stage_fn):\n                    result = await stage_fn(result)\n                else:\n                    result = stage_fn(result)\n                self.stats_data[stage_name]['calls'] += 1\n                self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            except Exception as e:\n                self.stats_data[stage_name]['errors'] += 1\n                self.stats_data[stage_name]['calls'] += 1\n                self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n                raise e\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        \"\"\"\n        并发处理一批数据\n        \n        Args:\n            items: 数据列表\n            concurrency: 并发数限制\n            \n        Returns:\n            处理后的数据列表\n        \"\"\"\n        semaphore = asyncio.Semaphore(concurrency)\n        \n        async def process_it",
          "time_taken": 20.412960052490234
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (still in cache)\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 158.0344638824463
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 指数退避因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"异步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise\n                    \n                    logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                    logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n                    \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"同步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数",
          "time_taken": 146.8029408454895
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable[..., Any]\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行任务、优雅关闭等操作。\n    使用线程实现并发执行。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count()\n        self._work_queue = queue.PriorityQueue()\n        self._threads: List[threading.Thread] = []\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.append(thread)\n    \n    def submit(self, fn: Callable[..., Any], *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"TaskPool已关闭，无法提交新任务\")\n        \n        task = Task(fn, args, kwargs, priority, timeout)\n        self._work_queue.put(task)\n        return task.future\n    \n    def map(self, fn: Callable[..., Any], iterable: Union[List, tuple]) -> List[Any]:\n        \"\"\"\n        批量执行任务\n        \n        Args:\n",
          "time_taken": 104.53620767593384
        }
      ],
      "elapsed_seconds": 374.0
    },
    {
      "round": 20,
      "timestamp": 1771032297.375396,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 避免了指数级递归的效率问题\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率：大数值测试\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 171.22607421875
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\n\ndef merge_sort(arr: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    实现归并排序算法\n    \n    归并排序是一种基于分治思想的稳定排序算法。它将数组递归地分成两半，\n    对每一半分别进行排序，然后将两个已排序的子数组合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的数字列表（支持整数和浮点数）\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([3.14, 2.71, 1.41])\n        [1.41, 2.71, 3.14]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[Union[int, float]], right: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    合并两个已排序的列表\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含浮点数的列表\n    assert merge_sort([3.14, 2.71, 1.41, 0.57]) ",
          "time_taken": 186.25313806533813
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type_: str, value: Union[float, str]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.current_char = self.expression[self.pos] if self.expression else None\n    \n    def advance(self):\n        \"\"\"Move to the next character.\"\"\"\n        self.pos += 1\n        if self.pos >= len(self.expression):\n            self.current_char = None\n        else:\n            self.current_char = self.expression[self.pos]\n    \n    def skip_whitespace(self):\n        \"\"\"Skip whitespace characters.\"\"\"\n        while self.current_char and self.current_char.isspace():\n            self.advance()\n    \n    def read_number(self) -> float:\n        \"\"\"Read a number (including decimals).\"\"\"\n        num_str = \"\"\n        while self.current_char and (self.current_char.isdigit() or self.current_char == '.'):\n            num_str += self.current_char\n            self.advance()\n        return float(num_str)\n    \n    def tokenize(self) -> List[Token]:\n        \"\"\"Convert the expression string into a list of tokens.\"\"\"\n        tokens = []\n        \n        while self.current_char:\n            self.skip_whitespace()\n            \n            if self.current_char is None:\n                break\n                \n            if self.current_char.isdigit() or self.current_char == '.':\n                tokens.append(Token(TokenType.NUMBER, self.read_number()))\n            elif self.current_char == '+':\n                tokens.append(Token(TokenType.PLUS, '+'))\n                self.advance()\n            elif self.current_char == '-':\n                # C",
          "time_taken": 122.20963525772095
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    \n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, data: list[int], config: dict[str, int]) -> str:\n        return f\"{x}: {y}: {d",
          "time_taken": 33.69898581504822
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持添加处理阶段、顺序执行和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录性能统计\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(st",
          "time_taken": 21.248655080795288
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 160.46134495735168
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"等待 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}\"\n                        )\n                        raise\n            raise last_exception  # 这行代码实际上不会执行到\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    r",
          "time_taken": 151.5921630859375
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数值越小优先级越高\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级、超时等特性。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数位置参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，可用于获取任务结果\n        \"\"\"\n        if not self._running:\n            raise RuntimeError(\"TaskPool已经关闭，无法提交新任务\")\n        \n        task = Task(fn, args, kwargs, priority, timeout)\n        \n        # 将",
          "time_taken": 160.6137979030609
        }
      ],
      "elapsed_seconds": 412.1
    },
    {
      "round": 21,
      "timestamp": 1771032502.18149,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 172.52291083335876
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组分成两半，\n    递归地对两半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 2, 8, 1],          # 小列表\n        [1, 1, 1, 1],          # 重复元素\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5]        # 已排序列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原列表: {original}\")\n        prin",
          "time_taken": 185.350084066391
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.pos < len(self.expression):\n            return self.expression[self.pos]\n        return ''\n    \n    def advance(self) -> str:\n        if self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            self.pos += 1\n            return char\n        return ''\n    \n    def skip_whitespace(self):\n        while self.peek().isspace():\n            self.advance()\n    \n    def parse_number(self) -> Token:\n        start = self.pos\n        while self.peek() and (self.peek().isdigit() or self.peek() == '.'):\n            self.advance()\n        value = float(self.expression[start:self.pos])\n        return Token('NUMBER', value)\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        tokens = []\n        \n        while self.pos < len(self.expression):\n            self.skip_whitespace()\n            \n            if self.peek() == '':\n                break\n                \n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                tokens.append(self.parse_number())\n            elif char == '+':\n                tokens.append(Token('+', '+'))\n                self.advance()\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos-1] in '(+-*/':\n                    # It's a negative sign, parse the following number\n                    self.advance()  # consume the '-'\n                    if self.peek() == '.':\n                        # Handle negative decimal like -3.14\n                  ",
          "time_taken": 98.0066270828247
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型（如 Union[int, str] 或 Optional[int]）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型（如 list[int]）\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型（如 dict[str, int]）\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(\n            _matches_type(k, args[0]) and _matches_type(v, args[1]) \n            for k, v in value.items()\n        )\n    \n    # 兜底情况\n    return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数，会在运行时检查参数和返回值类型\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n    ",
          "time_taken": 38.67913889884949
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self._stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self._stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            self._stats[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的最终数据\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._process_stage(stage_name, result)\n    ",
          "time_taken": 22.15143394470215
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \n            Args:\n                *args: 函数参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常，如果重试次数用尽\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                    \n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 重试 {max_retries} 次后仍然失败: {e}\")\n                        raise e\n                    \n                    logger.warning(f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_ret",
          "time_taken": 148.57752394676208
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    print(cache.get(1))  # Should return \"value1\"\n    \n    # Test capacity limit\n    cache.put(3, \"value3\")  # This should remove key 2\n    print(cache.get(2))  # Should return None\n    \n    # Test TTL functionality\n    cache.put(4, \"value4\", ttl=1)  # 1 second TTL\n    print(cache.get(4))  # Should return \"value4\"\n    time.sleep(1.1)\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test that get returns None for non-existent keys\n    print(cache.get(5))  # Should return None\n",
          "time_taken": 162.3943030834198
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池实现并发任务执行，支持任务优先级、超时控制等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        self.max_workers = max_workers or threading.active_count()\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_threads: List[threading.Thread] = []\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，可用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._sh",
          "time_taken": 94.45194220542908
        }
      ],
      "elapsed_seconds": 204.7
    },
    {
      "round": 22,
      "timestamp": 1771032554.787049,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n\n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n\n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self.pos",
          "time_taken": 48.71763205528259
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom concurrent.futures import Future\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    fn: Callable[..., Any]\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"优先级比较，数字越大优先级越高\"\"\"\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count() + 4\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._lock = threading.Lock()\n        self._running = False\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self) -> None:\n        \"\"\"启动工作线程\"\"\"\n        self._running = True\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self) -> None:\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从队列获取任务，超时时间为1秒\n                task = self._task_queue.get(timeout=1)\n                self._execute_task(task)\n                self._task_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                # 记录错误但不中断工作线",
          "time_taken": 30.213176250457764
        }
      ],
      "elapsed_seconds": 52.5
    },
    {
      "round": 23,
      "timestamp": 1771032902.155803,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 任务优先级\n    - 任务超时\n    - 优雅关闭\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._work_queue = queue.PriorityQueue()\n        self._threads: List[threading.Thread] = []\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._started = False\n        self._worker_count = 0\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        self._start_threads()\n    \n    def _start_threads(self):\n        \"\"\"启动工作线程\"\"\"\n        if self._started:\n            return\n            \n        with self._worker_lock:\n            if self._started:\n                return\n                \n            for _ in range(self.max_workers):\n                thread = threading.Thread(target=self._worker_loop, daemon=True)\n                thread.start()\n                self._threads.append(thread)\n            \n            self._started = True\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while True:\n            try:\n                # 从队列中获取任务，超时时间设置为1秒\n                task = self._work_queue.get(timeout=1)\n                if task is",
          "time_taken": 265.05030393600464
        }
      ],
      "elapsed_seconds": 347.3
    },
    {
      "round": 24,
      "timestamp": 1771032933.675549,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Union, TypeVar\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport logging\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    fn: Callable[..., Any]\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"优先级比较，数字越大优先级越高\"\"\"\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._lock = threading.Lock()\n        self._running = False\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self) -> None:\n        \"\"\"启动工作线程\"\"\"\n        self._running = True\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self) -> None:\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从队列获取任务，超时时间为1秒\n                task = self._task_queue.get(timeout",
          "time_taken": 30.85515809059143
        }
      ],
      "elapsed_seconds": 31.5
    },
    {
      "round": 25,
      "timestamp": 1771033366.629518,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 415.7583968639374
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n                \n            elif char in '+-*/()':\n                self.tokens.append(Token(char, char))\n                self.position += 1\n                \n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n\nclass Parser:\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.position = 0\n    \n    def peek(self) -> Token:\n        if self.position < len(self.tokens):\n            return self.tokens[self.position]\n        return None\n    \n    def consume(self, expected_type: str) -> Token:\n        token = self.peek()\n        if token and token.type == expected_type:\n            self.position += 1\n            return token\n        raise ValueError(f",
          "time_taken": 370.23334097862244
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的排序算法，采用分治法策略。\n    将数组递归地分成两半，分别排序后合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本，确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # 递归排序左右两部分\n    left_sorted = merge_sort(left)\n    right_sorted = merge_sort(right)\n    \n    # 合并已排序的两部分\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 已排序的左列表\n        right: 已排序的右列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_arr}\")\n        # 验证原列表未被修改\n        assert test_case == original, \"原列表被修改了！\"\n        # 验证排序正确\n        assert sorted_arr == sorted",
          "time_taken": 428.5225670337677
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"\n    检查值是否匹配期望的类型。\n    \n    Args:\n        value: 要检查的值\n        expected_type: 期望的类型\n    \n    Returns:\n        bool: 如果值匹配类型则返回True，否则返回False\n    \"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型的原始类型（如 list, dict, Union 等）\n    origin = typing.get_origin(expected_type)\n    \n    # 如果是普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数类型\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（如 Optional[X] 等价于 Union[X, None]）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数类型，只检查是否为list\n        if not args:\n            return True\n        # 检查所有元素是否匹配参数类型\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数类型，只检查是否为dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配参数类型\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器。\n    \n    Args:\n        func: 要装饰的函数\n    \n    Returns:\n        装饰后的函数，会在运行时检查参数和返回值类型\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名并绑定参数\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查每个参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, ",
          "time_taken": 327.3161017894745
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义装饰器参数类型\nRetryConfig = Tuple[int, float, float, Tuple[Type[Exception], ...]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable) -> Callable:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            \"\"\"\n            异步函数包装器\n            \n            Args:\n                *args: 函数位置参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常，如果重试次数用完\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                        logger.info(f\"等待 {current_delay:.2f} 秒后进行第 {attempt + 2} 次重试\")\n                     ",
          "time_taken": 393.05398201942444
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 408.03922414779663
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Union\nfrom collections import defaultdict\n\nclass AsyncPipeline:\n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {'calls': 0, 'total_time': 0.0, 'errors': 0})\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, name: str, fn: Callable, data: Any) -> Any:\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[name]['calls'] += 1\n            self.stats_data[name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[name]['calls'] += 1\n            self.stats_data[name]['total_time'] += (time.time() - start_time)\n            self.stats_data[name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        result = data\n        for name, fn in self.stages.items():\n            result = await self._process_single_stage(name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        semaphore = asyncio.Semaphore(concurrency)\n        \n        async def process_item(item: Any) -> Any:\n            async with semaphore:\n                try:\n                    return await self.process(item)\n                except Exception as e:\n                    # Re-raise the exception to be handled by the caller\n                    raise e\n        \n        tasks = [process_item(item) for item in items]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Handle exceptions in results\n        final_results = [",
          "time_taken": 311.46588110923767
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._lock = threading.Lock()\n        self._running = False\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPool-Worker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 使用超时机制避免无限等待\n                task = self._task_queue.get(timeout=1.0)\n                self._execute_task(task)\n                self._task_queue.task_done()\n            except queue.Empty:\n     ",
          "time_taken": 355.2249188423157
        }
      ],
      "elapsed_seconds": 432.9
    },
    {
      "round": 26,
      "timestamp": 1771033715.3893461,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 348.7
    },
    {
      "round": 27,
      "timestamp": 1771033754.340045,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._lock = threading.Lock()\n        self._running = False\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPool-Worker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 使用超时机制避免无限等待\n                task = self._task_queue.get(timeout=1.0)\n                self._execute_task(task)\n                self._task_queue.task_done()\n           ",
          "time_taken": 38.41522216796875
        }
      ],
      "elapsed_seconds": 38.9
    },
    {
      "round": 28,
      "timestamp": 1771033818.350664,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union, Tuple\nfrom concurrent.futures import Future\nimport heapq\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务数据类，支持优先级比较\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(init=False)\n    \n    def __post_init__(self):\n        self.future = Future()\n    \n    def __eq__(self, other):\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority == other.priority\n    \n    def __lt__(self, other):\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭等功能。\n    使用线程实现并发执行。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)\n        self._lock = threading.Lock()\n        self._running = False\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n        self._running = True\n    \n    def _worker(self):\n        \"\"\"工作线程主函数\"\"\"\n        while not self.",
          "time_taken": 63.463396072387695
        }
      ],
      "elapsed_seconds": 63.9
    },
    {
      "round": 29,
      "timestamp": 1771034198.471358,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable[..., Any]\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、超时控制和优先级排序。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> pool.map(lambda x: x*2, [1, 2, 3, 4])\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads = []\n        self._lock = threading.Lock()\n        self._initialize_workers()\n    \n    def _initialize_workers(self) -> None:\n        \"\"\"初始化工作线程\"\"\"\n        for i in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self) -> None:\n        \"\"\"工作线程循环\"\"\"\n        while self._running:\n            try:\n                # 从任务队列获取任务（阻塞等待）\n                priority, task = self._task_queue.get(timeout=1.0)\n                if not self._running:\n                    break\n                    \n                # 直接在工作线程中执行任务，而不是提交到另一个线程池\n                def run_task():\n     ",
          "time_taken": 293.8519380092621
        }
      ],
      "elapsed_seconds": 380.1
    },
    {
      "round": 30,
      "timestamp": 1771034420.854753,
      "passed": 8,
      "total": 8,
      "avg_score": 8.69,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度：O(n)，空间复杂度：O(1)（不包括结果列表）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [0, 1, 2, 5, 10]\n    \n    for case in test_cases:\n        print(f\"fibonacci({case}) = {fibonacci(case)}\")\n",
          "time_taken": 207.46962976455688
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组递归地分成两半，分别排序后再合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([5, 2, 8, 2, 1]) == [1, 2, 2, 5, 8]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 220.11212587356567
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.current_char = self.expression[self.pos] if self.expression else None\n    \n    def advance(self):\n        \"\"\"Move to the next character.\"\"\"\n        self.pos += 1\n        if self.pos >= len(self.expression):\n            self.current_char = None\n        else:\n            self.current_char = self.expression[self.pos]\n    \n    def skip_whitespace(self):\n        \"\"\"Skip whitespace characters.\"\"\"\n        while self.current_char and self.current_char.isspace():\n            self.advance()\n    \n    def read_number(self) -> float:\n        \"\"\"Read a number (including decimals).\"\"\"\n        number_str = \"\"\n        while self.current_char and (self.current_char.isdigit() or self.current_char == '.'):\n            number_str += self.current_char\n            self.advance()\n        return float(number_str)\n    \n    def tokenize(self) -> List[Token]:\n        \"\"\"Convert expression string into a list of tokens.\"\"\"\n        tokens = []\n        \n        while self.current_char:\n            self.skip_whitespace()\n            \n            if self.current_char is None:\n                break\n            \n            if self.current_char.isdigit() or self.current_char == '.':\n                tokens.append(Token(TokenType.NUMBER, self.read_number()))\n            elif self.current_char == '+':\n                tokens.append(Token(TokenType.PLUS, '+'))\n                self.advance()\n            elif self.current_char == '-':\n                # Ch",
          "time_taken": 158.52333211898804
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果无法识别的类型，使用isinstance检查\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, data: list[int], mapping: dict[str, int]) -> str:\n        return f\"{",
          "time_taken": 35.92387676239014
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union, Tuple\nfrom concurrent.futures import Future\nimport heapq\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务数据类，支持优先级比较\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(init=False)\n    created_time: float = field(default_factory=time.time)\n    \n    def __post_init__(self):\n        self.future = Future()\n    \n    def __eq__(self, other):\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority == other.priority\n    \n    def __lt__(self, other):\n        if not isinstance(other, Task):\n            # Handle comparison with non-Task objects (like None)\n            return NotImplemented\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭等功能。\n    使用线程实现并发执行。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)\n        self._lock = threading.Lock()\n        self._running = False\n        self._results: List[Any] = []\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n       ",
          "time_taken": 134.58188700675964
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段并记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_fn = self.stages[stage_name]\n        is_coroutine = asyncio.iscoroutinefunction(stage_fn)\n        \n        try:\n            if is_coroutine:\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的最终数据\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._",
          "time_taken": 23.24357295036316
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义同步和异步函数的类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数的指数退避重试机制\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                    \n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {type(e).__name__}: {e}\")\n                        raise e\n                    \n                    logger.warning(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试中失败: {type(e).__name__}: {e}\")\n                    logger.info(f\"等待 {current_delay:.2f} 秒后进行下一次重试...\")\n                    \n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n                    \n                except Exception as e:\n                    # 如果不是指定要",
          "time_taken": 185.44456481933594
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 198.7959430217743
        }
      ],
      "elapsed_seconds": 222.3
    },
    {
      "round": 31,
      "timestamp": 1771034462.9629672,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom typing import Protocol\n\nclass Task:\n    \"\"\"任务类，用于封装任务信息\"\"\"\n    def __init__(self, func: Callable, args: tuple, kwargs: dict, priority: int = 0, timeout: Optional[float] = None):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.priority = priority\n        self.timeout = timeout\n        self.future = Future()\n        self.submitted_time = time.time()\n\n@dataclass\nclass TaskWrapper:\n    \"\"\"用于优先级队列的任务包装器\"\"\"\n    priority: int\n    task_id: int\n    task: Task\n    \n    def __lt__(self, other):\n        if self.priority == other.priority:\n            return self.task_id < other.task_id\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量任务执行，具有优先级和超时支持。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为CPU核心数\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._task_counter = 0\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务，如果队列为空会阻塞等待\n                task_wrapper = self._task_queue.get",
          "time_taken": 41.49176478385925
        }
      ],
      "elapsed_seconds": 42.0
    },
    {
      "round": 32,
      "timestamp": 1771034495.009374,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom queue import PriorityQueue\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = PriorityQueue()\n        self._running = True\n        self._queue_lock = threading.Lock()\n        self._worker_threads = []\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for i in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while self._running:\n            try:\n                # 从优先级队列中获取任务\n                task = self._task_queue.get(timeout=1.0)\n                if not self._running:\n                    break\n                \n                # 执行任务\n                try:\n                    if task.timeout:\n                        result = self._executor.submit(\n                            task.func, *task.args, **task.k",
          "time_taken": 31.403644800186157
        }
      ],
      "elapsed_seconds": 32.0
    },
    {
      "round": 33,
      "timestamp": 1771034495.5110579,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 34,
      "timestamp": 1771034496.0073018,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 35,
      "timestamp": 1771035047.0594182,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([2, 2, 2, 2]) == [2, 2, 2, 2]\n    \n    # 测试负数\n    assert merge_sort([-1, -5, 3, 0, 2]) == [-5, -1, 0, 2, 3]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 326.44042015075684
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个斐波那契数\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 313.7878897190094
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n        \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n                \n            elif char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token('NUMBER', float(number_str)))\n                \n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.position += 1\n                \n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position - 1] in '(+-*/'):\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Parse the following number\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                  ",
          "time_taken": 266.15857887268066
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) for k, v in value.items())\n    else:\n        # 兜底：如果origin是其他类型，比如tuple等，尝试使用isinstance\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, hobbies: list[str], info: dict[str, int]) -> str:\n        return f\"N",
          "time_taken": 32.288103342056274
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持按顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n      ",
          "time_taken": 19.90314507484436
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 303.87786197662354
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\nfrom typing_extensions import ParamSpec\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\nP = ParamSpec('P')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"等待 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败: {e}\"\n                        )\n                        raise\n            raise RuntimeError(\"不应该到达这里\")\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n           ",
          "time_taken": 292.74902987480164
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom queue import PriorityQueue\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较 - 数字越小优先级越高\"\"\"\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭、任务超时和优先级等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._task_queue = PriorityQueue()\n        self._running_tasks = set()\n        self._worker_threads = []\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"TaskPool has been shutdown\")\n        \n        task = Task(fn, args, kwargs, priority, timeout)\n        \n        # 将任务放入优先级队列\n        self._task_queue.put",
          "time_taken": 307.76341104507446
        }
      ],
      "elapsed_seconds": 551.0
    },
    {
      "round": 36,
      "timestamp": 1771035076.9637089,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom queue import PriorityQueue\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = PriorityQueue()\n        self._running = True\n        self._queue_lock = threading.Lock()\n        self._worker_threads = []\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for i in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while self._running:\n            try:\n                # 从优先级队列中获取任务\n                task = self._task_queue.get(timeout=1.0)\n                if not self._running:\n                    break\n                \n                # 执行任务\n                try:\n                    if task.timeout:\n                        result = self._executor.submit(\n                            task.func, *task.args, **task.k",
          "time_taken": 29.28363609313965
        }
      ],
      "elapsed_seconds": 29.8
    },
    {
      "round": 37,
      "timestamp": 1771035221.09745,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\n\n@dataclass(order=True)\nclass PriorityTask:\n    \"\"\"带优先级的任务包装器\"\"\"\n    priority: int  # Removed compare=False since it needs to be compared\n    task_id: int = field(compare=False)\n    fn: Callable = field(compare=False)\n    args: tuple = field(compare=False)\n    kwargs: dict = field(compare=False)\n    timeout: Optional[float] = field(default=None, compare=False)\n    \n    # Removed explicit __lt__ method since @dataclass(order=True) handles it\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池管理功能，支持任务提交、批量执行、优雅关闭等操作。\n    支持任务超时和优先级功能。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._task_counter = 0\n        self._shutdown_event = threading.Event()\n        self._lock = threading.Lock()\n        \n        # 启动任务处理线程\n        self._worker_thread = threading.Thread(target=self._worker_loop, daemon=True)\n        self._worker_thread.start()\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高），默认为0\n            timeout: 任务超时时间（秒），默认为None（无超时）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n        \"\"\"\n        if self._shutdown_event.is_set():\n            raise RuntimeError(\"TaskPool已关闭，无法提交新任务\")\n            \n        # 创建任务\n        task = PriorityTask(\n            priority=priority,\n            task_id=self._task_counter,\n            fn=fn,\n            args=args,",
          "time_taken": 143.6279489994049
        }
      ],
      "elapsed_seconds": 144.1
    },
    {
      "round": 38,
      "timestamp": 1771035313.97216,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom collections import namedtuple\n\n# 任务优先级包装器\nclass TaskItem(namedtuple('TaskItem', ['priority', 'timestamp', 'future', 'fn', 'args', 'kwargs'])):\n    def __lt__(self, other):\n        # 优先级比较\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        # 如果优先级相同，按时间戳排序\n        return self.timestamp < other.timestamp\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池，基于线程实现\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 超时控制\n    - 优先级调度\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，如果为None则使用CPU核心数\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._work_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._finished = threading.Event()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"Cannot submit tasks to a shutdown pool\")\n        \n        future = Future()\n        task_item = TaskItem(priority, time.time(), future, fn, args, kwargs)\n        self._work_que",
          "time_taken": 92.29635214805603
        }
      ],
      "elapsed_seconds": 92.8
    },
    {
      "round": 39,
      "timestamp": 1771035314.556399,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.5
    },
    {
      "round": 40,
      "timestamp": 1771035789.775896,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证边界条件\n    print(f\"fibonacci(-1) = {fibonacci(-1)}\")  # []\n    print(f\"fibonacci(-5) = {fibonacci(-5)}\")  # []\n",
          "time_taken": 332.3289279937744
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，通过将数组递归地分成两半，\n    分别排序后再合并来实现整体排序。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通情况\n        [5, 2, 8, 1],          # 小列表\n        [1, 1, 1, 1],          # 重复元素\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5]        # 已排序列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n        assert t",
          "time_taken": 345.56963300704956
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[float, str]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                value = float(self.expression[start:self.pos])\n                self.tokens.append(Token('NUMBER', value))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative number\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    # This is a negative sign, not subtraction\n                    start = self.pos\n                    self.pos += 1\n                    while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                        self.pos += 1\n                    value = float(self.expression[start:self.pos])\n                    self.tokens.append(Token('NUMBER', value))\n                else:\n                    self.tokens.append(Token('-', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append",
          "time_taken": 281.69249081611633
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型 (包括 Optional)\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数，会在运行时检查参数和返回值类型\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名和绑定参数\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'r",
          "time_taken": 55.82456684112549
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持添加处理阶段、顺序执行和并发执行。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的最终数据\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage_name, result)\n        return result\n    \n    async def process_",
          "time_taken": 21.428301095962524
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"one\")\n    cache.put(2, \"two\")\n    print(cache.get(1))  # Should return \"one\"\n    \n    cache.put(3, \"three\")  # This should evict key 2\n    print(cache.get(2))  # Should return None (evicted)\n    \n    # Test TTL functionality\n    cache.put(4, \"four\", ttl=1)  # Expire in 1 second\n    print(cache.get(4))  # Should return \"four\"\n    \n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache = LRUCache(3)\n    cache.put(1, \"one\")\n    cache.put(2, \"two\")\n    cache.put(3, \"three\")\n    cache.put(4, \"four\")  # Should evict key 1\n    \n    print(cache.get(1))  # Should return None (evicted)\n    print(cache.get(2))  # Should return \"two\"\n    print(cache.get(3))  # Should return \"three\"\n    print(cache.get(4))  # Should return \"four\"\n",
          "time_taken": 321.99862575531006
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport logging\nimport time\nfrom functools import wraps\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.warning(\n                                f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                                f\"将在 {current_delay:.2f} 秒后重试...\"\n                            )\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.error(\n                                f\"函数 {func.__name__} 最终失败，已达到最大重试次数 {max_retries}: {e}\"\n                            )\n                            raise\n                raise last_exception\n                \n       ",
          "time_taken": 310.65752124786377
        }
      ],
      "elapsed_seconds": 475.2
    },
    {
      "round": 41,
      "timestamp": 1771035949.4596758,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom collections import namedtuple\n\n# 任务优先级包装器\nclass TaskItem(namedtuple('TaskItem', ['priority', 'timestamp', 'future', 'fn', 'args', 'kwargs'])):\n    def __lt__(self, other):\n        # 优先级比较\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        # 如果优先级相同，按时间戳排序\n        return self.timestamp < other.timestamp\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池，基于线程实现\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 超时控制\n    - 优先级调度\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，如果为None则使用CPU核心数\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._work_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._finished = threading.Event()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"Cannot submit tasks to a shutdown pool\")\n        \n        future = Future()\n        task_item = TaskItem(priority, time.time(), future, fn, args, kwargs)\n        self._work_que",
          "time_taken": 159.16105008125305
        }
      ],
      "elapsed_seconds": 159.6
    },
    {
      "round": 42,
      "timestamp": 1771036396.485951,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass Priority(Enum):\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: Priority = Priority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭、超时控制和优先级管理。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown = False\n        self._lock = threading.Lock()\n        self._task_queue = queue.PriorityQueue()\n        self._worker_threads: List[threading.Thread] = []\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: Priority = Priority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级 (LOW, NORMAL, HIGH)\n            timeout: 任务超时时间(秒)，None表示无超时\n           ",
          "time_taken": 317.9852600097656
        }
      ],
      "elapsed_seconds": 447.0
    },
    {
      "round": 43,
      "timestamp": 1771036424.288655,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom collections import namedtuple\n\n# 任务优先级包装器\nclass TaskItem(namedtuple('TaskItem', ['priority', 'timestamp', 'future', 'fn', 'args', 'kwargs'])):\n    def __lt__(self, other):\n        # 优先级比较\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        # 如果优先级相同，按时间戳排序\n        return self.timestamp < other.timestamp\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池，基于线程实现\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 超时控制\n    - 优先级调度\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，如果为None则使用CPU核心数\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._work_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._finished = threading.Event()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"Cannot submit tasks to a shutdown pool\")\n        \n        future = Future()\n        task_item = TaskItem(priority, time.time(), future, fn, args, kwargs)\n        self._work_que",
          "time_taken": 27.115081071853638
        }
      ],
      "elapsed_seconds": 27.7
    },
    {
      "round": 44,
      "timestamp": 1771036458.517476,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom concurrent.futures import Future\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport heapq\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._running = False\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        self._running = True\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self):\n        ",
          "time_taken": 33.603039026260376
        }
      ],
      "elapsed_seconds": 34.2
    },
    {
      "round": 45,
      "timestamp": 1771036894.409069,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能\n    import time\n    start = time.time()\n    result = fibonacci(1000)\n    end = time.time()\n    print(f\"fibonacci(1000) 长度: {len(result)}, 耗时: {end - start:.6f}秒\")\n",
          "time_taken": 241.3672480583191
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本，确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # 递归排序左右两半\n    sorted_left = merge_sort(left)\n    sorted_right = merge_sort(right)\n    \n    # 合并两个已排序的数组\n    return _merge(sorted_left, sorted_right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 2, 8, 1],          # 小列表\n        [1, 1, 1, 1],          # 重复元素\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5]        # 已排序列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n        assert test_case == original, \"原列表被修改了！\"\n        # 验证结",
          "time_taken": 254.39237713813782
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[float, str]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"+\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Parse the following number\n                    while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token(\"NUMBER\", float(number_str)))\n   ",
          "time_taken": 188.84731698036194
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：对于其他泛型类型，检查是否为对应的基本类型\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, scores: list[int], data: dict[str, int]) -> str:\n        return f",
          "time_taken": 36.18935203552246
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序和并发处理数据。\n    \n    支持添加处理阶段，顺序执行所有阶段，以及并发处理数据。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    asyn",
          "time_taken": 23.370777130126953
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 230.445494890213
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, Tuple, Union, Optional, Awaitable\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): \"\n                            f\"{type(e).__name__}: {e}，将在 {current_delay:.2f} 秒后重试\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终执行失败: {type(e).__name__}: {e}\"\n                        )\n                        raise\n                except Exception as e:\n                    # 对于不匹配的异常类型，直接抛出\n                    logger.error(\n                        f\"函数 {func.__name__} 执行失败，抛出不支持的异常类型: {type(e).__name__}: {e}\"\n                    )\n             ",
          "time_taken": 219.84759306907654
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    fn: Callable[..., Any]\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._work_queue = queue.PriorityQueue()\n        self._threads: List[threading.Thread] = []\n        self._running = True\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.append(thread)\n    \n    def submit(self, fn: Callable[..., Any], *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数字越小优先级越高，默认为0\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n           ",
          "time_taken": 231.57636499404907
        }
      ],
      "elapsed_seconds": 435.8
    },
    {
      "round": 46,
      "timestamp": 1771037044.000343,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 224, in <module>\n  File \"<string>\", line 185, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom concurrent.futures import Future\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport heapq\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._running = False\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        self._running = True\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker",
          "time_taken": 22.35974097251892
        }
      ],
      "elapsed_seconds": 149.5
    },
    {
      "round": 47,
      "timestamp": 1771037117.523147,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom concurrent.futures import Future\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport heapq\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._running = False\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        self._running = True\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker",
          "time_taken": 72.84882616996765
        }
      ],
      "elapsed_seconds": 73.5
    },
    {
      "round": 48,
      "timestamp": 1771037149.327693,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom queue import PriorityQueue\nimport heapq\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池实现并发任务执行，支持任务优先级、超时控制和优雅关闭。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self._max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown = False\n        self._lock = threading.Lock()\n        \n        # 用于存储任务的优先级队列\n        self._task_queue = PriorityQueue()\n        self._task_count = 0\n        self._task_id_lock = threading.Lock()\n        \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"Cannot submit tasks to a shutdown pool\")\n            \n        task = Task(fn, args, kwargs, priority, timeout)\n        ",
          "time_taken": 31.165751218795776
        }
      ],
      "elapsed_seconds": 31.7
    },
    {
      "round": 49,
      "timestamp": 1771037209.748244,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count()\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._lock = threading.Lock()\n        self._initialize_workers()\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker_loop, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从优先级队列中获取任务\n                task = self._task_queue.get(timeout=1.0)\n                if task is None:  # 用于关闭信号\n                    break\n                \n                # 执行任务\n                try:\n                    if task.timeout is not None:\n                        result = self._executor.submit(task.fn, *task.args, **task.kwargs).result(timeout=task.timeout)\n                    else:\n                        result = self.",
          "time_taken": 59.75224018096924
        }
      ],
      "elapsed_seconds": 60.4
    },
    {
      "round": 50,
      "timestamp": 1771037731.03629,
      "passed": 7,
      "total": 8,
      "avg_score": 8.25,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 326.33699083328247
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 2, 8, 1],          # 小列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n        assert test_case == original,",
          "time_taken": 339.6221740245819
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.tokens = []\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Invalid character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.",
          "time_taken": 283.1128990650177
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果无法识别的类型，尝试使用 isinstance\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数，会在运行时检查参数和返回值类型\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    ",
          "time_taken": 37.81370496749878
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        \"\"\"\n        初始化LRU缓存\n        \n        Args:\n            capacity: 缓存的最大容量\n        \"\"\"\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        \"\"\"\n        获取缓存中的值\n        \n        Args:\n            key: 要获取的键\n            \n        Returns:\n            如果键存在且未过期，返回对应的值；否则返回None\n        \"\"\"\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        \"\"\"\n        向缓存中添加或更新键值对\n        \n        Args:\n            key: 键\n            value: 值\n            ttl: 过期时间（秒），如果为None则永不过期\n        \"\"\"\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为2的LRU缓存\n    cache = LRUCache(2)\n    \n    # 测试基本功能\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # 应该输出 1\n    \n    # 测试容量限制\n    cache.put(\"c\", 3)  # 应该移除最久未使用的 \"b\"\n    print(cache.get(\"b\"))  # 应该输出 None\n    \n    # 测试TTL过期\n    cache.put(\"d\", 4, ttl=0.1)  # 0.1秒后过期\n    print(cache.get(\"d\"))  # 应该输出 4\n    time.sleep(0.2)  # 等待过期\n    print(cache.get(\"d\"))  # 应该输出 None\n    \n    # 测试更新操作\n    cache.put(\"a\", 5)\n    print(cache.get(\"a\"))  # 应该输出 5\n",
          "time_taken": 315.4944078922272
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，并记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, r",
          "time_taken": 22.129576921463013
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.warning(\n                                f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                                f\"将在 {current_delay:.2f} 秒后重试...\"\n                            )\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.error(\n                                f\"函数 {func.__name__} 最终失败，已达到最大重试次数 {max_retries + 1}: {e}\"\n                            )\n                            raise\n                raise last_exception  # 这行代码实际上不会执行到\n     ",
          "time_taken": 302.0409140586853
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数值越小优先级越高\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池任务提交、批量执行、优雅关闭等功能\n    支持任务优先级和超时控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._task_queue = queue.PriorityQueue()\n        self._running_tasks = set()\n        self._task_lock = threading.Lock()\n        \n        # 启动工作线程\n        self._worker_threads = []\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高，默认为0\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 当任务池已关闭时抛出异常\n        \"\"\"\n        with self._shutdown_lock:\n            if self._shutdown:\n                raise RuntimeError(\"TaskPool has been shutdown\")\n        \n        task = Task(fn, args,",
          "time_taken": 324.4250361919403
        }
      ],
      "elapsed_seconds": 521.2
    },
    {
      "round": 51,
      "timestamp": 1771038203.044548,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 471.9
    },
    {
      "round": 52,
      "timestamp": 1771038316.4111612,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._lock = threading.Lock()\n        self._initialize_workers()\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker_loop, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从优先级队列中获取任务\n                task = self._task_queue.get(timeout=1.0)\n                if task is None:  # 用于关闭信号\n                    break\n                \n                # 执行任务\n                try:\n                    if task.timeout is not None:\n                        result = self._executor.submit(task.fn, *task.args, **task.kwargs).result(timeout=task.timeout)\n                    else:\n                  ",
          "time_taken": 57.51986622810364
        }
      ],
      "elapsed_seconds": 113.3
    },
    {
      "round": 53,
      "timestamp": 1771038702.384789,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 15, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/dataclasses.py\", line 1013, in wrap\n    return _process_class(cls, init, repr, eq, order, unsafe_hash, frozen)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/dataclasses.py\", line 970, in _process_class\n    raise TypeError(f'Cannot overwrite attribute {name} '\nTypeError: Cannot overwrite attribute __lt__ in class PriorityTask. Consider using functools.total_ordering",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future\nimport heapq\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass(order=True)\nclass PriorityTask:\n    \"\"\"优先级任务包装类\"\"\"\n    priority: int\n    task_id: int = field(compare=False)\n    fn: Callable = field(compare=False)\n    args: tuple = field(compare=False)\n    kwargs: dict = field(compare=False)\n    timeout: Optional[float] = field(default=None)\n\n    def __eq__(self, other):\n        if not isinstance(other, PriorityTask):\n            return NotImplemented\n        return self.priority == other.priority and self.task_id == other.task_id\n\n    def __lt__(self, other):\n        if not isinstance(other, PriorityTask):\n            return NotImplemented\n        # Compare by priority first, then by task_id for tie-breaking\n        if self.priority == other.priority:\n            return self.task_id < other.task_id\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量任务执行、任务超时、任务优先级等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._task_counter = 0\n        self._shutdown_event = threading.Event()\n        self._worker_threads: List[threading.Thread] = []\n        self._initialize_workers()\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self.",
          "time_taken": 129.1351408958435
        }
      ],
      "elapsed_seconds": 385.9
    },
    {
      "round": 54,
      "timestamp": 1771039190.617693,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 221, in <module>\n  File \"<string>\", line 187, in __exit__\n  File \"<string>\", line 167, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union, TypeVar\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\nfrom collections import deque\n\nT = TypeVar('T')\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable[..., T]\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For other types, we can't compare, so return False\n        return False\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._lock = threading.Lock()\n        self._initialize_workers()\n        self._shutdown = False\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker_loop, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从优先级队列中获取任务\n                task = self._task_queue.get(timeout=1.0)\n             ",
          "time_taken": 130.71318578720093
        }
      ],
      "elapsed_seconds": 488.2
    },
    {
      "round": 55,
      "timestamp": 1771039725.023094,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "No code in response",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能（大数值测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 230.0570728778839
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef merge_sort(arr: List[T]) -> List[T]:\n    \"\"\"\n    对输入列表进行归并排序。\n    \n    归并排序是一种基于分治思想的稳定排序算法，时间复杂度为O(n log n)，\n    空间复杂度为O(n)。该函数是纯函数，不修改原始列表。\n    \n    Args:\n        arr: 待排序的列表，可以为空或包含单个元素\n        \n    Returns:\n        排序后的新列表，原列表保持不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort(['c', 'a', 'b'])\n        ['a', 'b', 'c']\n    \"\"\"\n    # 基础情况：空列表或单元素列表已排序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保纯函数特性\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[T], right: List[T]) -> List[T]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序列表\n        right: 右侧已排序列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试字符串列表\n    assert merge_sort(['c', 'a', 'b']) == ['a', 'b', 'c']\n    \n    # 测试原列表不变\n    original = [3, 1, 4, 1, 5]\n    sorted_arr = merge_sort(original)\n    assert original == [3, 1, 4, 1, 5]  # 原列表未被修改\n    assert sorted_arr == [1",
          "time_taken": 243.78404808044434
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expre",
          "time_taken": 183.80687403678894
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:  # 无参数的 List\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:  # 无参数的 Dict\n            return True\n        # 检查键值对类型\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__",
          "time_taken": 40.61843419075012
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\nfrom typing_extensions import ParamSpec\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量定义\nT = TypeVar('T')\nP = ParamSpec('P')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}\"\n                        )\n                        raise\n            raise last_exception  # 这行代码实际上不会执行到\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in ra",
          "time_taken": 204.09409999847412
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    \n    # Test updating existing key\n    cache.put(\"a\", 5)\n    print(cache.get(\"a\"))  # Should return 5\n",
          "time_taken": 219.65985679626465
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序和并发处理数据\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理结果\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序处理数据\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], co",
          "time_taken": 26.2256019115448
        }
      ],
      "elapsed_seconds": 534.3
    },
    {
      "round": 56,
      "timestamp": 1771039897.0134568,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count()\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._lock = threading.Lock()\n        self._initialize_workers()\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker_loop, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从优先级队列中获取任务\n                task = self._task_queue.get(timeout=1.0)\n                if task is None:  # 用于关闭信号\n                    break\n                \n                # 执行任务\n                try:\n                    if task.timeout is not None:\n                        result = self._executor.submit(task.fn, *task.args, **task.kwargs).result(timeout=task.timeout)\n             ",
          "time_taken": 54.91741108894348
        }
      ],
      "elapsed_seconds": 171.9
    },
    {
      "round": 57,
      "timestamp": 1771040135.200927,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        Example:\n           ",
          "time_taken": 33.89263725280762
        }
      ],
      "elapsed_seconds": 238.1
    },
    {
      "round": 58,
      "timestamp": 1771040492.342863,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 357.1
    },
    {
      "round": 59,
      "timestamp": 1771041085.2972858,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor, TimeoutError\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._shutdown_lock = threading.Lock()\n        self._shutdown_event = threading.Event()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n       ",
          "time_taken": 303.74504685401917
        }
      ],
      "elapsed_seconds": 592.9
    },
    {
      "round": 60,
      "timestamp": 1771041522.241775,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 从第3个数开始计算\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 149.5136799812317
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，通过递归地将数组分成两半，分别排序后再合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_arr}\")\n        # 验证原列表未被修改\n        assert test_case == origina",
          "time_taken": 162.69383811950684
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 188, in <module>\n  File \"<string>\", line 179, in evaluate\n  File \"<string>\", line 62, in tokenize\nTypeError: peek() takes 1 positional argument but 2 were given",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return \"\"\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return \"\"\n    \n    def is_digit(self, char: str) -> bool:\n        return char.isdigit()\n    \n    def is_decimal_point(self, char: str) -> bool:\n        return char == \".\"\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.position = 0\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isspace():\n                self.advance()\n                continue\n            \n            if char == \"+\":\n                self.tokens.append(Token(TokenType.PLUS, \"+\"))\n                self.advance()\n            elif char == \"-\":\n                # Check if this is a negative sign\n                if self.position == 0 or self.peek(-1) == \"(\":\n                    # It's a negative number\n                    number = \"-\"\n                    self.advance()\n                    while self.peek().isdigit() or self.peek() == \".\":\n                        number += self.advance()\n                    self.tokens.append(Token(TokenType.NUMBER, float(number)))\n                else:\n",
          "time_taken": 92.87348103523254
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果不能识别的类型，尝试使用 isinstance\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: ",
          "time_taken": 35.426225900650024
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Union\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items:",
          "time_taken": 21.836681842803955
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为2的LRU缓存\n    cache = LRUCache(2)\n    \n    # 测试基本功能\n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    print(cache.get(1))  # 应该输出 \"value1\"\n    \n    # 测试容量限制\n    cache.put(3, \"value3\")  # 应该移除key=2的项\n    print(cache.get(2))  # 应该输出 None\n    \n    # 测试TTL功能\n    cache.put(4, \"value4\", ttl=1)  # 1秒后过期\n    print(cache.get(4))  # 应该输出 \"value4\"\n    time.sleep(1.1)  # 等待1.1秒让其过期\n    print(cache.get(4))  # 应该输出 None\n    \n    # 测试线程安全\n    def test_thread():\n        for i in range(10):\n            cache.put(i, f\"value{i}\")\n            print(f\"Thread: {i}, Value: {cache.get(i)}\")\n    \n    # 创建多个线程同时操作缓存\n    threads = []\n    for i in range(3):\n        t = threading.Thread(target=test_thread)\n        threads.append(t)\n        t.start()\n    \n    for t in threads:\n        t.join()\n",
          "time_taken": 139.25132989883423
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避倍数\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"异步函数重试包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                        logger.info(f\"等待 {current_delay} 秒后进行下次重试...\")\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                except Exception as e:\n                    # 如果遇到不支持的异常类型，直接抛出\n                    logger.error(f\"函数 {func.__name__} 遇到不支持的异常类型: {e}\")\n                    raise\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"同步函数重试包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries +",
          "time_taken": 125.80945777893066
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        Example:\n           ",
          "time_taken": 133.0148949623108
        }
      ],
      "elapsed_seconds": 436.9
    },
    {
      "round": 61,
      "timestamp": 1771042122.706484,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expre",
          "time_taken": 286.89021277427673
        }
      ],
      "elapsed_seconds": 600.4
    },
    {
      "round": 62,
      "timestamp": 1771042581.3516421,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 203, in <module>\n  File \"<string>\", line 196, in evaluate\n  File \"<string>\", line 134, in parse_expression\n  File \"<string>\", line 152, in parse_term\n  File \"<string>\", line 175, in parse_factor\n  File \"<string>\", line 129, in _expect\nValueError: Expected RPAREN, got NUMBER",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    END = \"END\"\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float] = None):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def _is_digit(self, char: str) -> bool:\n        return char.isdigit()\n    \n    def _is_operator(self, char: str) -> bool:\n        return char in \"+-*/\"\n    \n    def _is_paren(self, char: str) -> bool:\n        return char in \"()\"\n    \n    def _is_space(self, char: str) -> bool:\n        return char.isspace()\n    \n    def _peek(self) -> str:\n        if self.pos < len(self.expression):\n            return self.expression[self.pos]\n        return \"\"\n    \n    def _advance(self) -> str:\n        if self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            self.pos += 1\n            return char\n        return \"\"\n    \n    def _parse_number(self) -> Token:\n        start = self.pos\n        # Handle negative numbers\n        if self._peek() == '-':\n            self._advance()\n            # If the next character is a digit or a dot, we continue parsing\n            if self._is_digit(self._peek()) or self._peek() == '.':\n                pass\n            else:\n                # If the - is not followed by a digit or dot, it's not a number\n                # Reset position and return a MINUS token\n                self.pos = start\n                return Token(TokenType.MINUS)\n        \n        while self._is_digit(self._peek()) or self._peek() == '.':\n            self._advance()\n        \n        value = self.expression[start:self.pos]\n        return Token(TokenType.",
          "time_taken": 48.542539834976196
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        ",
          "time_taken": 85.91584515571594
        }
      ],
      "elapsed_seconds": 458.6
    },
    {
      "round": 63,
      "timestamp": 1771042887.986005,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expre",
          "time_taken": 51.78572106361389
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._shutdown_event = threading.Event()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n        ",
          "time_taken": 91.35293006896973
        }
      ],
      "elapsed_seconds": 306.6
    },
    {
      "round": 64,
      "timestamp": 1771043347.492648,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n\n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n\n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n            self.expression[self.position].isdigit() or self.expression[self.p",
          "time_taken": 268.4931209087372
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._shutdown_event = threading.Event()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参",
          "time_taken": 310.2415020465851
        }
      ],
      "elapsed_seconds": 459.4
    },
    {
      "round": 65,
      "timestamp": 1771043817.7941492,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")      # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")      # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")      # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")      # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")    # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 135.16655731201172
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种基于分治思想的稳定排序算法。它将数组递归地分成两半，\n    对每一半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余的元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试一般情况\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试包含重复元素\n    assert merge_sort([2, 2, 2, 2]) == [2, 2, 2, 2]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 147.8773012161255
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\nimport re\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"+\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Parse the following number\n                    while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token(\"NUMBER\", float(number_str)))\n     ",
          "time_taken": 88.8563437461853
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 被装饰的函数\n        \n    Returns:\n        装饰后的函数，会在运行时检查参数和返回值类型\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func",
          "time_taken": 35.8482768535614
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义装饰器参数类型\nRetryConfig = Tuple[int, float, float, Tuple[Type[Exception], ...]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}\"\n                        )\n                        raise\n            raise last_exception  # 这行代码实际上不会执行到\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retr",
          "time_taken": 110.44931888580322
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Union\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持按顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self._stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段并记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_func = self._stages[stage_name]\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 更新统计信息\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计信息\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            self._stats[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._execute_stage(stage_name, result)\n        retur",
          "time_taken": 21.72562885284424
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 125.29729104042053
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        Example:\n           ",
          "time_taken": 131.2139139175415
        }
      ],
      "elapsed_seconds": 470.2
    },
    {
      "round": 66,
      "timestamp": 1771044124.240046,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._shutdown_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        ",
          "time_taken": 101.21537590026855
        }
      ],
      "elapsed_seconds": 306.4
    },
    {
      "round": 67,
      "timestamp": 1771044324.419343,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        Example:\n           ",
          "time_taken": 137.42658591270447
        }
      ],
      "elapsed_seconds": 200.1
    },
    {
      "round": 68,
      "timestamp": 1771044819.2206159,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 227, in <module>\n  File \"<string>\", line 203, in __exit__\n  File \"<string>\", line 188, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@dataclass\n@total_ordering\nclass PriorityTask:\n    \"\"\"带优先级的任务\"\"\"\n    priority: int\n    task_id: int\n    func: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float] = None\n    future: Optional[Future] = None  # Add future attribute\n    \n    def __lt__(self, other):\n        # 优先级越小越优先\n        if self.priority == other.priority:\n            return self.task_id < other.task_id\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、任务超时、任务优先级等特性。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count() + 4\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._task_counter = 0\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._worker_threads: List[threading.Thread] = []\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while True:\n            try:\n                # 从优先级队列中获取任务\n                priority_task = self._task_queue.get(timeout=1)\n                if priority_task is None:  # 退出信号\n                    break\n                \n                # 执行任务\n                future = self._executor.submit(\n                    priority_task.func, \n                    *priority_task.args, \n                    **priority_tas",
          "time_taken": 168.73934721946716
        }
      ],
      "elapsed_seconds": 494.7
    },
    {
      "round": 69,
      "timestamp": 1771045258.320029,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 439.0
    },
    {
      "round": 70,
      "timestamp": 1771045623.845616,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 时间复杂度：O(n)，空间复杂度：O(1)（不包括结果列表）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证函数正确性\n    assert fibonacci(0) == []\n    assert fibonacci(1) == [0]\n    assert fibonacci(2) == [0, 1]\n    assert fibonacci(5) == [0, 1, 1, 2, 3]\n    assert fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    print(\"所有测试通过！\")\n",
          "time_taken": 186.94742894172668
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治策略的排序算法。\n    时间复杂度为 O(n log n)，空间复杂度为 O(n)。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序列表\n        right: 右侧已排序列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([2, 2, 2, 2]) == [2, 2, 2, 2]\n    \n    # 测试原列表不变\n    original = [3, 1, 4, 1, 5]\n    sorted_arr = merge_sort(original)\n    assert original == [3, 1, 4, 1, 5]  # 原列表应保持不变\n    assert sorted_arr == [1, 1, 3, 4, 5]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 200.2607011795044
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Invalid character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self",
          "time_taken": 142.09837913513184
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: x}\n    \n    # 正确的调用\n ",
          "time_taken": 34.20117807388306
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.warning(\n                                f\"函数 {func.__name__} 执行失败 (attempt {attempt + 1}/{max_retries + 1}): {e}. \"\n                                f\"将在 {current_delay:.2f} 秒后重试...\"\n                            )\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.error(\n                                f\"函数 {func.__name__} 最终失败，已达到最大重试次数 {max_retries}: {e}\"\n                            )\n                            raise\n                raise last_exception or RuntimeError(\"未知错",
          "time_taken": 161.3567349910736
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Union\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发批量处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data: Dict[str, Dict[str, Union[int, float]]] = defaultdict(\n            lambda: {\"calls\": 0, \"total_time\": 0.0, \"errors\": 0}\n        )\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name][\"calls\"] += 1\n            self.stats_data[stage_name][\"total_time\"] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计信息\n            self.stats_data[stage_name][\"calls\"] += 1\n            self.stats_data[stage_name][\"total_time\"] += (time.time() - start_time)\n            self.stats_data[stage_name][\"errors\"] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_singl",
          "time_taken": 21.00667715072632
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 177.24179196357727
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        ",
          "time_taken": 127.96478915214539
        }
      ],
      "elapsed_seconds": 365.5
    },
    {
      "round": 71,
      "timestamp": 1771046142.361174,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    该类提供了一个基于线程的并发任务执行池，支持：\n    - 任务提交\n    - 批量任务执行\n    - 优雅关闭\n    - 任务超时控制\n    - 任务优先级支持\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> result = future.result()\n        >>> print(result)\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._lock = threading.Lock()\n        self._running = False\n        self._task_counter = 0  # For unique task identification\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n        \n        self._running = True\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从任务队列获取任务，设置超时避免永久阻塞\n                task = self._task_queue.ge",
          "time_taken": 326.40613412857056
        }
      ],
      "elapsed_seconds": 518.4
    },
    {
      "round": 72,
      "timestamp": 1771046272.119696,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\nimport logging\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        self._logger = logging.getLogger(__name__)\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n       ",
          "time_taken": 49.97762393951416
        }
      ],
      "elapsed_seconds": 129.7
    },
    {
      "round": 73,
      "timestamp": 1771046594.9959838,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 209, in <module>\n  File \"<string>\", line 188, in __exit__\n  File \"<string>\", line 173, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        # 优先级越小，优先级越高\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # Handle comparison with None (for shutdown mechanism)\n        if other is None:\n            return False\n        return NotImplemented\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 任务超时控制\n    - 任务优先级控制\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x**2, 5)\n        >>> print(future.result())\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_threads = []\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for i in range(self.max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown:\n            try:\n                # 从队列中获取任务，如果队列为空则等待\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 用于关闭信号\n            ",
          "time_taken": 127.2324321269989
        }
      ],
      "elapsed_seconds": 322.8
    },
    {
      "round": 74,
      "timestamp": 1771046993.215093,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\nimport logging\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务",
          "time_taken": 101.34774088859558
        }
      ],
      "elapsed_seconds": 398.1
    },
    {
      "round": 75,
      "timestamp": 1771047731.5487318,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 377.7586250305176
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Optional\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序结果: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 392.925803899765
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n                \n            elif char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                value = float(self.expression[start:self.pos])\n                self.tokens.append(Token(\"NUMBER\", value))\n                \n            elif char == '+':\n                self.tokens.append(Token(\"+\", char))\n                self.pos += 1\n                \n            elif char == '-':\n                # Check if this is a negative number\n                if self.pos == 0 or self.expression[self.pos - 1] in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    start = self.pos\n                    self.pos += 1\n                    # Parse the following number\n                    while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                        self.pos += 1\n                    value = float(self.expression[start:self.pos])\n                    self.tokens.append(Token(\"NUMBER\", value))\n                else:\n                    self.tokens.append(Token(\"-\", char)",
          "time_taken": 326.5651500225067
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：对于其他泛型类型，检查是否为对应的容器类型\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    # 测试函数1：基本类型检查\n    @type_check\n    def add(a: int, b: int) -> int:\n        return a + b\n    \n    print(add(1, 2))  # 正常",
          "time_taken": 39.024627923965454
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Union\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持按顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        retu",
          "time_taken": 19.942167043685913
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    \n    print(cache.get(1))  # Should return \"value1\"\n    \n    cache.put(3, \"value3\")  # This should evict key 2\n    \n    print(cache.get(2))  # Should return None (evicted)\n    print(cache.get(3))  # Should return \"value3\"\n    \n    # Test TTL functionality\n    cache.put(4, \"value4\", ttl=1)  # 1 second TTL\n    print(cache.get(4))  # Should return \"value4\"\n    \n    time.sleep(1.1)  # Wait for TTL to expire\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test LRU eviction with TTL\n    cache.put(5, \"value5\")\n    cache.put(6, \"value6\", ttl=0.5)  # 0.5 second TTL\n    cache.put(7, \"value7\")\n    \n    time.sleep(0.6)  # Wait for key 6 to expire\n    cache.put(8, \"value8\")  # This should evict key 5 (LRU) and key 6 (expired)\n    \n    print(cache.get(6))  # Should return None (expired)\n    print(cache.get(5))  # Should return None (evicted)\n    print(",
          "time_taken": 368.06459617614746
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\nfrom typing_extensions import ParamSpec\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\nP = ParamSpec('P')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 执行最终失败: {e}\"\n                        )\n                        raise\n            raise RuntimeError(\"不应该到达这里\")  # 理论上不会执行到这行\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries +",
          "time_taken": 354.2278609275818
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional\nfrom dataclasses import dataclass, field\nimport logging\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._logger = logging.getLogger(__name__)\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n      ",
          "time_taken": 367.1486678123474
        }
      ],
      "elapsed_seconds": 738.3
    },
    {
      "round": 76,
      "timestamp": 1771047972.150851,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        Example:\n           ",
          "time_taken": 86.60816693305969
        }
      ],
      "elapsed_seconds": 240.5
    },
    {
      "round": 77,
      "timestamp": 1771048263.4618602,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        ",
          "time_taken": 239.54370832443237
        }
      ],
      "elapsed_seconds": 291.2
    },
    {
      "round": 78,
      "timestamp": 1771048651.1326468,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 204, in <module>\nTypeError: '<' not supported between instances of 'TimeoutError' and 'TimeoutError'",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterable\nfrom dataclasses import dataclass, field\nfrom collections import defaultdict\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、任务超时、任务优先级等特性。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown = False\n        self._lock = threading.Lock()\n        \n        # 用于存储任务的优先队列\n        self._task_queue = queue.PriorityQueue()\n        self._task_count = 0\n        \n        # 启动任务处理线程\n        self._worker_thread = threading.Thread(target=self._worker_loop, daemon=True)\n        self._worker_thread.start()\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数值越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"TaskPool has been shut down\")\n        \n        # 创建任务\n        task = Task(fn, ",
          "time_taken": 196.65909814834595
        }
      ],
      "elapsed_seconds": 387.6
    },
    {
      "round": 79,
      "timestamp": 1771048787.369792,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        Example:\n           ",
          "time_taken": 92.49489521980286
        }
      ],
      "elapsed_seconds": 136.2
    },
    {
      "round": 80,
      "timestamp": 1771049255.095558,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算（索引为2）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 223.58559012413025
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分为两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {test_case} -> {result}\")\n    \n    # 验证原列表不变\n    original = [3, 1, 4, 1, 5]\n    result = merge_sort(original)\n    print(f\"原列表: {original}\")\n    print(f\"排序后: {result}\")\n",
          "time_taken": 237.997309923172
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 175, in <module>\n  File \"<string>\", line 167, in evaluate\n  File \"<string>\", line 52, in tokenize\nTypeError: peek() takes 1 positional argument but 2 were given",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens: List[Token] = []\n    \n    def peek(self) -> str:\n        if self.pos < len(self.expression):\n            return self.expression[self.pos]\n        return ''\n    \n    def advance(self) -> str:\n        if self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            self.pos += 1\n            return char\n        return ''\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.peek()\n            \n            if char.isspace():\n                self.advance()\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                num_str = ''\n                while self.pos < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                    num_str += self.advance()\n                self.tokens.append(Token('NUMBER', float(num_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.advance()\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.peek(1) == '(' or self.peek(1) == '+' or self.peek(1) == '-' or self.peek(1) == '*' or self.peek(1) == '/':\n                    # This is a negative sign, not subtraction\n                    self.advance()  # consume '-'\n                    num_str = '-'\n                    while self.pos < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                     ",
          "time_taken": 178.12461185455322
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型（包括 Optional）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有泛型参数，只检查是否为 list\n        if not args:\n            return isinstance(value, list)\n        # 检查所有元素是否匹配泛型参数\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有泛型参数，只检查是否为 dict\n        if not args:\n            return isinstance(value, dict)\n        # 检查键值对是否匹配泛型参数\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) for k, v in value.items())\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['re",
          "time_taken": 36.65446901321411
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理结果\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List",
          "time_taken": 22.927263975143433
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避倍数\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"等待 {current_delay:.2f} 秒后重试...\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败: {e}\"\n                        )\n                        raise\n            raise last_exception  # 这行代码实际上不会执行到\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n     ",
          "time_taken": 200.9471139907837
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为2的LRU缓存\n    cache = LRUCache(2)\n    \n    # 测试基本功能\n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    print(cache.get(1))  # 应该输出 \"value1\"\n    \n    # 测试容量限制\n    cache.put(3, \"value3\")  # 这会删除最久未使用的项(1)\n    print(cache.get(1))  # 应该输出 None\n    print(cache.get(2))  # 应该输出 \"value2\"\n    print(cache.get(3))  # 应该输出 \"value3\"\n    \n    # 测试TTL功能\n    cache.put(4, \"value4\", ttl=1)  # 1秒后过期\n    print(cache.get(4))  # 应该输出 \"value4\"\n    time.sleep(1.1)  # 等待过期\n    print(cache.get(4))  # 应该输出 None\n    \n    # 测试线程安全\n    import concurrent.futures\n    \n    def test_thread_safe():\n        for i in range(10):\n            cache.put(i, f\"value{i}\")\n            cache.get(i)\n    \n    # 多线程测试\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        futures = [executor.submit(test_thread_safe) for _ in range(5)]\n        for future in futures:\n            future.result()\n    \n    print(\"所有测试通过!\")\n",
          "time_taken": 213.73441195487976
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 227, in <module>\n  File \"<string>\", line 186, in __exit__\n  File \"<string>\", line 171, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        # Handle shutdown signal (None) - it should have lowest priority\n        if other is None:\n            return False\n        if self is None:\n            return True\n        # Handle case where other is not a Task instance\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量任务执行、优雅关闭等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._worker_threads: List[threading.Thread] = []\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while True:\n            try:\n                # 从优先级队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 收到关闭信号\n                    break\n                \n                # 执行任务\n                try:\n              ",
          "time_taken": 161.77400088310242
        }
      ],
      "elapsed_seconds": 467.7
    },
    {
      "round": 81,
      "timestamp": 1771049602.8962371,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n                \n            elif char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                value = float(self.expression[start:self.pos])\n                self.tokens.append(Token(\"NUMBER\", value))\n                \n            elif char == '+':\n                self.tokens.append(Token(\"+\", char))\n                self.pos += 1\n                \n            elif char == '-':\n                # Check if this is a negative number\n                if self.pos == 0 or self.expression[self.pos - 1] in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    start = self.pos\n                    self.pos += 1\n                    # Parse the following number\n                    while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                        self.pos += 1\n                    value = float(self.expression[start:self.pos])\n                    self.tokens.append(Token(\"NUMBER\", value))\n                else:\n                    self.tokens.append(Token(\"-\", char)",
          "time_taken": 65.78463912010193
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        Example:\n           ",
          "time_taken": 107.12481880187988
        }
      ],
      "elapsed_seconds": 347.7
    },
    {
      "round": 82,
      "timestamp": 1771049816.729912,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token('NUMBER', float(number_str)))\n                else:\n                   ",
          "time_taken": 150.20009303092957
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._results = {}\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务的Future对象\n            \n        ",
          "time_taken": 132.83750700950623
        }
      ],
      "elapsed_seconds": 213.8
    },
    {
      "round": 83,
      "timestamp": 1771050037.7792408,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n                \n            elif char == '+':\n                self.tokens.append(Token(\"+\", \"+\"))\n                self.position += 1\n                \n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Parse the following number\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        sel",
          "time_taken": 82.9859390258789
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                        result = self._execute_with_timeout",
          "time_taken": 72.62952184677124
        }
      ],
      "elapsed_seconds": 221.0
    },
    {
      "round": 84,
      "timestamp": 1771050352.328301,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 284, in <module>\nTypeError: shutdown() got an unexpected keyword argument 'wait'",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom collections import deque\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(init=False)\n\n    def __post_init__(self):\n        self.future = Future()\n\n    def __lt__(self, other):\n        \"\"\"定义任务优先级比较方法\"\"\"\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority < other.priority\n\n\n@dataclass\nclass Future:\n    \"\"\"Future对象，用于获取任务结果\"\"\"\n    _result: Any = None\n    _exception: Optional[Exception] = None\n    _done: bool = False\n    _callbacks: List[Callable] = field(default_factory=list)\n    _lock: threading.Lock = field(default_factory=threading.Lock)\n\n    def set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        with self._lock:\n            if not self._done:\n                self._result = result\n                self._done = True\n                for callback in self._callbacks:\n                    try:\n                        callback(self)\n                    except Exception:\n                        pass\n\n    def set_exception(self, exception: Exception):\n        \"\"\"设置任务异常\"\"\"\n        with self._lock:\n            if not self._done:\n                self._exception = exception\n                self._done = True\n                for callback in self._callbacks:\n                    try:\n                        callback(self)\n                    except Exception:\n                        pass\n\n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果\"\"\"\n        if not self._done:\n            # 简单的等待实现，实际可使用更复杂的等待机制\n            start_time = time.time()\n            while not self._done:\n                if timeout is not None and time.time() - start_time > timeout:\n                    raise concurrent.fu",
          "time_taken": 187.3671519756317
        }
      ],
      "elapsed_seconds": 314.5
    },
    {
      "round": 85,
      "timestamp": 1771051039.207752,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 260.2147448062897
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组递归地分成两半，\n    分别排序后再合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序后:   {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 275.17880415916443
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += ",
          "time_taken": 213.2187750339508
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:  # 没有指定元素类型\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:  # 没有指定键值类型\n            return True\n        # 检查每个键值对\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main",
          "time_taken": 33.8708860874176
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序和并发处理数据。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的最终数据\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return res",
          "time_taken": 20.2536039352417
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"one\")\n    cache.put(2, \"two\")\n    print(cache.get(1))  # Should return \"one\"\n    \n    cache.put(3, \"three\")  # This should evict key 2\n    print(cache.get(2))  # Should return None (evicted)\n    \n    # Test TTL functionality\n    cache.put(4, \"four\", ttl=1)  # Expires in 1 second\n    print(cache.get(4))  # Should return \"four\"\n    time.sleep(1.1)\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(5, \"five\")\n    cache.put(6, \"six\")\n    cache.put(7, \"seven\")  # This should evict key 5\n    print(cache.get(5))  # Should return None (evicted)\n    print(cache.get(6))  # Should return \"six\"\n    print(cache.get(7))  # Should return \"seven\"\n",
          "time_taken": 250.24486994743347
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Coroutine, Type, Tuple, Union, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[Callable, Coroutine]) -> Union[Callable, Coroutine]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            \"\"\"异步函数重试包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                        raise\n                    logger.warning(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试失败: {e}\")\n                    logger.info(f\"等待 {current_delay:.2f} 秒后进行下一次重试...\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n                    \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            \"\"\"同步函数重试包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功",
          "time_taken": 237.74643087387085
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 265, in <module>\n  File \"<string>\", line 232, in __exit__\n  File \"<string>\", line 216, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle case where other is None (shutdown signal)\n        if other is None:\n            return False\n        # Handle case where self is None (should not happen in normal operation)\n        if self is None:\n            return True\n        # Handle case where priority is infinity\n        if isinstance(self.priority, float) and self.priority == float('inf'):\n            return False\n        if isinstance(other.priority, float) and other.priority == float('inf'):\n            return True\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n     ",
          "time_taken": 197.9020779132843
        }
      ],
      "elapsed_seconds": 686.8
    },
    {
      "round": 86,
      "timestamp": 1771051350.578242,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 256, in <module>\n  File \"<string>\", line 223, in __exit__\n  File \"<string>\", line 207, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                     ",
          "time_taken": 158.11257886886597
        }
      ],
      "elapsed_seconds": 311.3
    },
    {
      "round": 87,
      "timestamp": 1771051730.3701692,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 251, in <module>\n  File \"<string>\", line 228, in __exit__\n  File \"<string>\", line 215, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (shutdown signals)\n        if other is None:\n            return False\n        if self.priority == other.priority:\n            # If priorities are equal, compare by id to ensure stable ordering\n            return id(self) < id(other)\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(t",
          "time_taken": 149.53028392791748
        }
      ],
      "elapsed_seconds": 379.7
    },
    {
      "round": 88,
      "timestamp": 1771052061.317707,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 274, in <module>\n  File \"<string>\", line 240, in __exit__\n  File \"<string>\", line 223, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None values (e.g., shutdown signals)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For non-Task objects, we can't compare directly\n        # Return False to avoid TypeError\n        return False\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n   ",
          "time_taken": 181.0143051147461
        }
      ],
      "elapsed_seconds": 330.9
    },
    {
      "round": 89,
      "timestamp": 1771052497.829498,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For non-Task objects (like None), treat as higher priority\n        return True\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(",
          "time_taken": 217.35791015625
        }
      ],
      "elapsed_seconds": 436.4
    },
    {
      "round": 90,
      "timestamp": 1771053013.163052,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 257.48816108703613
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入列表进行归并排序。\n    \n    归并排序是一种基于分治思想的稳定排序算法，时间复杂度为O(n log n)，\n    空间复杂度为O(n)。该函数是纯函数，不会修改原始列表。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表保持不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_arr}\")\n        # 验证原列表未被修改\n    ",
          "time_taken": 270.98857283592224
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\nimport re\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return \"\"\n    \n    def advance(self):\n        self.position += 1\n    \n    def skip_whitespace(self):\n        while self.peek().isspace():\n            self.advance()\n    \n    def read_number(self) -> float:\n        start = self.position\n        while self.peek() and (self.peek().isdigit() or self.peek() == '.'):\n            self.advance()\n        return float(self.expression[start:self.position])\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        tokens = []\n        \n        while self.position < len(self.expression):\n            self.skip_whitespace()\n            \n            if self.peek() == '':\n                break\n            \n            if self.peek().isdigit() or self.peek() == '.':\n                number = self.read_number()\n                tokens.append(Token(TokenType.NUMBER, number))\n            elif self.peek() == '+':\n                tokens.append(Token(TokenType.PLUS, '+'))\n                self.advance()\n            elif self.peek() == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, not subtraction\n                    self.advance()\n                    number = self.read_number(",
          "time_taken": 207.2079930305481
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: x}\n    \n    # 正确调用\n    tr",
          "time_taken": 35.51908612251282
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \n            Args:\n                *args: 函数位置参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常，如果重试次数用尽\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                    \n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise e\n                    \n                    logger.warning(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试时失败: {e}\")\n                ",
          "time_taken": 234.77208018302917
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 272, in <module>\n  File \"<string>\", line 233, in __exit__\n  File \"<string>\", line 217, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle None values for shutdown signal\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try",
          "time_taken": 188.47627973556519
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[An",
          "time_taken": 23.535270929336548
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 247.08000493049622
        }
      ],
      "elapsed_seconds": 515.3
    },
    {
      "round": 91,
      "timestamp": 1771053289.6571279,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 252, in <module>\n  File \"<string>\", line 210, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle case where other is None (shutdown signal)\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n        ",
          "time_taken": 56.14744782447815
        }
      ],
      "elapsed_seconds": 276.4
    },
    {
      "round": 92,
      "timestamp": 1771053705.406741,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 263, in <module>\n  File \"<string>\", line 225, in __exit__\n  File \"<string>\", line 209, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None values (for shutdown signaling)\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    i",
          "time_taken": 190.58667588233948
        }
      ],
      "elapsed_seconds": 415.7
    },
    {
      "round": 93,
      "timestamp": 1771054137.790163,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 259, in <module>\n  File \"<string>\", line 236, in __exit__\n  File \"<string>\", line 220, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle the case where other is None (shutdown signal)\n        if other is None:\n            return False  # None should not be considered as lower priority\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For other types, fallback to default comparison\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从",
          "time_taken": 133.4519238471985
        }
      ],
      "elapsed_seconds": 432.3
    },
    {
      "round": 94,
      "timestamp": 1771054415.775383,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 248, in <module>\n  File \"<string>\", line 206, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                        result = self._execute_with_timeout",
          "time_taken": 24.79090189933777
        }
      ],
      "elapsed_seconds": 277.9
    },
    {
      "round": 95,
      "timestamp": 1771054949.489259,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 229.75633811950684
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Optional\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分为两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [1, 1, 1, 1],          # 重复元素\n        [-3, -1, -4, -1, -5]   # 负数列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n        assert test_case == original, \"原列表被修改了！\"\n        # 验证排序正确性\n ",
          "time_taken": 242.57598996162415
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n                \n            elif char.isdigit() or char == '.':\n                self._read_number()\n                \n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n                \n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n                    \n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n                \n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n                \n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n                \n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n                \n            else:\n                raise ValueError(f\"Invalid character: {char}\")\n                \n        return self.toke",
          "time_taken": 183.907958984375
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 275, in <module>\n  File \"<string>\", line 209, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                        resu",
          "time_taken": 165.2603530883789
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, items: list, data: dict) -> str:\n        return f\"Name: {name}, Age: {age}, I",
          "time_taken": 137.81230187416077
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 163, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/runners.py\", line 44, in run\n    return loop.run_until_complete(main)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py\", line 642, in run_until_complete\n    return future.result()\n  File \"<string>\", line 78, in process\n  File \"<string>\", line 64, in _process_single_stage\n  File \"<string>\", line 50, in _process_single_stage\n  File \"<string>\", line 153, in stage3_async\nValueError: Data too large",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误计数\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['errors'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage",
          "time_taken": 124.41664910316467
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                retries = 0\n                current_delay = delay\n                \n                while True:\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        retries += 1\n                        if retries > max_retries:\n                            logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                            raise e\n                        \n                        logger.warning(\n                            f\"函数 {func.__name__} 第 {retries} 次重试失败: {e}, \"\n                            f\"将在 {current_delay:.2f} 秒后重试\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                        \n            return async_wrapper\n        else:\n            # 同步函数",
          "time_taken": 205.29933619499207
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n",
          "time_taken": 219.4843361377716
        }
      ],
      "elapsed_seconds": 533.6
    },
    {
      "round": 96,
      "timestamp": 1771055312.398199,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[An",
          "time_taken": 15.470059156417847
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 265, in <module>\n  File \"<string>\", line 237, in __exit__\n  File \"<string>\", line 221, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'Task'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.",
          "time_taken": 144.33963298797607
        }
      ],
      "elapsed_seconds": 362.8
    },
    {
      "round": 97,
      "timestamp": 1771055539.0327911,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 301, in <module>\n  File \"<string>\", line 223, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                        resu",
          "time_taken": 50.03290581703186
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段的处理。\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功处理的统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage_name,",
          "time_taken": 21.255552768707275
        }
      ],
      "elapsed_seconds": 226.6
    },
    {
      "round": 98,
      "timestamp": 1771055859.0172758,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 250, in <module>\n  File \"<string>\", line 208, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                        result = self._execute_with_timeout(task.func, t",
          "time_taken": 45.866451025009155
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理器，支持按顺序执行异步/同步函数阶段，\n    并发处理数据批次。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序处理数据，通过所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_st",
          "time_taken": 22.07203507423401
        }
      ],
      "elapsed_seconds": 319.9
    },
    {
      "round": 99,
      "timestamp": 1771056391.8177128,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 532.7
    },
    {
      "round": 100,
      "timestamp": 1771057037.6209211,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 296.61618089675903
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度为 O(n log n)，空间复杂度为 O(n)。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分为两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序结果: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 308.0214309692383
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 202, in <module>\n  File \"<string>\", line 194, in evaluate\n  File \"<string>\", line 60, in tokenize\nTypeError: peek() takes 1 positional argument but 2 were given",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    END = \"END\"\n\nclass Token:\n    def __init__(self, type_: TokenType, value: Union[float, str] = None):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return \"\"\n    \n    def consume(self) -> str:\n        char = self.peek()\n        self.position += 1\n        return char\n    \n    def is_digit(self, char: str) -> bool:\n        return char.isdigit()\n    \n    def is_dot(self, char: str) -> bool:\n        return char == \".\"\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.position = 0\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isspace():\n                self.consume()\n                continue\n            \n            if char == \"+\":\n                self.tokens.append(Token(TokenType.PLUS))\n                self.consume()\n            elif char == \"-\":\n                # Check if this is a negative number\n                if self.position == 0 or self.peek(-1) in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    # Read the following number\n                    number_str = \"-\"\n                    self.consume()\n                    while self.position < len(self.expression):\n                        next_char = self.peek()\n                        if self.is_digit(next_char) or self.is_dot(next_char):\n                            number_str += next_char\n  ",
          "time_taken": 225.25929713249207
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\nimport sys\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型 (包括 Optional)\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 List 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否是 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 Dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否是 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n       ",
          "time_taken": 54.61518907546997
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional, Coroutine\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Coroutine[Any, Any, T]]\nFunc = Union[SyncFunc, AsyncFunc]\n\nasync def async_sleep(delay: float) -> None:\n    \"\"\"异步睡眠\"\"\"\n    await asyncio.sleep(delay)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Func], Func]:\n    \"\"\"\n    自动重试装饰器\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Func) -> Func:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"异步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                        logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                        await async_sleep(current_delay)\n                        current_delay *= backoff\n            \n            # 理论上不会执行到这里\n            raise RuntimeError(\"重试逻辑异常\")\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            ",
          "time_taken": 271.0401051044464
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Tuple\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持添加处理阶段、顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[name]['calls'] += 1\n            self.stats_data[name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[name]['calls'] += 1\n            self.stats_data[name]['total_time'] += (time.time() - start_time)\n            self.stats_data[name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for name, fn in self.stages.items():\n            result = await self._process_single_stage(name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n ",
          "time_taken": 23.531949043273926
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 285.9637830257416
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    i",
          "time_taken": 264.03583216667175
        }
      ],
      "elapsed_seconds": 645.7
    },
    {
      "round": 101,
      "timestamp": 1771057434.191278,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n                \n            elif char.isdigit() or char == '.':\n                self._read_number()\n                \n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n                \n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n                    \n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n                \n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n                \n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n                \n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n                \n            else:\n                raise ValueError(f\"Invalid character: {char}\")\n                \n        return self.toke",
          "time_taken": 173.30156588554382
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For other types, we can't compare, so return False\n        return False\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号",
          "time_taken": 213.34957003593445
        }
      ],
      "elapsed_seconds": 396.5
    },
    {
      "round": 102,
      "timestamp": 1771057805.060274,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    END = \"END\"\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str] = None):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return \"\"\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return \"\"\n    \n    def is_digit(self, char: str) -> bool:\n        return char.isdigit()\n    \n    def is_dot(self, char: str) -> bool:\n        return char == \".\"\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isspace():\n                self.advance()\n                continue\n            \n            if char == \"+\":\n                tokens.append(Token(TokenType.PLUS))\n                self.advance()\n            \n            elif char == \"-\":\n                # Check if this is a negative sign\n                if tokens and tokens[-1].type in [TokenType.PLUS, TokenType.MINUS, \n                                                  TokenType.MULTIPLY, TokenType.DIVIDE, TokenType.LPAREN]:\n                    # This is a negative sign, not a subtraction operator\n                    # We need to parse the following number as negative\n                    number_str = \"-\"\n                    self.advan",
          "time_taken": 183.38233304023743
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 240, in <module>\n  File \"<string>\", line 216, in __exit__\n  File \"<string>\", line 203, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # When comparing with None, treat None as higher priority (so it goes last)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For any other type, we can't compare, so return False\n        return False\n\nclass TaskPool(Executor):\n    def __init__(self, max_workers=None):\n        if max_workers is None:\n            max_workers = 4\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                        result = self._execute_with_timeout(task.func, task.args, task.kwargs, task.timeout)\n                    else:\n                        ",
          "time_taken": 161.85110926628113
        }
      ],
      "elapsed_seconds": 370.8
    },
    {
      "round": 103,
      "timestamp": 1771058166.054347,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 192, in <module>\n  File \"<string>\", line 183, in evaluate\n  File \"<string>\", line 68, in tokenize\nTypeError: peek() takes 1 positional argument but 2 were given",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    END = \"END\"\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return \"\"\n    \n    def consume(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return \"\"\n    \n    def is_digit(self, char: str) -> bool:\n        return char.isdigit()\n    \n    def is_operator(self, char: str) -> bool:\n        return char in \"+-*/\"\n    \n    def is_paren(self, char: str) -> bool:\n        return char in \"()\"\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.position = 0\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isspace():\n                self.consume()\n                continue\n            \n            if self.is_digit(char) or char == '.':\n                # Parse number (including floats)\n                number_str = \"\"\n                while self.position < len(self.expression) and (self.is_digit(self.peek()) or self.peek() == '.'):\n                    number_str += self.consume()\n                self.tokens.append(Token(TokenType.NUMBER, float(number_str)))\n            elif self.is_operator(char):\n                # Handle unary minus\n                if char == '-' and (self.position == 0 or self.peek(-1) ==",
          "time_taken": 75.6557047367096
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 245, in <module>\n  File \"<string>\", line 210, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                     ",
          "time_taken": 54.16063690185547
        }
      ],
      "elapsed_seconds": 360.9
    },
    {
      "round": 104,
      "timestamp": 1771058521.161726,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    END = \"END\"\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str] = None):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return \"\"\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return \"\"\n    \n    def is_digit(self, char: str) -> bool:\n        return char.isdigit()\n    \n    def is_dot(self, char: str) -> bool:\n        return char == \".\"\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isspace():\n                self.advance()\n                continue\n            \n            if char == \"+\":\n                tokens.append(Token(TokenType.PLUS))\n                self.advance()\n            \n            elif char == \"-\":\n                # Check if this is a negative sign\n                if not tokens or tokens[-1].type in [TokenType.PLUS, TokenType.MINUS, \n                                                     TokenType.MULTIPLY, TokenType.DIVIDE, TokenType.LPAREN]:\n                    # This is a negative sign, not a subtraction operator\n                    # We need to parse the following number as negative\n                    number_str = \"-\"\n                    self",
          "time_taken": 113.8448429107666
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 259, in <module>\n  File \"<string>\", line 216, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle case where other is None (shouldn't happen in normal operation)\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                tr",
          "time_taken": 91.30403995513916
        }
      ],
      "elapsed_seconds": 355.0
    },
    {
      "round": 105,
      "timestamp": 1771059175.096328,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算剩余的斐波那契数\n    # 避免了指数级递归的效率问题\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率 - 大数值测试\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 255.40103816986084
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法\n    \n    归并排序是一种基于分治思想的稳定排序算法。它将数组递归地分成两半，\n    分别排序后再合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 268.23131799697876
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 62, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 150, in <module>\n  File \"<string>\", line 140, in evaluate\n  File \"<string>\", line 33, in tokenize\n  File \"<string>\", line 65, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n\n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Invalid character: {char}\")\n        return self.tokens\n\n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n           ",
          "time_taken": 208.4613528251648
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型（包括 Optional）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return isinstance(value, list)\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return isinstance(value, dict)\n        # 检查键值对是否匹配\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) for k, v in value.items())\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, h",
          "time_taken": 37.421122789382935
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Coroutine, Type, Tuple, Union, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[Callable, Coroutine]) -> Union[Callable, Coroutine]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"等待 {current_delay:.2f} 秒后重试...\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise\n                except Exception as e:\n                    # 如果遇到不支持的异常类型，直接抛出\n                    logger.error(f\"函数 {func.__name__} 遇到不支持的异常类型: {e}\")\n                    raise\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n    ",
          "time_taken": 228.8555872440338
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持按顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self._stages[name] = fn\n    \n    async def _execute_stage(self, name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息。\n        \n        Args:\n            name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            stage_func = self._stages[name]\n            is_async = asyncio.iscoroutinefunction(stage_func)\n            \n            if is_async:\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 更新统计信息\n            self._stats[name]['calls'] += 1\n            self._stats[name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self._stats[name]['calls'] += 1\n            self._stats[name]['total_time'] += (time.time() - start_time)\n            self._stats[name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._execute_stage(stage_name, result)\n  ",
          "time_taken": 21.449422121047974
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1 (not evicted yet)\n    \n    # Test thread safety\n    def thread_worker(thread_id):\n        for i in range(5):\n            cache.put(f\"thread{thread_id}_key{i}\", f\"value{thread_id}_{i}\")\n            print(f\"Thread {thread_id}: {cache.get(f'thread{thread_id}_key{i}')}\")\n    \n    import concurrent.futures\n    with concurrent.futures.ThreadPoolExecut",
          "time_taken": 245.24744486808777
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority < other.priority\n    \n    def __eq__(self, other):\n        \"\"\"相等比较，用于PriorityQueue的比较需求\"\"\"\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority == other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n     ",
          "time_taken": 250.8425657749176
        }
      ],
      "elapsed_seconds": 653.9
    },
    {
      "round": 106,
      "timestamp": 1771059580.561981,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    END = \"END\"\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str] = None):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return \"\"\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return \"\"\n    \n    def is_digit(self, char: str) -> bool:\n        return char.isdigit()\n    \n    def is_dot(self, char: str) -> bool:\n        return char == \".\"\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isspace():\n                self.advance()\n                continue\n            \n            if char == \"+\":\n                tokens.append(Token(TokenType.PLUS))\n                self.advance()\n            \n            elif char == \"-\":\n                # Check if this is a negative sign\n                if not tokens or tokens[-1].type in [TokenType.PLUS, TokenType.MINUS, \n                                                    TokenType.MULTIPLY, TokenType.DIVIDE, TokenType.LPAREN]:\n                    # This is a negative sign, not a subtraction operator\n                    # We need to parse the following number as negative\n                    number_str = \"-\"\n                    self.",
          "time_taken": 192.20871877670288
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 282, in <module>\n  File \"<string>\", line 235, in __exit__\n  File \"<string>\", line 222, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False\n        if self.priority == other.priority:\n            # If priorities are equal, compare by task counter to maintain order\n            return id(self) < id(other)\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        self._task_counter_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try",
          "time_taken": 170.73190999031067
        }
      ],
      "elapsed_seconds": 405.4
    },
    {
      "round": 107,
      "timestamp": 1771060049.552665,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.po",
          "time_taken": 160.97199010849
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 267, in <module>\n  File \"<string>\", line 238, in __exit__\n  File \"<string>\", line 222, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (used for shutdown signals)\n        if other is None:\n            return False\n        # Handle comparison with other Task objects\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For any other type, we can't compare\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务",
          "time_taken": 145.12435793876648
        }
      ],
      "elapsed_seconds": 468.9
    },
    {
      "round": 108,
      "timestamp": 1771060329.6460989,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                self.tokens.append(Token('MINUS', '-'))\n                self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        value = float(self.expression[start:self.pos])\n        self.tokens.append(Token('NUMBER', value))\n\nclass Parser:\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.pos = 0\n    \n    def peek(self) -> Token:\n",
          "time_taken": 154.14763808250427
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 265, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/concurrent/futures/_base.py\", line 447, in result\n    raise TimeoutError()\nconcurrent.futures._base.TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 272, in <module>\n  File \"<string>\", line 232, in __exit__\n  File \"<string>\", line 219, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For comparison with None (during shutdown), treat None as having lowest priority\n        # This ensures None can be compared with Task objects\n        # When other is None, we consider self to be \"greater\" so None gets lower priority\n        return True\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n            ",
          "time_taken": 135.5001139640808
        }
      ],
      "elapsed_seconds": 280.0
    },
    {
      "round": 109,
      "timestamp": 1771060765.325342,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 435.6
    },
    {
      "round": 110,
      "timestamp": 1771061320.720057,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率 - 大数值测试\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 272.0615601539612
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，通过递归地将数组分成两半，分别排序后合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 283.0973000526428
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 76, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 163, in <module>\n  File \"<string>\", line 153, in evaluate\n  File \"<string>\", line 44, in tokenize\n  File \"<string>\", line 79, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    END = \"END\"\n\nclass Token:\n    def __init__(self, type_: TokenType, value: Union[float, str] = None):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n\n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token(TokenType.PLUS))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token(TokenType.MINUS))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token(TokenType.MULTIPLY))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token(TokenType.DIVIDE))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token(TokenType.LPAREN))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token(TokenType.RPAREN))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\"",
          "time_taken": 228.22528290748596
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        return isinstance(value, list) and all(_matches_type(v, args[0]) for v in value) if args else isinstance(value, list)\n    elif origin is dict:\n        return isinstance(value, dict) and all(_matches_type(k, args[0]) and _matches_type(v, args[1]) for k, v in value.items()) if args else isinstance(value, dict)\n    else:\n        # 兜底：对于其他泛型类型，只检查容器类型本身\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, items: list[int], data: dict[str, int]) -> int:\n        return x + sum(items)\n    \n    # 正确使用\n    try:\n        result = example_func(5, \"hello\", [1, 2, 3], {\"a\": 1, \"b\": 2})\n        ",
          "time_taken": 57.209386110305786
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录性能统计\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concu",
          "time_taken": 45.24542784690857
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"d\"))  # Should return 4\n    \n    # Test that existing entries are moved to end\n    cache.put(\"e\", 5)\n    cache.put(\"f\", 6)\n    print(cache.get(\"e\"))  # Should return None (evicted)\n    print(cache.get(\"f\"))  # Should return 6\n",
          "time_taken": 261.76990127563477
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"异步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(\n                            f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}, \"\n                            f\"将在 {current_delay:.2f} 秒后重试\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                except Exception as e:\n                    # 非指定异常类型直接抛出\n                    logger.error(f\"函数 {func.__name__} 执行时发生未指定异常: {e}\")\n                    raise\n            \n        @func",
          "time_taken": 252.36741089820862
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None values (for shutdown signals)\n        if other is None:\n            return False\n        if self.priority == other.priority:\n            # If priorities are equal, compare by id to ensure consistent ordering\n            return id(self) < id(other)\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._t",
          "time_taken": 269.3214988708496
        }
      ],
      "elapsed_seconds": 555.3
    },
    {
      "round": 111,
      "timestamp": 1771061652.5310998,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        value = float(self.expression[start:self.pos",
          "time_taken": 175.13443613052368
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 255, in <module>\n  File \"<string>\", line 232, in __exit__\n  File \"<string>\", line 216, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if other is None:\n            return False\n        return self.priority < other.priority\n    \n    def __eq__(self, other):\n        \"\"\"相等比较\"\"\"\n        if other is None:\n            return False\n        return self.priority == other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                  ",
          "time_taken": 157.39874792099
        }
      ],
      "elapsed_seconds": 331.8
    },
    {
      "round": 112,
      "timestamp": 1771061972.4928799,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                num_str = self.expression[start:self.pos]\n                self.tokens.append(Token('NUMBER', float(num_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos-1] in '(+-*/':\n                    # This is a negative sign, not subtraction\n                    start = self.pos\n                    self.pos += 1\n                    while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                        self.pos += 1\n                    num_str = self.expression[start:self.pos]\n                    self.tokens.append(Token('NUMBER', float(num_str)))\n                else:\n                    self.tokens.append(Token('-', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.appe",
          "time_taken": 78.77898406982422
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 262, in <module>\n  File \"<string>\", line 223, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (used for shutdown signals)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n       ",
          "time_taken": 59.60816836357117
        }
      ],
      "elapsed_seconds": 319.9
    },
    {
      "round": 113,
      "timestamp": 1771062300.090393,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type_: str, value: Union[float, str]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.current_char = self.expression[self.pos] if self.expression else None\n    \n    def advance(self):\n        \"\"\"Move to the next character.\"\"\"\n        self.pos += 1\n        if self.pos >= len(self.expression):\n            self.current_char = None\n        else:\n            self.current_char = self.expression[self.pos]\n    \n    def skip_whitespace(self):\n        \"\"\"Skip whitespace characters.\"\"\"\n        while self.current_char and self.current_char.isspace():\n            self.advance()\n    \n    def read_number(self) -> float:\n        \"\"\"Read a number (including decimals).\"\"\"\n        num_str = \"\"\n        while self.current_char and (self.current_char.isdigit() or self.current_char == '.'):\n            num_str += self.current_char\n            self.advance()\n        return float(num_str)\n    \n    def tokenize(self) -> List[Token]:\n        \"\"\"Convert expression string into a list of tokens.\"\"\"\n        tokens = []\n        \n        while self.current_char:\n            self.skip_whitespace()\n            \n            if self.current_char is None:\n                break\n            \n            if self.current_char.isdigit() or self.current_char == '.':\n                tokens.append(Token(TokenType.NUMBER, self.read_number()))\n            elif self.current_char == '+':\n                tokens.append(Token(TokenType.PLUS, '+'))\n                self.advance()\n            elif self.current_char == '-':\n                # Check if ",
          "time_taken": 182.40940475463867
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 246, in <module>\n  File \"<string>\", line 219, in __exit__\n  File \"<string>\", line 206, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False\n        if self.priority == other.priority:\n            # If priorities are equal, compare by id to ensure stable ordering\n            return id(self) < id(other)\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.g",
          "time_taken": 159.48322415351868
        }
      ],
      "elapsed_seconds": 327.5
    },
    {
      "round": 114,
      "timestamp": 1771062558.7883039,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 287, in <module>\n  File \"<string>\", line 208, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        self._task_counter_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                       ",
          "time_taken": 49.473536014556885
        }
      ],
      "elapsed_seconds": 258.6
    },
    {
      "round": 115,
      "timestamp": 1771063021.714443,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    # 使用迭代而非递归，时间复杂度O(n)，空间复杂度O(1)（不包括结果列表）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 267.5911738872528
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef merge_sort(arr: List[T]) -> List[T]:\n    \"\"\"\n    对输入列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的列表，可以包含任何可比较的元素\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort(['c', 'a', 'b'])\n        ['a', 'b', 'c']\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[T], right: List[T]) -> List[T]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序列表\n        right: 右侧已排序列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],  # 空列表\n        [1],  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 4, 3, 2, 1],  # 逆序列表\n        [1, 2, 3, 4, 5],  # 已排序列表\n        [2, 2, 2, 2],  # 重复元素\n        ['c', 'a', 'b', 'd'],  # 字符串列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原列表: {original}\")\n        print(f\"  排序后: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 280.4098811149597
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n\n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._parse_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._parse_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MUL', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIV', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n\n    def _parse_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        value = float(self.expression[start:self.pos])\n    ",
          "time_taken": 225.6793029308319
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"\n    检查值是否匹配期望的类型。\n    \n    Args:\n        value: 要检查的值\n        expected_type: 期望的类型\n        \n    Returns:\n        bool: 如果值匹配类型返回True，否则返回False\n    \"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 如果是普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（如 Optional[X] 等价于 Union[X, None]）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器。\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名并绑定参数\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise ",
          "time_taken": 37.75958800315857
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\nfrom typing_extensions import ParamSpec\n\nT = TypeVar('T')\nP = ParamSpec('P')\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间会乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (attempt {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 在 {max_retries + 1} 次重试后仍然失败: {e}\"\n                        )\n                        raise\n            raise last_exception  # 这行代码实际上不会执行到\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_",
          "time_taken": 244.68840336799622
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持按顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_func = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 记录成功统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的最终数据\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage_name, result)\n        return result\n    \n    async def process_batch(se",
          "time_taken": 21.44295024871826
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 256.7193191051483
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False\n        if self is None:\n            return True\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n            ",
          "time_taken": 266.68846893310547
        }
      ],
      "elapsed_seconds": 462.8
    },
    {
      "round": 116,
      "timestamp": 1771063337.636642,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 284, in <module>\n  File \"<string>\", line 204, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                        result = self._execute_with_timeout",
          "time_taken": 49.28432893753052
        }
      ],
      "elapsed_seconds": 315.8
    },
    {
      "round": 117,
      "timestamp": 1771063713.8243022,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 267, in <module>\n  File \"<string>\", line 238, in __exit__\n  File \"<string>\", line 222, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False  # None should be processed last (higher priority)\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is N",
          "time_taken": 128.62124705314636
        }
      ],
      "elapsed_seconds": 376.1
    },
    {
      "round": 118,
      "timestamp": 1771064023.8761191,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 266, in <module>\n  File \"<string>\", line 229, in __exit__\n  File \"<string>\", line 212, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'Task'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    i",
          "time_taken": 138.76036977767944
        }
      ],
      "elapsed_seconds": 310.0
    },
    {
      "round": 119,
      "timestamp": 1771064369.107127,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (shutdown signal)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For non-Task objects, we can't compare, so return False\n        return False\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is ",
          "time_taken": 222.032879114151
        }
      ],
      "elapsed_seconds": 345.2
    },
    {
      "round": 120,
      "timestamp": 1771064832.079922,
      "passed": 7,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [0, 1, 2, 5, 10]\n    \n    for case in test_cases:\n        print(f\"fibonacci({case}) = {fibonacci(case)}\")\n",
          "time_taken": 299.298406124115
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种基于分治思想的稳定排序算法。它将数组递归地分成两半，\n    对每一半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保纯函数特性\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余的元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 313.2479920387268
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n\n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                self.tokens.append(Token('MINUS', '-'))\n                self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n\n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        number_str = self.expression[start:self.pos]\n        try:\n            if '.' in number_str:\n                number = float(number_str)\n            else:\n                number = int(number_str)\n            self.tokens.append(Token('NUMBER', number))\n        except V",
          "time_taken": 249.90295028686523
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:  # 无参数的 List\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:  # 无参数的 Dict\n            return True\n        # 检查键和值的类型\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) for k, v in value.items())\n    \n    # 兜底处理\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数，会在运行时检查参数和返回值类型\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n    ",
          "time_taken": 93.08507585525513
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.warning(\n                                f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}. \"\n                                f\"将在 {current_delay:.2f} 秒后重试...\"\n                            )\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.error(\n                                f\"函数 {func.__name__} 最终失败，已达到最大重试次数 {max_retries}: {e}",
          "time_taken": 274.9607481956482
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name",
          "time_taken": 21.457926988601685
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (still in cache)\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 290.6535358428955
        }
      ],
      "elapsed_seconds": 462.9
    },
    {
      "round": 121,
      "timestamp": 1771065212.604585,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 207, in <module>\n  File \"<string>\", line 207, in <listcomp>\n  File \"<string>\", line 132, in submit\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'Task' and 'Task'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 211, in <module>\n  File \"<string>\", line 193, in __exit__\n  File \"<string>\", line 181, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Pyt",
          "code_generated": "import threading\nimport time\nimport queue\n\n# Make sure the Task class is properly defined\nclass Task:\n    def __init__(self, func, args, kwargs, priority, timeout):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.priority = priority\n        self.timeout = timeout\n        self.future = None\n\n# Make sure Future class is properly defined\nclass Future:\n    def __init__(self):\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result):\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception):\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout=None):\n        with self._condition:\n            if not self._done:\n                self._condition.wait(timeout)\n            if self._exception:\n                raise self._exception\n            return self._result\n\n# Final clean corrected version\nclass TaskPoolFinal:\n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        Initialize task pool\n        \n        Args:\n            max_workers: Number of worker threads\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: list[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        \n        # Start worker threads\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"Worker thread loop\"\"\"\n   ",
          "time_taken": 233.33788895606995
        }
      ],
      "elapsed_seconds": 380.4
    },
    {
      "round": 122,
      "timestamp": 1771065537.7394052,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 333, in <module>\n  File \"<string>\", line 207, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                        result = self._execute_with_timeout",
          "time_taken": 33.019137144088745
        }
      ],
      "elapsed_seconds": 325.1
    },
    {
      "round": 123,
      "timestamp": 1771065669.672124,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 251, in <module>\n  File \"<string>\", line 212, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                        result = self._execute_with_timeout(task.func, t",
          "time_taken": 25.07010316848755
        }
      ],
      "elapsed_seconds": 131.9
    },
    {
      "round": 124,
      "timestamp": 1771066035.059402,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle case where other is not a Task instance\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try",
          "time_taken": 218.79710912704468
        }
      ],
      "elapsed_seconds": 365.3
    },
    {
      "round": 125,
      "timestamp": 1771066755.386753,
      "passed": 5,
      "total": 8,
      "avg_score": 7.06,
      "pass_rate": 0.625,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个斐波那契数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个斐波那契数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 340.3836929798126
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 351.4817349910736
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 59, in _parse_number\nValueError: could not convert string to float: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 158, in <module>\n  File \"<string>\", line 148, in evaluate\n  File \"<string>\", line 33, in tokenize\n  File \"<string>\", line 62, in _parse_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._parse_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative number\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._parse_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _parse_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        number_str = self.expression[start:self.pos]\n     ",
          "time_taken": 268.3971657752991
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) for k, v in value.items())\n    else:\n        # 兜底：如果是普通类型则用 isinstance 检查\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, data: list) -> dict:\n        return {\"result\": x, \"message\": y, \"items\": data}\n    ",
          "time_taken": 121.76450419425964
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 163, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/runners.py\", line 44, in run\n    return loop.run_until_complete(main)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py\", line 642, in run_until_complete\n    return future.result()\n  File \"<string>\", line 76, in process\n  File \"<string>\", line 62, in _process_single_stage\n  File \"<string>\", line 48, in _process_single_stage\n  File \"<string>\", line 153, in stage3_async\nValueError: 数据过大",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序处理和并发批量处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage_name, result)\n        return result\n    \n    async def ",
          "time_taken": 106.94141817092896
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional, Coroutine\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Coroutine[Any, Any, T]]\nFunc = Union[SyncFunc, AsyncFunc]\n\nasync def async_sleep(delay: float) -> None:\n    \"\"\"异步睡眠\"\"\"\n    await asyncio.sleep(delay)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Func], Func]:\n    \"\"\"\n    自动重试装饰器\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Func) -> Func:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"异步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次尝试失败: {e}\")\n                        logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                        await async_sleep(current_delay)\n                        current_delay *= backoff\n                except Exception as e:\n                    # 不在指定异常列表中的异常直接抛出\n                    logger.error(f\"函数 {func.__name__} 遇到未预期异常: {e}\")\n                    raise\n            \n  ",
          "time_taken": 316.05669474601746
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 269, in <module>\n  File \"<string>\", line 246, in __exit__\n  File \"<string>\", line 230, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if other is None:\n            return False\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority < other.priority\n    \n    def __eq__(self, other):\n        \"\"\"相等比较\"\"\"\n        if not isinstance(other, Task):\n            return False\n        return (self.func == other.func and \n                self.args == other.args and \n                self.kwargs == other.kwargs and\n                self.priority == other.priority)\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.app",
          "time_taken": 251.09949207305908
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 330.30449295043945
        }
      ],
      "elapsed_seconds": 720.3
    },
    {
      "round": 126,
      "timestamp": 1771067096.1587389,
      "passed": 7,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n\n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n\n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        number_str = self.expression[start:self.pos]\n        try:\n",
          "time_taken": 225.89167094230652
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name",
          "time_taken": 48.69839787483215
        }
      ],
      "elapsed_seconds": 340.7
    },
    {
      "round": 127,
      "timestamp": 1771067948.596396,
      "passed": 6,
      "total": 8,
      "avg_score": 7.06,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_func = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 记录统计数据\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['errors'] += 1\n            self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        ",
          "time_taken": 21.510398864746094
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 248, in <module>\n  File \"<string>\", line 220, in __exit__\n  File \"<string>\", line 203, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                    \n                # 执行任务\n                try:\n                    if task.timeout:\n                      ",
          "time_taken": 172.92026615142822
        }
      ],
      "elapsed_seconds": 852.4
    },
    {
      "round": 128,
      "timestamp": 1771068413.9159522,
      "passed": 7,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n\n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n\n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        number_str = self.expression[start:self.pos]\n        try:\n",
          "time_taken": 234.79138278961182
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self._stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，并记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_stats = self._stats[stage_name]\n        \n        try:\n            stage_fn = self._stages[stage_name]\n            \n            # 判断是否为异步函数\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            stage_stats['calls'] += 1\n            stage_stats['total_time'] += (time.time() - start_time)\n            return result\n            \n        except Exception as e:\n            stage_stats['calls'] += 1\n            stage_stats['total_time'] += (time.time() - start_time)\n            stage_stats['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._execute_stage(stage_name, result)\n        ret",
          "time_taken": 24.777677059173584
        }
      ],
      "elapsed_seconds": 465.2
    },
    {
      "round": 129,
      "timestamp": 1771068792.114229,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\nimport re\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"+\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in \"(+-*/\":\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token(\"NUMBER\", float(number_str)))\n                else:\n                    s",
          "time_taken": 193.54007124900818
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False\n        if self.priority == other.priority:\n            # If priorities are equal, compare by task counter to maintain order\n            return id(self) < id(other)\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        self._task_counter_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try",
          "time_taken": 234.855975151062
        }
      ],
      "elapsed_seconds": 378.1
    },
    {
      "round": 130,
      "timestamp": 1771069215.82618,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算（索引为2）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 275.6927869319916
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [1, 1, 1, 1],          # 重复元素\n        [-3, -1, -4, -1, -5]   # 负数\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_arr}\")\n        # 验证原列表未被修改\n        assert test_case == original, \"原列表被修改了！\"\n        # 验证排序正确\n        assert sorted_arr == sorted(original), \"排序结果错误！\"\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 287.97389483451843
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                self.tokens.append(Token('MINUS', '-'))\n                self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        value = float(self.expression[start:self.pos])\n        self.tokens.append(Token('NUMBER', value))\n\nclass Parser:\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.pos = 0\n    \n    de",
          "time_taken": 225.76313304901123
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, scores: list[int], info: dict[str, int]) -> str:\n        return f\"Name: {name}",
          "time_taken": 52.52417516708374
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 263, in <module>\n  File \"<string>\", line 236, in __exit__\n  File \"<string>\", line 220, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle case where other is None (which shouldn't happen in normal operation)\n        if other is None:\n            return False\n        # Handle case where other is not a Task instance\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(tim",
          "time_taken": 208.91814398765564
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n        return result\n    \n    async def process_batch(self, items: List[Any],",
          "time_taken": 24.30399990081787
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\"\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (still in cache)\n    \n    # Test overwriting existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 265.7275929450989
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \n            Args:\n                *args: 函数参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常，如果重试次数用完\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                        logger.info(f\"等",
          "time_taken": 253.9402620792389
        }
      ],
      "elapsed_seconds": 423.6
    },
    {
      "round": 131,
      "timestamp": 1771069670.616144,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 278, in <module>\n  File \"<string>\", line 249, in __exit__\n  File \"<string>\", line 233, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (used for shutdown signals)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For other types, we can't compare, so return False\n        return False\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if tas",
          "time_taken": 136.54960584640503
        }
      ],
      "elapsed_seconds": 454.7
    },
    {
      "round": 132,
      "timestamp": 1771070078.9157178,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None or other non-Task objects\n        if other is None:\n            return False\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        self._task_counter_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n   ",
          "time_taken": 276.83572602272034
        }
      ],
      "elapsed_seconds": 408.2
    },
    {
      "round": 133,
      "timestamp": 1771070388.4670222,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 309.5
    },
    {
      "round": 134,
      "timestamp": 1771070632.018388,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 259, in <module>\n  File \"<string>\", line 232, in __exit__\n  File \"<string>\", line 219, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (shutdown signals)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        self._task_counter_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n              ",
          "time_taken": 140.06499218940735
        }
      ],
      "elapsed_seconds": 243.5
    },
    {
      "round": 135,
      "timestamp": 1771071068.0698931,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率（大数值测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 227.72720217704773
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Optional\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组递归地分成两半，\n    对每一半分别进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表保持不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 242.5808141231537
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position += 1\n                    number_str = self.expression[start:s",
          "time_taken": 183.17451286315918
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 如果没有原始类型（普通类型如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数，会在运行时检查参数和返回值类型\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints",
          "time_taken": 41.9072949886322
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 266, in <module>\n  File \"<string>\", line 242, in __exit__\n  File \"<string>\", line 226, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (shutdown signal)\n        if other is None:\n            return False\n        if self.priority == other.priority:\n            # If priorities are equal, compare by task creation order\n            # This is a simple approach - in a real implementation you might want\n            # to track creation order or use a more sophisticated approach\n            return id(self) < id(other)\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _work",
          "time_taken": 165.0381441116333
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理结果\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], ",
          "time_taken": 21.25155282020569
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 216.95117783546448
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\nFunc = Union[SyncFunc, AsyncFunc]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Func], Func]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Func) -> Func:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}\"\n                        )\n                        logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败，已达到最大重试次数 {max_retries + 1}: {e}\"\n                        )\n                        raise\n            raise last_exception  # 这行代码实际上不会执行到\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range",
          "time_taken": 205.88003730773926
        }
      ],
      "elapsed_seconds": 436.0
    },
    {
      "round": 136,
      "timestamp": 1771071433.210358,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 365.1
    },
    {
      "round": 137,
      "timestamp": 1771071790.9605298,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (used for shutdown signal)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For other types, we can't compare, so return False\n        return False\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        self._task_counter_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n         ",
          "time_taken": 211.6907660961151
        }
      ],
      "elapsed_seconds": 357.7
    },
    {
      "round": 138,
      "timestamp": 1771072257.454128,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle the case where other is None (used for shutdown signals)\n        if other is None:\n            return False\n        if self.priority == other.priority:\n            # If priorities are equal, compare by id to ensure consistent ordering\n            return id(self) < id(other)\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_que",
          "time_taken": 226.32229709625244
        }
      ],
      "elapsed_seconds": 466.4
    },
    {
      "round": 139,
      "timestamp": 1771072524.225827,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 273, in <module>\n  File \"<string>\", line 246, in __exit__\n  File \"<string>\", line 227, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For other types, we can't compare, so return False\n        return False\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout",
          "time_taken": 158.1606481075287
        }
      ],
      "elapsed_seconds": 266.7
    },
    {
      "round": 140,
      "timestamp": 1771073075.067082,
      "passed": 7,
      "total": 8,
      "avg_score": 8.31,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    # 使用迭代而非递归，时间复杂度O(n)，空间复杂度O(1)（不包括结果列表）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能（大数值测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 314.90138602256775
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法，时间复杂度为O(n log n)。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表保持不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {test_case} -> {result}\")\n    \n    # 验证原列表未被修改\n    original = [3, 1, 4, 1, 5]\n    result = merge_sort(original)\n    print(f\"原列表: {original}\")",
          "time_taken": 329.95193004608154
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n\n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._parse_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._parse_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n\n    def _parse_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n    ",
          "time_taken": 259.567745923996
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return re",
          "time_taken": 112.87599086761475
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 261, in <module>\n  File \"<string>\", line 234, in __exit__\n  File \"<string>\", line 218, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n            ",
          "time_taken": 240.78347325325012
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序和并发处理数据。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages = []\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        \n        self.stages.append((name, fn))\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name, stage_fn in self.stages:\n            start_time = time.time()\n            try:\n                if asyncio.iscoroutinefunction(stage_fn):\n                    result = await stage_fn(result)\n                else:\n                    result = stage_fn(result)\n                self.stats_data[stage_name]['calls'] += 1\n                self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            except Exception as e:\n                self.stats_data[stage_name]['errors'] += 1\n                self.stats_data[stage_name]['calls'] += 1\n                self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n                raise  # 重新抛出异常\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        \"\"\"\n        并发处理数据批次\n        \n        Args:\n            items: 数据列表\n            concurrency: 最大并发数\n            \n        Returns:\n            处理后的数据列表\n        \"\"\"\n        semaphore = asyncio.Semaphore(concurrency)\n        \n        async def process_item(item):\n         ",
          "time_taken": 98.81228280067444
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        \"\"\"\n        初始化LRU缓存\n        \n        Args:\n            capacity: 缓存的最大容量\n        \"\"\"\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        \"\"\"\n        获取缓存中的值\n        \n        Args:\n            key: 要获取的键\n            \n        Returns:\n            如果键存在且未过期，返回对应的值；否则返回None\n        \"\"\"\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        \"\"\"\n        向缓存中添加或更新键值对\n        \n        Args:\n            key: 要添加或更新的键\n            value: 要添加或更新的值\n            ttl: 过期时间（秒），如果为None则永不过期\n        \"\"\"\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 示例用法和测试\nif __name__ == \"__main__\":\n    # 创建一个容量为3的LRU缓存\n    cache = LRUCache(3)\n    \n    # 测试基本功能\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    cache.put(\"c\", 3)\n    \n    print(cache.get(\"a\"))  # 应该返回1\n    print(cache.get(\"b\"))  # 应该返回2\n    print(cache.get(\"c\"))  # 应该返回3\n    \n    # 测试LRU淘汰机制\n    cache.put(\"d\", 4)  # 应该淘汰键\"a\"\n    print(cache.get(\"a\"))  # 应该返回None（已淘汰）\n    print(cache.get(\"b\"))  # 应该返回2\n    \n    # 测试TTL功能\n    cache.put(\"e\", 5, ttl=1)  # 设置1秒过期\n    print(cache.get(\"e\"))  # 应该返回5\n    time.sleep(1.1)  # 等待1.1秒让其过期\n    print(cache.get(\"e\"))  # 应该返回None（已过期）\n    \n    # 测试更新操作\n    cache.put(\"f\", 6)\n   ",
          "time_taken": 304.5635027885437
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n        \n    Example:\n        @auto_retry(max_retries=3, delay=1.0, backoff=2.0, exceptions=(ValueError, TimeoutError))\n        def risky_function():\n            # 可能失败的函数\n            pass\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \n            Args:\n                *args: 函数位置参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常，如果重试次数用尽\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                    \n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.erro",
          "time_taken": 287.4257731437683
        }
      ],
      "elapsed_seconds": 550.8
    },
    {
      "round": 141,
      "timestamp": 1771073463.383059,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 267, in <module>\n  File \"<string>\", line 233, in __exit__\n  File \"<string>\", line 220, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (for shutdown signals)\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        self._task_counter = 0\n        self._task_counter_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n             ",
          "time_taken": 186.75640296936035
        }
      ],
      "elapsed_seconds": 388.2
    },
    {
      "round": 142,
      "timestamp": 1771073721.201403,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with shutdown signals\n        if isinstance(other, ShutdownSignal):\n            return False\n        if isinstance(self, ShutdownSignal):\n            return True\n        return self.priority < other.priority\n\nclass ShutdownSignal:\n    \"\"\"关闭信号类\"\"\"\n    def __lt__(self, other):\n        # Shutdown signal should be prioritized to exit immediately\n        return True\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    实现了基于线程的并发任务执行，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try",
          "time_taken": 138.50577998161316
        }
      ],
      "elapsed_seconds": 257.7
    },
    {
      "round": 143,
      "timestamp": 1771073862.368856,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom concurrent.futures import Future\nimport functools\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现\n    \n    该类提供了一个线程池来执行并发任务，支持任务提交、批量执行、优雅关闭等功能。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的位置参数\n            priority: 任务优先级（数值越小优先级越高，但此实现中不使用优先级队列）\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数的关键字参数\n            \n        Returns:\n            Future对象，可用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"Cannot submit tasks to a shutdown TaskPool\")\n            \n        # 使用functools.partial包装参数\n        func = functools.partial(fn, *args, **kwargs)\n        \n        # 提交任务到线程池\n        future = self._executor.submit(func)\n        \n        # 如果指定了超时时间，则包装future以支持超时\n        if timeout is not None:\n            original_future = future\n            \n            def timeout_wrapper():\n                try:\n                    # Use the original future's result with timeout\n                    result = original_future.result(timeout=timeout)\n                    return result\n                except concurrent.futures.TimeoutError:\n                    # Re-raise as TimeoutError\n                    raise TimeoutErr",
          "time_taken": 50.71184730529785
        }
      ],
      "elapsed_seconds": 141.1
    },
    {
      "round": 144,
      "timestamp": 1771073946.614924,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持任务提交、批量执行、优雅关闭等操作。\n    使用线程实现并发执行，支持任务超时和优先级。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n        \"\"\"\n        if not self._running:\n            raise RuntimeError(\"TaskPool已关闭，无法提交新任务\")\n        \n        task = Task(fn, args, kwargs, priority, timeout)\n        future = task.future\n        \n        # 将任务放入优先级队列\n        self._task_queue.put((priority, time.time(), task))\n        \n        return future\n    \n    def map(self, fn: Callable, iterable) -> List[Any]:\n        \"\"\"\n        批量执行任务\n ",
          "time_taken": 29.34124517440796
        }
      ],
      "elapsed_seconds": 84.2
    },
    {
      "round": 145,
      "timestamp": 1771074441.324575,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 276.8088889122009
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本，避免修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的数组\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 290.4506301879883
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            \n            elif char == '+':\n                self.tokens.append(Token(\"+\", \"+\"))\n                self.position += 1\n            \n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Parse the following number\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position += ",
          "time_taken": 225.4994580745697
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况，对于其他类型如 tuple, set 等，仅检查类型本身\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return ",
          "time_taken": 34.45988988876343
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['errors'] += 1\n            self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return result\n  ",
          "time_taken": 21.133908987045288
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\nFunc = Union[SyncFunc, AsyncFunc]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Func], Func]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Func) -> Func:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \n            Args:\n                *args: 函数参数\n                **kwargs: 函数关键字参数\n                \n            Returns:\n                函数执行结果\n                \n            Raises:\n                原始异常（如果重试失败）\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {type(e).__name__}: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {type(e).__name__}: {e}\")\n                        logger.info(f\"等待 {current_delay:.",
          "time_taken": 253.3237919807434
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 266.5666699409485
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 211, in <module>\n  File \"<string>\", line 183, in __exit__\n  File \"<string>\", line 145, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Union, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数值越小优先级越高\"\"\"\n        # Handle comparison with None (for shutdown signal)\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优雅关闭等操作。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        if max_workers is None:\n            import multiprocessing\n            max_workers = multiprocessing.cpu_count()\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._idle_workers = threading.Condition()\n        self._worker_count = 0\n        self._worker_count_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数位置参数\n            priority: 任务优先级，数值越小优先级越高（默认0）\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n  ",
          "time_taken": 212.06132888793945
        }
      ],
      "elapsed_seconds": 494.6
    },
    {
      "round": 146,
      "timestamp": 1771074841.55707,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 400.2
    },
    {
      "round": 147,
      "timestamp": 1771075167.223735,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 325.6
    },
    {
      "round": 148,
      "timestamp": 1771075630.4920058,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持任务提交、批量执行、优雅关闭等操作。\n    使用线程实现并发执行，支持任务超时和优先级。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 当任务池已关闭时抛出\n        \"\"\"\n        if not self._running:\n            raise RuntimeError(\"TaskPool已关闭，无法提交新任务\")\n        \n        task = Task(fn, args, kwargs, priority, timeout)\n        future = task.future\n        \n        # 将任务放入优先级队列\n        self._task_queue.put((priority, time.time(), task))\n        \n        return future\n    \n    def map(self, fn: Callable,",
          "time_taken": 285.0434181690216
        }
      ],
      "elapsed_seconds": 463.2
    },
    {
      "round": 149,
      "timestamp": 1771076039.802238,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 409.2
    },
    {
      "round": 150,
      "timestamp": 1771076442.526766,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算（索引为2）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 205.03360199928284
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度为 O(n log n)，空间复杂度为 O(n)。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通情况\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_arr}\")\n        # 验证原列表未被修改\n        assert test_case == original, \"原列表被修改了！\"\n        # 验证排序正确\n        assert sorted_arr == sorted(original), \"排",
          "time_taken": 217.85210299491882
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n                \n            if char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and",
          "time_taken": 150.3206946849823
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(",
          "time_taken": 94.51056599617004
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理。\n    \n    支持添加异步或同步阶段，记录每个阶段的执行统计信息。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_func = self.stages[stage_name]\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return result\n    \n    asyn",
          "time_taken": 81.95411610603333
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                    \n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                        raise\n                    \n                    logger.warning(\n                        f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试时失败: {e}，\"\n                        f\"将在 {current_delay:.2f} 秒后重试\"\n                    )\n                    \n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n                ",
          "time_taken": 179.08986496925354
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic functionality\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL functionality\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 194.18393993377686
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nimport heapq\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持任务提交、批量执行、优雅关闭等操作。\n    使用线程实现并发执行，支持任务超时和优先级。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._running = True\n        self._task_queue = queue.PriorityQueue()\n        self._worker_threads = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 当任务池已关闭时抛出\n        \"\"\"\n        if not self._running:\n            raise RuntimeError(\"TaskPool已关闭，无法提交新任务\")\n        \n        task = Task(fn, args, kwargs, priority, timeout)\n        future = task.future\n        \n        # 将任务放入优先级队列\n        # 使用时间戳确保相同优先级任务的执行顺序\n        self._task_queue.put((priority, time.time(), task))\n        \n        return future\n    \n    ",
          "time_taken": 132.32382202148438
        }
      ],
      "elapsed_seconds": 402.6
    },
    {
      "round": 151,
      "timestamp": 1771076959.951067,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列排序 - 优先级越小越高\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时和批量执行。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._tasks_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        self._worker_thread = threading.Thread(target=self._worker_loop, daemon=True)\n        self._worker_thread.start()\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数位置参数\n            priority: 任务优先级（数值越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"TaskPool has been shutdown\")\n        \n        task = Task(fn, args, kwargs, priority, timeout)\n        future = task.future\n        \n        # 将任务放入优先队列\n        self._tasks_queue.put((priority, task))\n        \n        return future\n    \n    def map(self, fn: Callable, iterable: Union[List, tuple, deque], priority: ",
          "time_taken": 274.75913405418396
        }
      ],
      "elapsed_seconds": 517.3
    },
    {
      "round": 152,
      "timestamp": 1771077102.906868,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nimport heapq\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持任务提交、批量执行、优雅关闭等操作。\n    使用线程实现并发执行，支持任务超时和优先级。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._running = True\n        self._task_queue = queue.PriorityQueue()\n        self._worker_threads = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 当任务池已关闭时抛出\n        \"\"\"\n        if not self._running:\n            raise RuntimeError(\"TaskPool已关闭，无法提交新任务\")\n        \n        task = Task(fn, args, kwargs, priority, timeout)\n        future = task.future\n        \n        # 将任务放入优先级队列\n        # 使用 (priority, submitted_time, task) 作为优先级键，确保相同优先级的任务按提交顺序执行\n        self._task_queue.put((priority, time.time(), task))",
          "time_taken": 24.60483407974243
        }
      ],
      "elapsed_seconds": 142.9
    },
    {
      "round": 153,
      "timestamp": 1771077183.17638,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom concurrent.futures import Future\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列排序\"\"\"\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    该类提供了一个线程池来执行并发任务，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL,\n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的位置参数\n            priori",
          "time_taken": 47.119789123535156
        }
      ],
      "elapsed_seconds": 80.2
    },
    {
      "round": 154,
      "timestamp": 1771077637.275255,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union, Iterator\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future, ThreadPoolExecutor\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数值越小优先级越高\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> result = future.result()\n        >>> print(result)  # 10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        self.max_workers = max_workers\n        self.executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        \n        # 用于存储任务的优先队列\n        self._task_queue = queue.PriorityQueue()\n        self._task_thread = threading.Thread(target=self._worker, daemon=True)\n        self._task_thread.start()\n        \n        logger.info(f\"TaskPool initialized with {max_workers} workers\")\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高，默认为0\n            timeout: 任务超时时间（秒），None表示无超时限制\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，可用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown",
          "time_taken": 303.2120158672333
        }
      ],
      "elapsed_seconds": 454.0
    },
    {
      "round": 155,
      "timestamp": 1771077957.1123111,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 非负整数，表示要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 处理特殊情况\n    if n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    \n    # 初始化结果列表\n    result = [0, 1]\n    \n    # 迭代计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 284.4489758014679
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，通过递归地将数组分成两半，分别排序后合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本，避免修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n        assert test_case == original, \"原列表被修改了！\"\n       ",
          "time_taken": 297.00769305229187
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including decimals)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            \n            elif char == '+':\n                self.tokens.append(Token(\"+\", \"+\"))\n                self.position += 1\n            \n            elif char == '-':\n                # Check if this is a negative number\n                if self.position == 0 or self.expression[self.position - 1] in \"(+-*/\":\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position += 1\n                    number_s",
          "time_taken": 238.50212717056274
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型（包括 Optional）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有指定元素类型，则只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有指定键值类型，则只检查是否为 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 被装饰的函数\n        \n    Returns:\n        带类型检查的包装函数\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名和参数绑定\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:",
          "time_taken": 192.464350938797
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom concurrent.futures import Future\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列排序，优先级高的排在前面\"\"\"\n        return self.priority.value > other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    该类提供了一个线程池来执行并发任务，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL,\n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的位置参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示不设置超时\n            **k",
          "time_taken": 219.79211401939392
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"异步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise  # 重新抛出原始异常\n                    \n                    logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                    logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                    \n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n                    \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"同步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_r",
          "time_taken": 259.8294858932495
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"one\")\n    cache.put(2, \"two\")\n    print(cache.get(1))  # Should return \"one\"\n    \n    cache.put(3, \"three\")  # This should evict key 2\n    print(cache.get(2))  # Should return None\n    \n    # Test TTL functionality\n    cache.put(4, \"four\", ttl=1)  # 1 second TTL\n    print(cache.get(4))  # Should return \"four\"\n    time.sleep(1.1)\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test LRU behavior\n    cache.put(5, \"five\")\n    cache.put(6, \"six\")\n    print(cache.get(5))  # Should return None (evicted due to LRU)\n    print(cache.get(6))  # Should return \"six\"\n",
          "time_taken": 274.45798921585083
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List\nfrom collections import defaultdict\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {'calls': 0, 'total_time': 0.0, 'errors': 0})\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # Re-raise the exception properly\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        \"\"\"\n   ",
          "time_taken": 178.05227971076965
        }
      ],
      "elapsed_seconds": 319.7
    },
    {
      "round": 156,
      "timestamp": 1771078083.7048168,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 1\n    NORMAL = 2\n    HIGH = 3\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        if self.priority == other.priority:\n            return id(self) < id(other)  # 相同优先级按提交顺序\n        return self.priority.value > other.priority.value  # 数值越大优先级越高\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供提交单个任务、批量执行、优雅关闭等功能\n    支持任务超时和优先级控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._task_queue = queue.PriorityQueue()\n        self._worker_threads: List[threading.Thread] = []\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown:\n            try:\n                # 使用超时机制避免永久阻塞\n                task = self._task_queue.get(timeout=1.0)\n                self._execute_task(task)\n                self._task_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception:\n                # 捕获异常避免工作线程崩溃\n                continue\n    \n",
          "time_taken": 31.40064001083374
        }
      ],
      "elapsed_seconds": 126.5
    },
    {
      "round": 157,
      "timestamp": 1771078484.064826,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 259, in <module>\n  File \"<string>\", line 49, in result\nconcurrent.futures._base.TimeoutError: Task not completed",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import deque\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(init=False)\n    \n    def __post_init__(self):\n        self.future = Future()\n\n\n@dataclass\nclass Future:\n    \"\"\"任务结果的未来对象\"\"\"\n    _done: bool = False\n    _result: Any = None\n    _exception: Optional[Exception] = None\n    _callbacks: List[Callable] = field(default_factory=list)\n    _lock: threading.Lock = field(default_factory=threading.Lock)\n    \n    def done(self) -> bool:\n        \"\"\"检查任务是否完成\"\"\"\n        with self._lock:\n            return self._done\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果\"\"\"\n        with self._lock:\n            if not self._done:\n                if timeout is None:\n                    # Wait indefinitely for the task to complete\n                    # This is a simplified approach - in practice you'd want to wait\n                    # with a proper synchronization mechanism\n                    raise concurrent.futures.TimeoutError(\"Task not completed\")\n                else:\n                    raise concurrent.futures.TimeoutError(\"Task not completed\")\n            \n            if self._exception:\n                raise self._exception\n                \n            return self._result\n    \n    def exception(self, timeout: Optional[float] = None) -> Optional[Exception]:\n        \"\"\"获取任务异常\"\"\"\n        with self._lock:\n            if not self._done:\n                if timeout is None:\n                    raise concurrent.futures.TimeoutError(\"Task not completed\")\n                else:\n                    raise concurrent.futures.TimeoutError(\"Task not completed\")\n            \n            return self._exception\n    \n    def add",
          "time_taken": 142.23726224899292
        }
      ],
      "elapsed_seconds": 400.3
    },
    {
      "round": 158,
      "timestamp": 1771078542.5374131,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport functools\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 1\n    NORMAL = 2\n    HIGH = 3\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submitted_time < other.submitted_time  # 相同优先级按提交时间\n        return self.priority.value > other.priority.value  # 数值越大优先级越高\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供提交单个任务、批量执行、优雅关闭等功能\n    支持任务超时和优先级控制\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._task_queue = queue.PriorityQueue()\n        self._worker_threads: List[threading.Thread] = []\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown:\n            try:\n           ",
          "time_taken": 37.89045023918152
        }
      ],
      "elapsed_seconds": 58.4
    },
    {
      "round": 159,
      "timestamp": 1771078679.829817,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        # Handle comparison with None (used for shutdown signals)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For comparison with non-Task objects (like None), treat as higher priority\n        return True\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭、超时控制和优先级调度。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        if self.max_workers is None:\n            # 如果没有指定线程数，使用默认的线程数\n            import os\n            self.max_workers = os.cpu_count() or 1\n            \n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从优先级队列中获取任务\n                task = self._task_queue.get(timeout=1)\n                if task i",
          "time_taken": 114.44020009040833
        }
      ],
      "elapsed_seconds": 137.2
    },
    {
      "round": 160,
      "timestamp": 1771078956.416866,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证高效性：大数值测试\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 126.75421476364136
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_arr}\")\n        # 验证原列表未被修改\n        assert test_case == original, \"原列表被修改了！\"\n        # 验证排序正确性\n        assert sorted_arr == sorted(original), \"排序结果不正确！\"\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 138.56159281730652
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        \"\"\"将表达式字符串转换为token列表\"\"\"\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # 解析数字（包括浮点数）\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n                \n            elif char in '+-*/()':\n                # 处理运算符和括号\n                if char == '-' and (self.position == 0 or \n                                   self.expression[self.position-1] in '(+-*/'):\n                    # 这是一个负号，需要和后面的数字合并\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token(\"NUMBER\", float(number_str)))\n          ",
          "time_taken": 80.15362620353699
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例使用\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, hobbies: list[str], info: dict[str, int]) -> str:\n        return f\"Name: {name}, Age:",
          "time_taken": 35.845298051834106
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数的指数退避重试机制。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避倍数\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.warning(\n                                f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                                f\"将在 {current_delay:.2f} 秒后重试...\"\n                            )\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.error(\n                                f\"函数 {func.__name__} 最终失败，已达到最大重试次数 {max_retries}: {e}\"\n                            )\n                            raise\n                raise last_exception  # 理论上不会执行到这里\n       ",
          "time_taken": 102.28550338745117
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage_name, result)\n        return result\n    \n    async def process_batch(self,",
          "time_taken": 22.4560866355896
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (still in cache)\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 116.77274894714355
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 65.58652210235596
        }
      ],
      "elapsed_seconds": 276.5
    },
    {
      "round": 161,
      "timestamp": 1771078976.959713,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 20.5
    },
    {
      "round": 162,
      "timestamp": 1771079001.863432,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 24.8
    },
    {
      "round": 163,
      "timestamp": 1771079170.874801,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 168.9
    },
    {
      "round": 164,
      "timestamp": 1771079298.603843,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 127.6
    },
    {
      "round": 165,
      "timestamp": 1771079989.3792489,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 462.90296602249146
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组递归地分成两半，\n    分别排序后合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的整数列表（升序）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的子数组\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试重复元素\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]\n    \n    # 测试负数\n    assert merge_sort([-3, -1, -4, -1, -5, -9, -2, -6]) == [-9, -6, -5, -4, -3, -2, -1, -1]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 475.43092584609985
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 152, in <module>\n  File \"<string>\", line 143, in evaluate\n  File \"<string>\", line 33, in tokenize\n  File \"<string>\", line 58, in _read_number\nValueError: could not convert string to float: ''",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative number\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        value = self.expression[start:self.pos]\n   ",
          "time_taken": 412.21959686279297
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        return isinstance(value, list) and all(_matches_type(v, args[0]) for v in value) if args else isinstance(value, list)\n    elif origin is dict:\n        return isinstance(value, dict) and all(_matches_type(k, args[0]) and _matches_type(v, args[1]) for k, v in value.items()) if args else isinstance(value, dict)\n    else:\n        # 兜底：如果是普通类型则检查类型，否则返回True\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, items: list[int], mapping: dict[str, int]) -> str:\n        return f\"x={x}, y={y}, items={items}, mapping={mapping}\"\n    \n    # 正确调用\n    try:\n        result = example_function(",
          "time_taken": 181.8776891231537
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    An asynchronous pipeline that processes data through a series of stages.\n    Each stage can be a regular function or an async function.\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        Add a stage to the pipeline.\n        \n        Args:\n            name: The name of the stage\n            fn: The function to execute for this stage\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"Function must be callable\")\n        self.stages[name] = fn\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        Process data through all stages in order.\n        \n        Args:\n            data: The input data to process\n            \n        Returns:\n            The processed data after all stages\n        \"\"\"\n        result = data\n        for stage_name, stage_func in self.stages.items():\n            start_time = time.time()\n            try:\n                if asyncio.iscoroutinefunction(stage_func):\n                    result = await stage_func(result)\n                else:\n                    result = stage_func(result)\n                self.stats_data[stage_name]['calls'] += 1\n                self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            except Exception as e:\n                self.stats_data[stage_name]['errors'] += 1\n                self.stats_data[stage_name]['calls'] += 1\n                self.stats_data[stage_name]['total_time'] += time.time() - start_time\n                raise  # Re-raise the exception to propagate it\n        return result\n    \n    async def process_batch(self, items: List[Any],",
          "time_taken": 169.0106270313263
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义异步和同步函数的类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\nFunc = Union[SyncFunc, AsyncFunc]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Func], Func]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子，每次重试延迟时间会乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Func) -> Func:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试失败: {e}\")\n                        logger.info(f\"等待 {current_delay:.2f} 秒后进行下次重试...\")\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n            \n            # 理论上不会执行到这里\n            raise RuntimeError(\"重试逻辑异常\")\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            同步函数包装器\n            \"\"\"\n            current_delay",
          "time_taken": 438.4709451198578
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 452.4610800743103
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future, ThreadPoolExecutor\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n\n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭、超时控制和优先级调度。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count()\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数值越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n        \"\"\"\n        if not self._running:\n            raise RuntimeError(\"TaskPool已关闭，无法提交新任务\")\n            \n        task = Task(fn, args, kwargs, priority, timeout)\n        future = task.future\n        \n        # 更新任务提交时间\n        task.submitted_time = time.time()\n        \n        # 将任务放入",
          "time_taken": 454.58450198173523
        }
      ],
      "elapsed_seconds": 690.6
    },
    {
      "round": 166,
      "timestamp": 1771080537.000299,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        \"\"\"将表达式字符串转换为token列表\"\"\"\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # 解析数字（包括浮点数）\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n                \n            elif char in '+-*/()':\n                # 处理运算符和括号\n                if char == '-' and (self.position == 0 or \n                                   self.expression[self.position-1] in '(+-*/'):\n                    # 这是一个负号，需要和后面的数字合并\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token(\"NUMBER\", float(number_str)))\n          ",
          "time_taken": 212.9220950603485
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=lambda: time.time())\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n         ",
          "time_taken": 255.04763078689575
        }
      ],
      "elapsed_seconds": 547.5
    },
    {
      "round": 167,
      "timestamp": 1771081114.453516,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[s",
          "time_taken": 271.6077311038971
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor, TimeoutError\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=lambda: time.time())  # Fixed: correct default factory\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n       ",
          "time_taken": 312.8013288974762
        }
      ],
      "elapsed_seconds": 577.3
    },
    {
      "round": 168,
      "timestamp": 1771081338.769453,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\nimport re\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token('NUMBER', float(number_str)))\n                else:\n                    self.tokens.",
          "time_taken": 60.13511300086975
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 100.36456608772278
        }
      ],
      "elapsed_seconds": 224.2
    },
    {
      "round": 169,
      "timestamp": 1771082015.1986802,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)  # Fixed: was time.time (function) instead of time.time() (call)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n",
          "time_taken": 311.73993611335754
        }
      ],
      "elapsed_seconds": 676.3
    },
    {
      "round": 170,
      "timestamp": 1771082577.0756779,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 避免指数级递归，时间复杂度O(n)，空间复杂度O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证边界情况\n    print(f\"fibonacci(-1) = {fibonacci(-1)}\")  # []\n    print(f\"fibonacci(15) = {fibonacci(15)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n",
          "time_taken": 359.80762696266174
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度为 O(n log n)，空间复杂度为 O(n)。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理空列表和单元素列表的情况\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序后:   {sorted_arr}\")\n        print(f\"  原列表不变: {test_case == original}\")\n        print()\n",
          "time_taken": 371.11615896224976
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                self.tokens.append(Token('MINUS', '-'))\n                self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        value = float(self.expression[start:self.pos])\n        self.tokens.append(Token('NUMBER', value))\n\nclass Parser:\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.pos = 0\n    \n    de",
          "time_taken": 304.62729001045227
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, items: list[int], mapping: dict[str, int]) -> str:\n        return f\"{x}: {y}: {",
          "time_taken": 97.91895008087158
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 160, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/runners.py\", line 44, in run\n    return loop.run_until_complete(main)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py\", line 642, in run_until_complete\n    return future.result()\n  File \"<string>\", line 77, in process\n  File \"<string>\", line 51, in _process_single_stage\n  File \"<string>\", line 150, in stage3_error\nValueError: Data too large",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List\nfrom collections import defaultdict\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self._stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self._stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            self._stats[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._process_single_stage(stage_name, result)\n        return result\n    \n",
          "time_taken": 85.26934123039246
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\nFunc = Union[SyncFunc, AsyncFunc]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Func], Func]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子(指数退避)\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Func) -> Func:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"\n            异步函数包装器\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                        logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                except Exception as e:\n                    # 如果是不支持的异常类型，直接抛出\n                    logger.error(f\"函数 {func.__name__} 遇到不支持的异常类型: {type(e).__name__}: {e}\")\n                    raise\n            \n            # 理论上不会执行到这里\n            raise RuntimeError(\"Unexpected",
          "time_taken": 332.11852526664734
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\"\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 348.07362699508667
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=lambda: time.time())\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n         ",
          "time_taken": 346.4108190536499
        }
      ],
      "elapsed_seconds": 561.7
    },
    {
      "round": 171,
      "timestamp": 1771082959.668017,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 102, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/runners.py\", line 44, in run\n    return loop.run_until_complete(main)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py\", line 642, in run_until_complete\n    return future.result()\n  File \"<string>\", line 94, in test\nAttributeError: 'AsyncPipeline' object has no attribute 'process_batch'",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\n\nclass AsyncPipeline:\n    \"\"\"\n    An asynchronous pipeline that processes data through a series of stages.\n    Each stage can be a regular function or an async function.\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {'calls': 0, 'total_time': 0.0, 'errors': 0})\n    \n    def add_stage(self, name: str, func: Callable):\n        \"\"\"Add a stage to the pipeline.\"\"\"\n        self.stages[name] = func\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"Process data through all stages.\"\"\"\n        for stage_name, stage_func in self.stages.items():\n            start_time = time.time()\n            try:\n                if asyncio.iscoroutinefunction(stage_func):\n                    data = await stage_func(data)\n                else:\n                    data = stage_func(data)\n                # Success case\n                self.stats_data[stage_name]['calls'] += 1\n                self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            except Exception as e:\n                # Exception case\n                self.stats_data[stage_name]['calls'] += 1\n                self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n                self.stats_data[stage_name]['errors'] += 1\n                raise  # Re-raise the exception\n        return data\n    \n    def get_stats(self) -> Dict:\n        \"\"\"Get pipeline statistics.\"\"\"\n        # Convert defaultdict to regular dict for clean output\n        return {k: dict(v) for k, v in self.stats_data.items()}\n\n# Test functions\nasync def stage1(data):\n    return data * 2\n\ndef stage2(data):\n    return data + 1\n\nasync def stage3(data):\n    if data > 10:\n        raise ValueError(\"Too large\")\n    return data * 3\n\n# Example usage and testing\nasync def main():\n    # Create pipeline\n    pipeline = AsyncPip",
          "time_taken": 115.73392176628113
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 202.4810507297516
        }
      ],
      "elapsed_seconds": 382.4
    },
    {
      "round": 172,
      "timestamp": 1771083411.265742,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    An asynchronous pipeline that processes data through a series of stages.\n    Each stage can be a regular function or an async function.\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        Add a stage to the pipeline.\n        \n        Args:\n            name: The name of the stage\n            fn: The function to execute for this stage\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"Function must be callable\")\n        self.stages[name] = fn\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        Process data through all stages in order.\n        \n        Args:\n            data: The input data to process\n            \n        Returns:\n            The processed data after all stages\n        \"\"\"\n        result = data\n        for stage_name, stage_func in self.stages.items():\n            start_time = time.perf_counter()\n            try:\n                if asyncio.iscoroutinefunction(stage_func):\n                    result = await stage_func(result)\n                else:\n                    result = stage_func(result)\n                self.stats_data[stage_name]['calls'] += 1\n                self.stats_data[stage_name]['total_time'] += time.perf_counter() - start_time\n            except Exception as e:\n                self.stats_data[stage_name]['errors'] += 1\n                self.stats_data[stage_name]['calls'] += 1\n                self.stats_data[stage_name]['total_time'] += time.perf_counter() - start_time\n                raise  # Re-raise the exception to propagate it\n        return result\n    \n    async def process_batch",
          "time_taken": 20.379910230636597
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass, field\nimport threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=lambda: time.time())\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n         ",
          "time_taken": 259.8368639945984
        }
      ],
      "elapsed_seconds": 451.5
    },
    {
      "round": 173,
      "timestamp": 1771083669.675485,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的最终数据\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n  ",
          "time_taken": 22.284070014953613
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 118.15734314918518
        }
      ],
      "elapsed_seconds": 258.3
    },
    {
      "round": 174,
      "timestamp": 1771083947.546438,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self._stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self._stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功统计\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            self._stats[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._process_single_stage(stage_name, result)\n        re",
          "time_taken": 20.641350030899048
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 101.57599902153015
        }
      ],
      "elapsed_seconds": 277.7
    },
    {
      "round": 175,
      "timestamp": 1771084443.5112681,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 测试负数情况\n    print(f\"fibonacci(-1) = {fibonacci(-1)}\")  # []\n",
          "time_taken": 323.0248489379883
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组分成两半，\n    递归地对两半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 2, 8, 1],          # 小列表\n        [1, 1, 1, 1],          # 重复元素\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5]        # 已排序列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_arr}\")\n        # 验证原列表未被修改\n        ass",
          "time_taken": 336.3232319355011
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 273.3743441104889
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"\n    检查值是否匹配指定的类型。\n    \n    Args:\n        value: 要检查的值\n        expected_type: 期望的类型\n        \n    Returns:\n        bool: 如果值匹配类型则返回True，否则返回False\n    \"\"\"\n    # 处理None类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型检查\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取类型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理Union类型（如 Optional[X] 等价于 Union[X, None]）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理list类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果有参数类型，检查每个元素\n        if args:\n            return all(_matches_type(v, args[0]) for v in value)\n        else:\n            # 没有参数类型，只检查是否为list\n            return isinstance(value, list)\n    \n    # 处理dict类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果有参数类型，检查键值对\n        if args:\n            return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                      for k, v in value.items())\n        else:\n            # 没有参数类型，只检查是否为dict\n            return isinstance(value, dict)\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器。\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hint",
          "time_taken": 41.56748294830322
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        retur",
          "time_taken": 21.276751279830933
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\nfrom typing_extensions import Awaitable\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\nU = TypeVar('U')\n\n# 定义异步和同步函数的类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Awaitable[T]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 指数退避因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.warning(\n                                f\"函数 {func.__name__} 执行失败 (attempt {attempt + 1}/{max_retries + 1}): {e}. \"\n                                f\"将在 {current_delay:.2f} 秒后重试...\"\n                            )\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.error(\n                                f\"函数 {func.__name__} 最终失败 (attempt {attempt + 1}/{max_retries + 1}): {e}\"\n                            )\n   ",
          "time_taken": 299.55241990089417
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None due to expiration\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 312.70985198020935
        }
      ],
      "elapsed_seconds": 495.8
    },
    {
      "round": 176,
      "timestamp": 1771084791.699476,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 86.03854012489319
        }
      ],
      "elapsed_seconds": 348.0
    },
    {
      "round": 177,
      "timestamp": 1771085145.698228,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor, TimeoutError\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.monotonic)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n",
          "time_taken": 200.3285150527954
        }
      ],
      "elapsed_seconds": 353.9
    },
    {
      "round": 178,
      "timestamp": 1771085391.8126569,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 259, in <module>\n  File \"<string>\", line 247, in __exit__\n  File \"<string>\", line 228, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import wraps\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        # Handle case where other is None (shutdown signal)\n        if other is None:\n            return False  # None should not be prioritized\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented  # Let Python handle comparison with other types\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 任务超时控制\n    - 任务优先级\n    - 多线程执行\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._work_queue = queue.PriorityQueue()\n        self._threads: List[threading.Thread] = []\n        self._running = True\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.append(thread)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while self._running:\n            try:\n                # 从队列获取任务，超时时间设为1秒，避免长时间阻塞\n ",
          "time_taken": 131.9049642086029
        }
      ],
      "elapsed_seconds": 246.0
    },
    {
      "round": 179,
      "timestamp": 1771085809.324039,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 265.81557607650757
        }
      ],
      "elapsed_seconds": 417.4
    },
    {
      "round": 180,
      "timestamp": 1771086488.309389,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 350.9223790168762
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种基于分治思想的稳定排序算法。它将数组递归地分成两半，\n    分别排序后合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {test_case} -> {result}\")\n    \n    # 验证原列表不变\n    original = [3, 1, 4, 1, 5]\n    result = merge_sort(original)\n    print(f\"原列表: {original}",
          "time_taken": 366.1673581600189
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 199, in <module>\nAssertionError",
          "code_generated": "from typing import List, Union\nimport re\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type_: TokenType, value: Union[float, str]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return \"\"\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return \"\"\n    \n    def skip_whitespace(self):\n        while self.peek().isspace():\n            self.advance()\n    \n    def parse_number(self) -> Token:\n        start = self.position\n        while self.peek() and (self.peek().isdigit() or self.peek() == '.'):\n            self.advance()\n        value = self.expression[start:self.position]\n        return Token(TokenType.NUMBER, float(value))\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        tokens = []\n        \n        while self.position < len(self.expression):\n            self.skip_whitespace()\n            \n            if self.peek() == '':\n                break\n                \n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                tokens.append(self.parse_number())\n            elif char == '+':\n                tokens.append(Token(TokenType.PLUS, char))\n                self.advance()\n            elif char == '-':\n                # Check if this is a negative number\n                if self.position == 0 or self.expression[",
          "time_taken": 304.10975098609924
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    # 测试普通类型\n    @type_check\n    def add(a: int, b: int) -> int:\n        return a + b\n    \n    print(add(1, 2))  # 正常运行\n    \n    # 测试列表类",
          "time_taken": 36.486897230148315
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.warning(\n                                f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}. \"\n                                f\"将在 {current_delay:.2f} 秒后重试...\"\n                            )\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.error(\n                                f\"函数 {func.__name__} 最终失败，已达到最大重试次数 {max_retries}\"\n                            )\n                            raise\n                raise last_exception  # 理论上不会执行到这里\n            \n            r",
          "time_taken": 326.39560294151306
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_func = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的最终数据\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n  ",
          "time_taken": 23.113893032073975
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 341.0168790817261
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=lambda: time.time())\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n         ",
          "time_taken": 342.315966129303
        }
      ],
      "elapsed_seconds": 678.8
    },
    {
      "round": 181,
      "timestamp": 1771087057.349705,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 158, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 235.9787631034851
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)  # Fixed: was time.time (function) instead of time.time() (function call)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        ",
          "time_taken": 276.27464485168457
        }
      ],
      "elapsed_seconds": 568.9
    },
    {
      "round": 182,
      "timestamp": 1771087499.881419,
      "passed": 6,
      "total": 8,
      "avg_score": 6.94,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 150, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 234.3299400806427
        }
      ],
      "elapsed_seconds": 442.4
    },
    {
      "round": 183,
      "timestamp": 1771088000.669128,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 157, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 260.12555408477783
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=lambda: time.time())\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n         ",
          "time_taken": 300.06896114349365
        }
      ],
      "elapsed_seconds": 500.6
    },
    {
      "round": 184,
      "timestamp": 1771088551.71789,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 158, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 244.61028480529785
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=lambda: time.time())\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n         ",
          "time_taken": 286.29782795906067
        }
      ],
      "elapsed_seconds": 550.9
    },
    {
      "round": 185,
      "timestamp": 1771089084.388155,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能\n    import time\n    start = time.time()\n    result = fibonacci(1000)\n    end = time.time()\n    print(f\"fibonacci(1000) 长度: {len(result)}, 耗时: {end - start:.6f}秒\")\n",
          "time_taken": 301.19992995262146
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组递归地分成两半，\n    分别排序后再合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # 递归排序左右两部分\n    sorted_left = merge_sort(left)\n    sorted_right = merge_sort(right)\n    \n    # 合并两个已排序的数组\n    return _merge(sorted_left, sorted_right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素加入结果列表\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素加入结果列表\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 313.6128959655762
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 160, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 252.61580324172974
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 9, in <module>\nNameError: name 'Enum' is not defined",
          "code_generated": "from dataclasses import dataclass, field\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nimport threading\nimport time\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"可复用的任务池\"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"初始化任务池\"\"\"\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"提交任务到任务池\"\"\"\n        if not self._running:\n            raise RuntimeError(\"TaskPool has been shutdown\")\n            \n        task = Task(\n            func=fn,\n            args=args,\n            kwargs=kwargs,\n            priority=priority,\n            timeout=timeout\n        )\n        \n        # 将任务放入队列\n        self._task_queue.put(task)\n        \n        return task.future\n    \n    def map(self, fn: Callable, iterable: Iterator) -> List[Any]:\n        \"\"\"批量执行任务\"\"\"\n        futures = []\n        for item in iterable:\n       ",
          "time_taken": 233.37668991088867
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"\n    检查值是否匹配期望的类型。\n    \n    Args:\n        value: 要检查的值\n        expected_type: 期望的类型\n        \n    Returns:\n        bool: 如果值匹配类型返回True，否则返回False\n    \"\"\"\n    # 处理None类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # Union类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:  # 空列表\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:  # 空字典\n            return True\n        # 检查键值对类型\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) for k, v in value.items())\n    \n    # 兜底处理\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器。\n    \n    Args:\n        func: 被装饰的函数\n        \n    Returns:\n        装饰后的函数，会进行运行时类型检查\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n",
          "time_taken": 36.73418402671814
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.warning(\n                                f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}. \"\n                                f\"将在 {current_delay:.2f} 秒后重试...\"\n                            )\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.error(\n                                f\"函数 {func.__name__} 最终失败: {e}. \"\n                    ",
          "time_taken": 275.50231194496155
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self._stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_func = self._stages[stage_name]\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 更新统计信息\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计信息\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            self._stats[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._execute_stage(stage_name, result)\n        return result\n    \n   ",
          "time_taken": 21.604593753814697
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 290.0710959434509
        }
      ],
      "elapsed_seconds": 532.5
    },
    {
      "round": 186,
      "timestamp": 1771089350.5081239,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 150, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 61.92752695083618
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 103.27780294418335
        }
      ],
      "elapsed_seconds": 266.0
    },
    {
      "round": 187,
      "timestamp": 1771089586.120887,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 161, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 47.35199213027954
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 31.697768211364746
        }
      ],
      "elapsed_seconds": 235.5
    },
    {
      "round": 188,
      "timestamp": 1771090054.813361,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 156, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 185.38340497016907
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        # 优先级越小越先执行\n        # 如果优先级相同，比较提交时间\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池，使用线程实现\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 指定最大工作线程数\n    - 任务超时控制\n    - 任务优先级控制\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为CPU核心数\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._work_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._idle_semaphore = threading.Semaphore(0)\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while True:\n            try:\n                # 从队列获取任务\n                task = self._work_queue.get(timeout=1)\n                if task is None:  # 收到关闭信号\n                    break\n                \n                # 执行任务\n                try:\n                    result = task.fn(*task.args, **task.kwargs)\n                    task.future.set_result(result)\n                except Exception as e:\n               ",
          "time_taken": 226.5169539451599
        }
      ],
      "elapsed_seconds": 468.5
    },
    {
      "round": 189,
      "timestamp": 1771090509.100766,
      "passed": 6,
      "total": 8,
      "avg_score": 6.94,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 161, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 304.0829041004181
        }
      ],
      "elapsed_seconds": 454.1
    },
    {
      "round": 190,
      "timestamp": 1771091148.1012459,
      "passed": 6,
      "total": 8,
      "avg_score": 7.75,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 处理n=1的特殊情况\n    if n == 1:\n        return [0]\n    \n    # 初始化结果列表\n    result = [0, 1]\n    \n    # 使用迭代方式计算斐波那契数列，时间复杂度O(n)，空间复杂度O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    print(f\"fibonacci(-1) = {fibonacci(-1)}\")  # []\n",
          "time_taken": 304.56519317626953
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素并合并\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 小列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_arr}\")\n        # 验证原列表未被修改\n        assert test_case =",
          "time_taken": 317.66961193084717
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 147, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 256.36994981765747
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"\n    检查值是否匹配期望的类型。\n    \n    Args:\n        value: 要检查的值\n        expected_type: 期望的类型\n        \n    Returns:\n        bool: 如果值匹配类型返回True，否则返回False\n    \"\"\"\n    # 处理None类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型的原始类型（如 list, dict, Union 等）\n    origin = typing.get_origin(expected_type)\n    \n    # 如果没有原始类型（普通类型如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（如 Optional[X] 等价于 Union[X, None]）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数（如 list），只需检查是否为list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数（如 dict），只需检查是否为dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器。\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名并绑定参数\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查每个参数的类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(val",
          "time_taken": 39.257970094680786
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间会乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        通用装饰器函数，支持同步和异步函数\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.warning(\n                                f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries}): {e}. \"\n                                f\"将在 {current_delay:.2f} 秒后重试...\"\n                            )\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.error(\n                                f\"函数 {func.__name__} 最终失败",
          "time_taken": 278.70215225219727
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Union\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return r",
          "time_taken": 22.549504041671753
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        \"\"\"\n        初始化LRU缓存\n        \n        Args:\n            capacity: 缓存的最大容量\n        \"\"\"\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        \"\"\"\n        获取缓存中的值\n        \n        Args:\n            key: 要获取的键\n            \n        Returns:\n            如果键存在且未过期，返回对应的值；否则返回None\n        \"\"\"\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        \"\"\"\n        向缓存中添加或更新键值对\n        \n        Args:\n            key: 要添加或更新的键\n            value: 要存储的值\n            ttl: 过期时间（秒），如果为None则永不过期\n        \"\"\"\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为2的LRU缓存\n    cache = LRUCache(2)\n    \n    # 测试基本功能\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # 应该输出 1\n    \n    # 测试容量限制\n    cache.put(\"c\", 3)  # 这会移除最久未使用的项\"a\"\n    print(cache.get(\"a\"))  # 应该输出 None\n    print(cache.get(\"b\"))  # 应该输出 2\n    print(cache.get(\"c\"))  # 应该输出 3\n    \n    # 测试TTL功能\n    cache.put(\"d\", 4, ttl=1)  # 1秒后过期\n    print(cache.get(\"d\"))  # 应该输出 4\n    time.sleep(1.1)  # 等待过期\n    print(cache.get(\"d\"))  # 应该输出 None\n    \n    # 测试线程安全\n    import concurrent.futures\n    \n    def test_concurrent():\n        for i in range(100):\n          ",
          "time_taken": 294.31257009506226
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass, field\nfrom enum import Enum\nimport threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)  # Fixed: removed parentheses\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            ",
          "time_taken": 297.7934308052063
        }
      ],
      "elapsed_seconds": 638.9
    },
    {
      "round": 191,
      "timestamp": 1771091467.474337,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 167, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 72.03021192550659
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 111.20137596130371
        }
      ],
      "elapsed_seconds": 319.2
    },
    {
      "round": 192,
      "timestamp": 1771091933.433123,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 160, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 232.40257787704468
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass, field\nimport threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)  # Fixed: removed parentheses\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            ",
          "time_taken": 273.15339279174805
        }
      ],
      "elapsed_seconds": 465.8
    },
    {
      "round": 193,
      "timestamp": 1771092356.6529741,
      "passed": 6,
      "total": 8,
      "avg_score": 6.94,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 166, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 239.25137591362
        }
      ],
      "elapsed_seconds": 423.1
    },
    {
      "round": 194,
      "timestamp": 1771092932.209476,
      "passed": 6,
      "total": 8,
      "avg_score": 6.94,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 157, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 260.25938606262207
        }
      ],
      "elapsed_seconds": 575.4
    },
    {
      "round": 195,
      "timestamp": 1771093465.357313,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 时间复杂度：O(n)，空间复杂度：O(1)（不包括结果列表）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 238.47697615623474
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理空列表和单元素列表的边界情况\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [1, 1, 1, 1],          # 重复元素\n        [-3, -1, -4, -1, -5]   # 负数列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {test_case} -> {sorted_result}\")\n        \n        # 验证原列表未被修改\n        print(f\"原列表未变: {test_case}\")\n        print()\n",
          "time_taken": 250.58591413497925
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 148, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 190.90177297592163
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        return isinstance(value, list) and all(_matches_type(v, args[0]) for v in value) if args else isinstance(value, list)\n    elif origin is dict:\n        return isinstance(value, dict) and all(_matches_type(k, args[0]) and _matches_type(v, args[1]) for k, v in value.items()) if args else isinstance(value, dict)\n    else:\n        # 兜底：对于其他类型，如果expected_type是type则检查类型，否则返回True\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, hobbies: list[str], info: dict[str, int]) -> str:\n        return f\"Name: {name}, Age: {age}, Hobbies: {hobbies}, Info: {info}\"\n    \n    # 正确的调用\n    try:\n ",
          "time_taken": 143.63833093643188
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 167, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/runners.py\", line 44, in run\n    return loop.run_until_complete(main)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py\", line 642, in run_until_complete\n    return future.result()\n  File \"<string>\", line 139, in example_usage\n  File \"<string>\", line 73, in process\n  File \"<string>\", line 49, in _process_single_stage\n  File \"<string>\", line 128, in async_stage3\nValueError: 数据过大",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurre",
          "time_taken": 131.3847668170929
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\n# 定义装饰器参数类型\nRetryConfig = Tuple[int, float, float, Tuple[Type[Exception], ...]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (attempt {attempt + 1}/{max_retries + 1}): {e}\"\n                        )\n                        logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise\n                except Exception as e:\n                    # 如果不是指定要重试的异常类型，则直接抛出\n                    raise e\n            \n            raise last_exception or RuntimeError(\"未知错误\")\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            ",
          "time_taken": 213.3702688217163
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    \n    # Test updating existing key\n    cache.put(\"a\", 5)\n    print(cache.get(\"a\"))  # Should return 5\n",
          "time_taken": 228.03342485427856
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 175.89040899276733
        }
      ],
      "elapsed_seconds": 533.0
    },
    {
      "round": 196,
      "timestamp": 1771093851.031956,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 157, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 150.9239411354065
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 218, in <module>\n  File \"<string>\", line 178, in __exit__\n  File \"<string>\", line 161, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterable, Union\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务数据类，支持优先级比较\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        elif other is None:\n            # When comparing with None, return NotImplemented\n            # This prevents the queue from trying to compare None with None\n            return NotImplemented\n        return NotImplemented\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池，基于线程实现\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 超时控制\n    - 优先级调度\n    \"\"\"\n    \n    def __init__(self, max_workers: int = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为CPU核心数\n        \"\"\"\n        if max_workers is None:\n            import multiprocessing\n            max_workers = multiprocessing.cpu_count()\n        \n        self.max_workers = max_workers\n        self._work_queue = queue.PriorityQueue()\n        self._threads: List[threading.Thread] = []\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.append(thread)\n    \n    def _worker(self):\n        \"\"\"工作线程执行函数\"\"\"\n        while True:\n            try:\n                # 从优先级队列获取任务\n                task = self._work_queue.get(timeout=1)\n                if task is None:  # 退出信号\n                    break\n                \n                # 执行",
          "time_taken": 132.17018961906433
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.perf_counter()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.perf_counter() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.perf_counter() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n     ",
          "time_taken": 23.08057403564453
        }
      ],
      "elapsed_seconds": 385.5
    },
    {
      "round": 197,
      "timestamp": 1771094315.693506,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 163, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 261.5361511707306
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Union\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息。\n        \n        Args:\n            name: 阶段名称\n            fn: 阶段函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[name]['calls'] += 1\n            self.stats_data[name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[name]['calls'] += 1\n            self.stats_data[name]['total_time'] += (time.time() - start_time)\n            self.stats_data[name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for name, fn in self.stages.items():\n            result = await self._process_single_stage(name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        \"\"\"\n ",
          "time_taken": 23.721555948257446
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 302.4389009475708
        }
      ],
      "elapsed_seconds": 464.5
    },
    {
      "round": 198,
      "timestamp": 1771094706.5539682,
      "passed": 6,
      "total": 8,
      "avg_score": 7.0,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 150, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 242.7583999633789
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Union\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return",
          "time_taken": 25.521907091140747
        }
      ],
      "elapsed_seconds": 390.7
    },
    {
      "round": 199,
      "timestamp": 1771095143.3526452,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 148, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 42.63868308067322
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 84.85996580123901
        }
      ],
      "elapsed_seconds": 436.6
    },
    {
      "round": 200,
      "timestamp": 1771095745.586462,
      "passed": 6,
      "total": 8,
      "avg_score": 7.75,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算剩余的数，避免指数级递归\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能（大数测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 298.87852692604065
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n        ",
          "time_taken": 312.17670011520386
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 150, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 248.41602396965027
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                   for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, items: list) -> dict:\n        return {\"count\": x, \"name\": y, \"values\": items}",
          "time_taken": 34.97992777824402
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序处理和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self._stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self._stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self._stats[stage_name]['calls'] += 1\n            self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            self._stats[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序处理所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._process_single_stage(stage_name, result)\n  ",
          "time_taken": 21.668817043304443
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        \"\"\"\n        初始化LRU缓存\n        \n        Args:\n            capacity: 缓存的最大容量\n        \"\"\"\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        \"\"\"\n        获取缓存中的值\n        \n        Args:\n            key: 要获取的键\n            \n        Returns:\n            如果键存在且未过期，返回对应的值；否则返回None\n        \"\"\"\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        \"\"\"\n        向缓存中添加或更新键值对\n        \n        Args:\n            key: 要添加或更新的键\n            value: 要添加或更新的值\n            ttl: 过期时间（秒），如果为None则永不过期\n        \"\"\"\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为2的LRU缓存\n    cache = LRUCache(2)\n    \n    # 测试基本功能\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # 应该输出 1\n    \n    # 测试容量限制\n    cache.put(\"c\", 3)  # 这会淘汰最久未使用的项\"a\"\n    print(cache.get(\"a\"))  # 应该输出 None\n    print(cache.get(\"b\"))  # 应该输出 2\n    print(cache.get(\"c\"))  # 应该输出 3\n    \n    # 测试TTL功能\n    cache.put(\"d\", 4, ttl=1)  # 1秒后过期\n    print(cache.get(\"d\"))  # 应该输出 4\n    time.sleep(1.1)  # 等待1.1秒让其过期\n    print(cache.get(\"d\"))  # 应该输出 None\n    \n    # 测试更新操作\n    cache.put(\"e\", 5)\n    cache.put(\"f\", 6)\n    cache.put(\"e\", 7)  # 更新已存在的键\n    print(cache",
          "time_taken": 288.49676489830017
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子，每次重试延迟时间会乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"异步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试失败: {e}\")\n                        logger.info(f\"等待 {current_delay:.2f} 秒后进行下次重试...\")\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                except Exception as e:\n                    # 如果遇到未指定的异常类型，直接抛出\n                    logger.error(f\"函数 {func.__name__} 遇到未配置重试的异常: {e}\")\n                    raise\n            \n            # 理论上不会执行到这里\n            raise",
          "time_taken": 273.7896418571472
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass, field\nimport threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=lambda: time.time())\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n         ",
          "time_taken": 290.1818017959595
        }
      ],
      "elapsed_seconds": 602.1
    },
    {
      "round": 201,
      "timestamp": 1771096305.119742,
      "passed": 6,
      "total": 8,
      "avg_score": 6.94,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 157, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 219.94679498672485
        }
      ],
      "elapsed_seconds": 559.4
    },
    {
      "round": 202,
      "timestamp": 1771096768.6403542,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 148, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 234.41750311851501
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)  # Fixed: removed parentheses\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            ",
          "time_taken": 276.7526309490204
        }
      ],
      "elapsed_seconds": 463.4
    },
    {
      "round": 203,
      "timestamp": 1771097279.389073,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 161, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 211.52814483642578
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass, field\nimport threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 253.3217170238495
        }
      ],
      "elapsed_seconds": 510.6
    },
    {
      "round": 204,
      "timestamp": 1771098039.2545989,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 147, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 243.97698521614075
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor, TimeoutError\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=lambda: time.time())\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执",
          "time_taken": 286.1687800884247
        }
      ],
      "elapsed_seconds": 759.7
    },
    {
      "round": 205,
      "timestamp": 1771098697.655499,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算剩余的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 382.3105540275574
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组递归地分成两半，\n    分别排序后，再将两个已排序的子数组合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # 递归排序左右两部分\n    sorted_left = merge_sort(left)\n    sorted_right = merge_sort(right)\n    \n    # 合并两个已排序的列表\n    return _merge(sorted_left, sorted_right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 已排序的左列表\n        right: 已排序的右列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([5, 2, 8, 2, 1]) == [1, 2, 2, 5, 8]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 394.85508608818054
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 160, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 338.49395394325256
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    \n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, scores: list[int], info: dict[str, int]) -> str:\n        return f\"{name} ",
          "time_taken": 65.45961999893188
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}\"\n                        )\n                        logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise\n            raise last_exception  # 这行代码实际上不会执行到\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                exc",
          "time_taken": 361.375608921051
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return ",
          "time_taken": 24.818257093429565
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 372.642235994339
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 380.1065409183502
        }
      ],
      "elapsed_seconds": 658.2
    },
    {
      "round": 206,
      "timestamp": 1771099103.1441321,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 150, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 222.1133668422699
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass, field\nimport threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=lambda: time.time())\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n         ",
          "time_taken": 263.1232120990753
        }
      ],
      "elapsed_seconds": 405.4
    },
    {
      "round": 207,
      "timestamp": 1771099497.2249222,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 148, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 46.19714307785034
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制和批量执行。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> print(future.result())\n        10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: ",
          "time_taken": 32.600831031799316
        }
      ],
      "elapsed_seconds": 393.9
    },
    {
      "round": 208,
      "timestamp": 1771100018.420317,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 155, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 240.4253010749817
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import deque\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable[..., Any]\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量任务执行、任务超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._running = True\n        self._lock = threading.Lock()\n        self._worker_threads: List[threading.Thread] = []\n        self._initialize_workers()\n        \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for i in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n            \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while self._running:\n            try:\n                # 使用超时机制，避免无限等待\n                priority, timestamp, task = self._task_queue.get(timeout=1.0)\n                self._execute_task(task)\n                self._task_queue.task_done()\n            except queue.Empty:\n                conti",
          "time_taken": 229.92623114585876
        }
      ],
      "elapsed_seconds": 521.0
    },
    {
      "round": 209,
      "timestamp": 1771100182.660352,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 153, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 50.33360290527344
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Any, Callable, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(init=False)\n    \n    def __post_init__(self):\n        self.future = Future()\n\n@dataclass\nclass Future:\n    \"\"\"Future对象，用于获取任务结果\"\"\"\n    _result: Any = None\n    _exception: Optional[Exception] = None\n    _done: bool = False\n    _cancelled: bool = False\n    _callbacks: List[Callable] = field(default_factory=list)\n    _condition: threading.Condition = field(default_factory=threading.Condition)\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果\"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise concurrent.futures.TimeoutError()\n            if self._exception:\n                raise self._exception\n            return self._result\n    \n    def exception(self, timeout: Optional[float] = None) -> Optional[Exception]:\n        \"\"\"获取任务异常\"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise concurrent.futures.TimeoutError()\n            return self._exception\n    \n    def done(self) -> bool:\n        \"\"\"检查任务是否完成\"\"\"\n        with self._condition:\n            return self._done\n    \n    def cancelled(self) -> bool:\n        \"\"\"检查任务是否被取消\"\"\"\n        with self._condition:\n            return self._cancelled\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        w",
          "time_taken": 34.80997180938721
        }
      ],
      "elapsed_seconds": 164.1
    },
    {
      "round": 210,
      "timestamp": 1771100614.232843,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证边界条件\n    print(f\"fibonacci(-1) = {fibonacci(-1)}\") # []\n    print(f\"fibonacci(15) = {fibonacci(15)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n",
          "time_taken": 137.9312870502472
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef merge_sort(arr: List[T]) -> List[T]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的列表，元素类型可以是任何可比较的类型\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort(['c', 'a', 'b'])\n        ['a', 'b', 'c']\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[T], right: List[T]) -> List[T]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试重复元素\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]\n    \n    # 测试字符串列表\n    assert merge_sort(['banana', 'apple', 'cherry']) == ['apple', 'banana', 'cherry']\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 151.04307413101196
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 160, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 83.02362394332886
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    # 测试普通类型\n    @type_check\n    def add(a: int, b: int) -> int:\n        return a + b\n    \n    print(add(1, 2))  # 正常\n    \n    # 测试列表类型",
          "time_taken": 34.70076894760132
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义装饰器参数类型\nRetryConfig = Tuple[int, float, float, Tuple[Type[Exception], ...]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数的指数退避重试机制\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \n    Example:\n        @auto_retry(max_retries=3, delay=1.0, backoff=2.0, exceptions=(ValueError, TimeoutError))\n        def risky_function():\n            # 一些可能失败的函数\n            pass\n    \"\"\"\n    \n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            \"\"\"\n            异步函数包装器\n            \"\"\"\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 在第 {attempt + 1} 次调用失败: {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(f\"函数 {func.__name__}",
          "time_taken": 111.11339592933655
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, re",
          "time_taken": 20.92184019088745
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 126.39536714553833
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    该类提供了一个线程池实现，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x**2, 5)\n        >>> print(future.result())\n        25\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级 (数值越小优先级越高)\n            timeout: 任务超时时间(秒)\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，可用于获取任务结果或检查任务状态\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n       ",
          "time_taken": 68.8508369922638
        }
      ],
      "elapsed_seconds": 431.5
    },
    {
      "round": 211,
      "timestamp": 1771100876.660912,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 156, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 18.536736011505127
        }
      ],
      "elapsed_seconds": 262.3
    },
    {
      "round": 212,
      "timestamp": 1771101061.770838,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 168, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 19.907596111297607
        }
      ],
      "elapsed_seconds": 185.0
    },
    {
      "round": 213,
      "timestamp": 1771101156.877015,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 150, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 18.61959671974182
        }
      ],
      "elapsed_seconds": 94.9
    },
    {
      "round": 214,
      "timestamp": 1771101335.117323,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 150, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 18.361212730407715
        }
      ],
      "elapsed_seconds": 178.1
    },
    {
      "round": 215,
      "timestamp": 1771101718.368782,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 130.50316405296326
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组分成两半，\n    递归地对两半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 145.67394375801086
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 156, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 81.60999298095703
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return True\n        # 检查键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return resu",
          "time_taken": 37.60262107849121
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        ",
          "time_taken": 24.06576371192932
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 122.39194798469543
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom concurrent.futures import Future\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom collections import deque\nimport heapq\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        # 优先级越小，优先级越高\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._lock = threading.Lock()\n        self._initialize_workers()\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 设置超时时间，避免永久阻塞\n                task = self._task_queue.get(timeout=1.0)\n                self._execute_task(task)\n                self._task_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                # 记录异常但不中断工作线程\n                print(f\"Worker error: {e}\")\n    \n    def _execute_task(self, task: Task):\n        \"\"\"执行单个任务\"\"\"\n        try:\n            # 如果有超时设置，使",
          "time_taken": 66.83381986618042
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义异步和同步函数的类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Any]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数的指数退避重试机制\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间会乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            \"\"\"\n            异步函数包装器\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(\n                            f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试中失败: {e}，\"\n                            f\"将在 {current_delay:.2f} 秒后重试\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n            \n            # 这行代码实际上不会执行，因为上面的循环会抛出异常或返回\n            raise RuntimeError(\"意外的重试循环结束\")\n        \n        @functools.wraps(func)\n        def s",
          "time_taken": 110.57128596305847
        }
      ],
      "elapsed_seconds": 383.1
    },
    {
      "round": 216,
      "timestamp": 1771101938.511651,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 168, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 19.858325004577637
        }
      ],
      "elapsed_seconds": 220.0
    },
    {
      "round": 217,
      "timestamp": 1771102154.4193652,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 148, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 18.270564794540405
        }
      ],
      "elapsed_seconds": 215.8
    },
    {
      "round": 218,
      "timestamp": 1771102412.149803,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": false,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 159, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 19.03170084953308
        }
      ],
      "elapsed_seconds": 257.6
    },
    {
      "round": 219,
      "timestamp": 1771129308.69505,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while (self.position < len(self.expression) and \n                       (self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.')):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if (self.position == 0 or \n                    self.expression[self.position-1] in \"(+-*/\"):\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while (self.position < len(self.expression) and \n                           (self.expression[self.position].isdigit() or \n                            self.expression[self.position] == '.')):\n                        self.position += 1\n                    number_str = self.expression[start:",
          "time_taken": 20.585461854934692
        }
      ],
      "elapsed_seconds": 21.0
    },
    {
      "round": 220,
      "timestamp": 1771129542.5174432,
      "passed": 8,
      "total": 8,
      "avg_score": 8.75,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算（索引为2）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率：大数值测试\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 215.60266017913818
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种分治算法，将数组递归地分成两半，分别排序后再合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left)\n    right_sorted = merge_sort(right)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序结果: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 230.14966416358948
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        value = float(self.expression[star",
          "time_taken": 85.38078808784485
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：对于其他类型，如果expected_type是type则检查类型，否则返回True\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, hobbies: list[str], info: dict[str, int]) -> s",
          "time_taken": 37.95892405509949
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional, Coroutine\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Coroutine[Any, Any, T]]\nFunc = Union[SyncFunc, AsyncFunc]\n\nasync def async_sleep(delay: float) -> None:\n    \"\"\"异步睡眠\"\"\"\n    await asyncio.sleep(delay)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Func], Func]:\n    \"\"\"\n    自动重试装饰器\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子(指数退避)\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Func) -> Func:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        await async_sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 在 {max_retries} 次重试后仍然失败: {e}\"\n                        )\n                        raise\n            raise last_exception  # 理论上不会执行到这里\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_de",
          "time_taken": 187.8510398864746
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 阶段处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[A",
          "time_taken": 24.867114067077637
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        \"\"\"\n        初始化LRU缓存\n        \n        Args:\n            capacity: 缓存的最大容量\n        \"\"\"\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        \"\"\"\n        获取缓存中的值\n        \n        Args:\n            key: 要获取的键\n            \n        Returns:\n            如果键存在且未过期，返回对应的值；否则返回None\n        \"\"\"\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        \"\"\"\n        向缓存中添加或更新键值对\n        \n        Args:\n            key: 要添加或更新的键\n            value: 要存储的值\n            ttl: 过期时间（秒），如果为None则永不过期\n        \"\"\"\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为3的LRU缓存\n    cache = LRUCache(3)\n    \n    # 测试基本功能\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    cache.put(\"c\", 3)\n    \n    print(\"初始状态:\", cache.get(\"a\"))  # 应该返回1\n    print(\"初始状态:\", cache.get(\"b\"))  # 应该返回2\n    \n    # 测试LRU淘汰机制\n    cache.put(\"d\", 4)  # 这会淘汰最久未使用的\"a\"\n    print(\"淘汰测试:\", cache.get(\"a\"))  # 应该返回None\n    print(\"淘汰测试:\", cache.get(\"b\"))  # 应该返回2\n    \n    # 测试TTL过期\n    cache.put(\"e\", 5, ttl=1)  # 1秒后过期\n    print(\"TTL测试:\", cache.get(\"e\"))  # 应该返回5\n    time.sleep(1.1)  # 等待过期\n    print(\"TTL过期测试:\", cache.get(\"e\"))  # 应该返回None\n    \n    # 测试更新操作\n    cache.put(\"b\", 2",
          "time_taken": 205.13871264457703
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass Priority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n@dataclass(order=True)\nclass PriorityTask:\n    \"\"\"带优先级的任务包装器\"\"\"\n    priority: Priority = field(compare=False)\n    task_id: int = field(compare=False)\n    fn: Callable = field(compare=False)\n    args: tuple = field(compare=False)\n    kwargs: dict = field(compare=False)\n    timeout: Optional[float] = field(default=None)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务执行器，支持任务提交、批量执行、优雅关闭、超时控制和优先级调度。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._task_counter = 0\n        self._shutdown = False\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        self._worker_threads = []\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: Priority = Priority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的位置参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示不超时\n        ",
          "time_taken": 70.38803791999817
        }
      ],
      "elapsed_seconds": 233.8
    },
    {
      "round": 221,
      "timestamp": 1771129562.764215,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and \\\n                      (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and \\\n                          (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token('NUMBER', float(number_str)))\n  ",
          "time_taken": 19.603484869003296
        }
      ],
      "elapsed_seconds": 20.2
    },
    {
      "round": 222,
      "timestamp": 1771129563.259731,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 223,
      "timestamp": 1771129563.814996,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 224,
      "timestamp": 1771129564.364279,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=43)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 225,
      "timestamp": 1771129998.5217159,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 236.81645226478577
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的排序算法，采用分治法的思想：\n    1. 将数组分成两半\n    2. 递归地对两半进行排序\n    3. 合并两个已排序的数组\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 已排序的左列表\n        right: 已排序的右列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序结果: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 251.48303890228271
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\nimport re\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including float)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                value = float(self.expression[start:self.position])\n                self.tokens.append(Token(\"NUMBER\", value))\n                \n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", char))\n                self.position += 1\n                \n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in \"(+-*/\":\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position += 1\n                    value = flo",
          "time_taken": 117.56133198738098
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型的原始类型（如 list, dict, Union 等）\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型（如 Optional[X] 等价于 Union[X, None]）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有泛型参数，则只检查是否为 list\n        if not args:\n            return isinstance(value, list)\n        # 检查每个元素是否匹配泛型参数\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有泛型参数，则只检查是否为 dict\n        if not args:\n            return isinstance(value, dict)\n        # 检查每个键值对是否匹配泛型参数\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        带类型检查的包装函数\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名并绑定参数\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查每个参数的类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行原函数\n  ",
          "time_taken": 36.54441690444946
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序处理和并发批量处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return resul",
          "time_taken": 21.638129949569702
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\"\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 226.50747919082642
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        # Handle case where other is None (for shutdown signal)\n        if other is None:\n            return False\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级、超时和批量执行等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count()\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._lock = threading.Lock()\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从队列获取任务，设置超时避免永久阻塞\n                task = self._task_queue.get(timeout=1.0)\n                if task is None:  # 退出信号\n                    break\n                \n                # 执行任务\n                try:\n                    if task.timeout:\n                        # 使用超时执行\n                        result = self._executor.submit(\n                            task.fn, *task.args, **ta",
          "time_taken": 100.84114623069763
        }
      ],
      "elapsed_seconds": 434.0
    },
    {
      "round": 226,
      "timestamp": 1771130108.753045,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional, Coroutine\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Coroutine[Any, Any, T]]\nFunc = Union[SyncFunc, AsyncFunc]\n\nasync def async_sleep(delay: float) -> None:\n    \"\"\"异步睡眠\"\"\"\n    await asyncio.sleep(delay)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Func], Func]:\n    \"\"\"\n    自动重试装饰器\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子(指数退避)\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Func) -> Func:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试后成功执行\")\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        await async_sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 在 {max_retries} 次重试后仍然失败: {e}\"\n                        )\n                        raise\n          ",
          "time_taken": 109.62661790847778
        }
      ],
      "elapsed_seconds": 110.1
    },
    {
      "round": 227,
      "timestamp": 1771130394.589175,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 285.7
    },
    {
      "round": 228,
      "timestamp": 1771130556.633549,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 162.0
    },
    {
      "round": 229,
      "timestamp": 1771130692.7173948,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=44)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional, Coroutine\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Coroutine[Any, Any, T]]\nFunc = Union[SyncFunc, AsyncFunc]\n\nasync def async_sleep(delay: float) -> None:\n    \"\"\"异步睡眠\"\"\"\n    await asyncio.sleep(delay)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Func], Func]:\n    \"\"\"\n    自动重试装饰器\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间(秒)\n        backoff: 退避因子(指数退避)\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Func) -> Func:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        await async_sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 在 {max_retries} 次重试后仍然失败: {e}\"\n                        )\n                        raise\n            raise last_exception  # 理论上不会执行到这里\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwarg",
          "time_taken": 135.4930398464203
        }
      ],
      "elapsed_seconds": 136.0
    },
    {
      "round": 230,
      "timestamp": 1771131350.4489632,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试重复元素\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]\n    \n    # 测试原列表不变\n    original = [3, 1, 4, 1, 5]\n    sorted_arr = merge_sort(original)\n    assert original == [3, 1, 4, 1, 5]  # 原列表未被修改\n    assert sorted_arr == [1, 1, 3, 4, 5]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 523.4935100078583
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 510.54800391197205
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including decimals)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                value = float(self.expression[start:self.position])\n                self.tokens.append(Token(\"NUMBER\", value))\n            elif char == '+':\n                self.tokens.append(Token(\"+\", char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Parse the following number\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position += 1\n                    value = f",
          "time_taken": 344.36867785453796
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"\n    检查值是否匹配期望的类型。\n    \n    Args:\n        value: 要检查的值\n        expected_type: 期望的类型\n        \n    Returns:\n        bool: 如果值匹配类型返回True，否则返回False\n    \"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（包括 Optional）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器。\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数，会在调用时检查参数和返回值类型\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f",
          "time_taken": 62.02628803253174
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为2的LRU缓存\n    cache = LRUCache(2)\n    \n    # 测试基本功能\n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    print(cache.get(1))  # 应该输出 \"value1\"\n    \n    # 测试容量限制\n    cache.put(3, \"value3\")  # 这会删除最久未使用的项(1)\n    print(cache.get(1))  # 应该输出 None\n    print(cache.get(2))  # 应该输出 \"value2\"\n    print(cache.get(3))  # 应该输出 \"value3\"\n    \n    # 测试TTL过期\n    cache.put(4, \"value4\", ttl=0.1)  # 100毫秒后过期\n    print(cache.get(4))  # 应该输出 \"value4\"\n    time.sleep(0.15)  # 等待过期\n    print(cache.get(4))  # 应该输出 None\n    \n    # 测试线程安全\n    import concurrent.futures\n    \n    def test_thread_safe():\n        for i in range(10):\n            cache.put(i, f\"value{i}\")\n            cache.get(i)\n    \n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        futures = [executor.submit(test_thread_safe) for _ in range(5)]\n        for future in futures:\n            future.result()\n    \n    print(\"所有测试通过!\")\n",
          "time_taken": 499.4247851371765
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持按顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats: Dict[str, Dict[str, Any]] = defaultdict(\n            lambda: {\"calls\": 0, \"total_time\": 0.0, \"errors\": 0}\n        )\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self._stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，并记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_fn = self._stages[stage_name]\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self._stats[stage_name][\"calls\"] += 1\n            self._stats[stage_name][\"total_time\"] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误计数\n            self._stats[stage_name][\"calls\"] += 1\n            self._stats[stage_name][\"total_time\"] += (time.time() - start_time)\n            self._stats[stage_name][\"errors\"] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._execute_stage(stage_name, result)\n      ",
          "time_taken": 44.76631283760071
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Any]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \n    Example:\n        @auto_retry(max_retries=3, delay=1.0, backoff=2.0, exceptions=(ValueError, IOError))\n        def my_function():\n            # 可能失败的函数\n            pass\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            \"\"\"\n            异步函数包装器\n            \"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                    \n                except Exception as e:\n                    # 检查是否应该重试这个异常\n                    should_retry = any(isinstance(e, exc_type) for exc_type in exceptions)\n                    if not should_retry:\n                        logger.error(f\"函数 {func.__name__} 遇到未配置重试的异常: {type(e).__name__}: {e}\")\n                        raise e\n                    \n    ",
          "time_taken": 487.75282192230225
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 229, in <module>\n  File \"<string>\", line 55, in result\nconcurrent.futures._base.TimeoutError: Future not done",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom collections import deque\nimport heapq\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(init=False)\n    \n    def __post_init__(self):\n        self.future = Future()\n\n@dataclass\nclass Future:\n    \"\"\"Future对象，用于获取任务结果\"\"\"\n    _done: bool = False\n    _result: Any = None\n    _exception: Optional[Exception] = None\n    _callbacks: List[Callable] = field(default_factory=list)\n    _lock: threading.Lock = field(default_factory=threading.Lock)\n    \n    def set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        with self._lock:\n            if not self._done:\n                self._result = result\n                self._done = True\n                for callback in self._callbacks:\n                    callback(self)\n    \n    def set_exception(self, exception: Exception):\n        \"\"\"设置任务异常\"\"\"\n        with self._lock:\n            if not self._done:\n                self._exception = exception\n                self._done = True\n                for callback in self._callbacks:\n                    callback(self)\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果\"\"\"\n        if not self._done:\n            raise concurrent.futures.TimeoutError(\"Future not done\")\n        if self._exception:\n            raise self._exception\n        return self._result\n    \n    def done(self) -> bool:\n        \"\"\"检查任务是否完成\"\"\"\n        return self._done\n    \n    def add_done_callback(self, callback: Callable[['Future'], None]):\n        \"\"\"添加完成回调\"\"\"\n        with self._lock:\n            if self._done:\n                callback(self)\n            else:\n                self._callbacks.append(callback)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池实现并发执行任务，支持任务优先级、超时控制和优雅关闭。\n    \n    A",
          "time_taken": 409.555330991745
        }
      ],
      "elapsed_seconds": 657.6
    },
    {
      "round": 231,
      "timestamp": 1771131749.1488519,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union, Tuple\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        # Handle case where other is None (for shutdown signal)\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        # For any other type, return False to avoid comparison errors\n        return False\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级、超时和批量执行等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._lock = threading.Lock()\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从队列获取任务，设置超时避免永久阻塞\n                task = self._task_queue.get(timeout=1.0)\n                if task is None:  # 退出信号\n                    break\n                \n                # 执行任务\n                try:\n                    #",
          "time_taken": 110.6487033367157
        }
      ],
      "elapsed_seconds": 398.6
    },
    {
      "round": 232,
      "timestamp": 1771132116.2937322,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    该类提供了一个基于线程池的任务执行框架，支持：\n    - 提交单个任务\n    - 批量执行任务\n    - 任务优先级\n    - 任务超时控制\n    - 优雅关闭\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._worker_threads: List[threading.Thread] = []\n        self._initialize_workers()\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 使用超时机制，避免无限等待\n                task = self._task_queue.get(timeout=1.0)\n                self._execute_task(task)\n                self._task_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                # 记录异常但不中断工作线程\n                print(f\"Worker error: {e}\")\n    \n    def _execute_task(self, task: Task):\n        \"\"\"执行单个任务\"\"\"\n        try:\n            if task.timeout is not None:\n                # 使用 Threa",
          "time_taken": 31.558037996292114
        }
      ],
      "elapsed_seconds": 367.1
    },
    {
      "round": 233,
      "timestamp": 1771132743.105474,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 支持的函数类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., Any]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \n    Example:\n        @auto_retry(max_retries=3, delay=1.0, backoff=2.0, exceptions=(ValueError, IOError))\n        def my_function():\n            # 可能失败的函数\n            pass\n    \"\"\"\n    \n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        \"\"\"\n        装饰器实现\n        \n        Args:\n            func: 被装饰的函数\n            \n        Returns:\n            包装后的函数\n        \"\"\"\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            \"\"\"\n            异步函数包装器\n            \"\"\"\n            current_delay = delay\n            \n            # Normalize exceptions to handle IOError/OSError equivalence\n            normalized_exceptions = []\n            for exc_type in exceptions:\n                if exc_type == IOError:\n                    # Handle IOError -> OSError equivalence\n                    normalized_exceptions.extend([IOError, OSError])\n                else:\n                    normalized_exceptions.append(exc_type)\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt + 1} 次重试后成功",
          "time_taken": 353.8277850151062
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future as FutureType\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优雅关闭等操作。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or concurrent.futures.ThreadPoolExecutor()._max_workers\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._tasks_queue = queue.PriorityQueue()\n        self._task_thread = threading.Thread(target=self._worker, daemon=True)\n        self._task_thread.start()\n        self._task_count = 0\n        self._task_count_lock = threading.Lock()\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> FutureType:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"TaskPool has been shut down\")\n            \n        task = Task(fn, args, kwargs, priority, timeout)\n        future = concurrent.futures.Future()\n        \n        # 为任务分配唯一ID\n        with self._task_count_lock:\n            task_id = self._task_count\n            self._task_count += 1\n        \n        # ",
          "time_taken": 372.63865208625793
        }
      ],
      "elapsed_seconds": 626.7
    },
    {
      "round": 234,
      "timestamp": 1771132864.574393,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=45)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    该类提供了一个基于线程池的任务执行框架，支持：\n    - 提交单个任务\n    - 批量执行任务\n    - 任务优先级\n    - 任务超时控制\n    - 优雅关闭\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._worker_threads: List[threading.Thread] = []\n        self._initialize_workers()\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 使用超时机制，避免无限等待\n                task = self._task_queue.get(timeout=1.0)\n                self._execute_task(task)\n                self._task_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                # 记录异常但不中断工作线程\n                print(f\"Worker error: {e}\")\n    \n    def _execute_task(self, task: Task):\n        \"\"\"执行单个任务\"\"\"\n        try:\n            # 提交任务到线程池执行\n            if task.timeout is not None:\n ",
          "time_taken": 37.27187395095825
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义装饰器的参数类型\nRetryConfig = Tuple[int, float, float, Tuple[Type[Exception], ...]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间会乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"等待 {current_delay:.2f} 秒后重试...\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 最终失败: {e}\"\n                        )\n                        raise\n            raise last_exception\n        \n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args",
          "time_taken": 120.82370805740356
        }
      ],
      "elapsed_seconds": 121.4
    },
    {
      "round": 235,
      "timestamp": 1771133157.7922611,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能（大数值测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 266.37191915512085
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序结果: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 277.5159606933594
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.tokens = []\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.pos = 0\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                num_str = self.expression[start:self.pos]\n                self.tokens.append(Token(\"NUMBER\", float(num_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"+\", \"+\"))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    start = self.pos\n                    self.pos += 1\n                    while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                        self.pos += 1\n                    num_str = self.expression[start:self.pos]\n                    self.tokens.append(Token(\"NUMBER\", float(num_str)))\n                else:\n                    self.tokens.append(Token(\"-\", \"-\"))\n                    self.pos += 1\n            elif char == '*':\n                sel",
          "time_taken": 136.188734292984
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        result = func(*args, **kwargs)\n        \n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: x}\n    \n    # 正确调用\n    try:\n        result = example_function(",
          "time_taken": 32.523990869522095
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义同步和异步函数的类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数的指数退避重试机制。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        # 检查函数是否已经是异步函数\n        is_async = asyncio.iscoroutinefunction(func)\n        \n        if is_async:\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                retries = 0\n                current_delay = delay\n                \n                while True:\n                    try:\n                        result = await func(*args, **kwargs)\n                        return result\n                    except exceptions as e:\n                        retries += 1\n                        if retries > max_retries:\n                            logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                            raise e\n                        \n                        logger.warning(\n                            f\"函数 {func.__name__} 第 {retries} 次重试失败: {e}，\"\n                            f\"将在 {current_delay:.2f} 秒后重试\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                        \n            return async_wrapper\n        else:\n            # 同步函数处理\n            @functools",
          "time_taken": 239.58032703399658
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: ",
          "time_taken": 20.960710287094116
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    print(cache.get(1))  # Should return \"value1\"\n    \n    cache.put(3, \"value3\")  # This should evict key 2\n    print(cache.get(2))  # Should return None\n    \n    # Test TTL functionality\n    cache.put(4, \"value4\", ttl=1)  # 1 second TTL\n    print(cache.get(4))  # Should return \"value4\"\n    time.sleep(1.1)\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test LRU eviction with TTL\n    cache.put(5, \"value5\")\n    cache.put(6, \"value6\", ttl=0.5)\n    time.sleep(0.6)\n    cache.put(7, \"value7\")  # This should evict key 5 (not key 6 which is expired)\n    print(cache.get(6))  # Should return None (expired)\n    print(cache.get(5))  # Should return None (evicted)\n    print(cache.get(7))  # Should return \"value7\"\n",
          "time_taken": 257.0747230052948
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, as_completed\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务类，支持优先级比较\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级、超时等特性。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, name=f\"TaskPool-Worker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:",
          "time_taken": 131.8998830318451
        }
      ],
      "elapsed_seconds": 293.1
    },
    {
      "round": 236,
      "timestamp": 1771133587.499784,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 239, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/concurrent/futures/_base.py\", line 447, in result\n    raise TimeoutError()\nconcurrent.futures._base.TimeoutError",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Any, Callable, List, Optional, Union, Tuple\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future, Executor\nimport heapq\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        if self.priority == other.priority:\n            # When priorities are equal, use a stable comparison\n            # Using a unique identifier or just return False to avoid comparison issues\n            # In practice, this should be handled by the queue itself\n            return id(self) < id(other)  # Use object id as tiebreaker\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持：\n    - 提交单个任务\n    - 批量执行任务\n    - 任务超时控制\n    - 任务优先级\n    - 优雅关闭\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if t",
          "time_taken": 259.1178631782532
        }
      ],
      "elapsed_seconds": 429.6
    },
    {
      "round": 237,
      "timestamp": 1771133643.200671,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, as_completed\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务类，支持优先级比较\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级、超时等特性。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, name=f\"TaskPool-Worker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:",
          "time_taken": 55.11730217933655
        }
      ],
      "elapsed_seconds": 55.6
    },
    {
      "round": 238,
      "timestamp": 1771133995.870095,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 239, in <module>\n  File \"<string>\", line 202, in __exit__\n  File \"<string>\", line 182, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    # 添加任务序号用于比较，避免相同优先级时的比较问题\n    sequence: int = 0\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        if other is None:\n            return False\n        if isinstance(other, Task):\n            # 先比较优先级，再比较序号\n            if self.priority == other.priority:\n                return self.sequence < other.sequence\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现并发执行任务，支持任务提交、批量执行、优雅关闭等操作。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_threads: List[threading.Thread] = []\n        self._sequence_counter = 0\n        self._initialize_workers()\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                task = self._task_queue.get(timeout=1)\n                if task is None:  # 关闭信号\n          ",
          "time_taken": 158.86101484298706
        }
      ],
      "elapsed_seconds": 352.6
    },
    {
      "round": 239,
      "timestamp": 1771134190.541373,
      "passed": 7,
      "total": 8,
      "avg_score": 7.94,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=46)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 150, in <module>\nTypeError: '<' not supported between instances of 'Future' and 'Future'",
          "code_generated": "from typing import Callable, Iterable, List, Optional, Any, Tuple\nimport threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom concurrent.futures import ThreadPoolExecutor\nimport heapq\n\nclass TaskPool:\n    \"\"\"\n    A reusable concurrent task pool implementation using threading.\n    \n    This class provides a way to submit and execute tasks concurrently,\n    with support for task prioritization, timeouts, and graceful shutdown.\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        \"\"\"\n        Initialize the TaskPool with a specified number of worker threads.\n        \n        Args:\n            max_workers: Maximum number of worker threads. If None, \n                        uses ThreadPoolExecutor's default (usually number of CPUs * 5).\n        \"\"\"\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown = False\n        self._lock = threading.Lock()\n        self._task_queue = queue.PriorityQueue()\n        self._task_counter = 0\n        \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> ConcurrentFuture:\n        \"\"\"\n        Submit a task to the task pool.\n        \n        Args:\n            fn: The function to execute\n            *args: Positional arguments to pass to the function\n            priority: Task priority (lower numbers = higher priority)\n            timeout: Timeout in seconds for the task execution\n            **kwargs: Keyword arguments to pass to the function\n            \n        Returns:\n            A Future object representing the execution of the task\n            \n        Raises:\n            RuntimeError: If the pool has been shut down\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"Cannot submit tasks to a shutdown pool\")\n            \n        # Create a wrapper function that handles timeout\n        def timeout_wrapper():\n            if timeout is not None:\n               ",
          "time_taken": 144.55003595352173
        }
      ],
      "elapsed_seconds": 194.6
    },
    {
      "round": 240,
      "timestamp": 1771134648.108474,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率 - 大数值测试\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 274.42757511138916
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self.po",
          "time_taken": 88.8100438117981
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([5, 2, 8, 2, 9, 1]) == [1, 2, 2, 5, 8, 9]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 286.598356962204
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    # 测试基本类型\n    @type_check\n    def add(a: int, b: int) -> int:\n        return a + b\n    \n    print(add(1, 2))  # 正常运行\n    \n    # 测试列表类型\n    @",
          "time_taken": 34.16943407058716
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test thread safety\n    def thread_worker():\n        for i in range(100):\n            cache.put(f\"key_{i}\", i)\n            cache.get(f\"key_{i}\")\n    \n    threads = []\n    for _ in range(5):\n        t = threading.Thread(target=thread_worker)\n        threads.append(t)\n        t.start()\n    \n    for t in threads:\n        t.join()\n    \n    print(\"Thread s",
          "time_taken": 263.97521710395813
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序和并发处理数据。\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self._stages[name] = fn\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name, stage_fn in self._stages.items():\n            start_time = time.time()\n            try:\n                if asyncio.iscoroutinefunction(stage_fn):\n                    result = await stage_fn(result)\n                else:\n                    result = stage_fn(result)\n                self._stats[stage_name]['calls'] += 1\n                self._stats[stage_name]['total_time'] += (time.time() - start_time)\n            except Exception as e:\n                self._stats[stage_name]['errors'] += 1\n                self._stats[stage_name]['calls'] += 1\n                self._stats[stage_name]['total_time'] += (time.time() - start_time)\n                raise  # 重新抛出异常\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        \"\"\"\n        并发处理数据批次\n        \n        Args:\n            items: 数据列表\n            concurrency: 并发数限制\n            \n        Returns:\n            处理后的数据列表\n        \"\"\"\n        semaphore = asyncio.Semaphore(concurrency)\n        \n        async def process_i",
          "time_taken": 21.50659203529358
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, as_completed\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务类，支持优先级比较\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级、超时等特性。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"hello\")\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, name=f\"TaskPool-Worker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:",
          "time_taken": 83.68404698371887
        }
      ],
      "elapsed_seconds": 457.5
    },
    {
      "round": 241,
      "timestamp": 1771134869.484388,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义同步和异步函数的类型\nSyncFunc = Callable[..., T]\nAsyncFunc = Callable[..., T]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Union[SyncFunc, AsyncFunc]], Union[SyncFunc, AsyncFunc]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数的指数退避重试机制。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Union[SyncFunc, AsyncFunc]) -> Union[SyncFunc, AsyncFunc]:\n        # 检查函数是否已经是异步函数\n        is_async = asyncio.iscoroutinefunction(func)\n        \n        if is_async:\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                retries = 0\n                current_delay = delay\n                \n                while True:\n                    try:\n                        result = await func(*args, **kwargs)\n                        return result\n                    except exceptions as e:\n                        retries += 1\n                        if retries > max_retries:\n                            logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                            raise e\n                        \n                        logger.warning(\n                            f\"函数 {func.__name__} 第 {retries} 次重试失败: {e}，\"\n                            f\"将在 {current_delay:.2f} 秒后重试\"\n                        )\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                        \n            return async_wrapper\n        else:\n            # 同步函数处理\n            @functools",
          "time_taken": 218.89115524291992
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        # Handle comparison with None values\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优雅关闭等操作。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> result = future.result()\n        >>> print(result)  # 10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间（秒）\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._shutdown = False\n        self._lock = threading.Lock()\n        self._task_queue = queue.PriorityQueue()\n        self._worker_threads: List[threading.Thread] = []\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown:\n       ",
          "time_taken": 98.2367160320282
        }
      ],
      "elapsed_seconds": 221.3
    },
    {
      "round": 242,
      "timestamp": 1771135680.377717,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "from typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\nimport asyncio\nimport functools\nimport logging\nimport time\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义装饰器参数类型\nRetryConfig = Tuple[int, float, float, Tuple[Type[Exception], ...]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 执行最终失败: {e}\"\n                        )\n                        raise\n            raise last_exception  # 这行代码实际上不会被执行\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n         ",
          "time_taken": 312.0140652656555
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n\n@dataclass\nclass Task:\n    \"\"\"任务类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __hash__(self):\n        return id(self)\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池实现并发任务执行，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._task_queue = queue.PriorityQueue()\n        self._task_count = 0\n        self._task_lock = threading.Lock()\n        \n        # 启动任务处理线程\n        self._worker_thread = threading.Thread(target=self._worker_loop, daemon=True)\n        self._worker_thread.start()\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数位置参数\n            priority: 任务优先级 (LOW, NORMAL, HIGH)\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"TaskPool has been shutdown\")\n        \n        # 创建任务\n        task = Task(\n            func=fn,\n            args=args,\n            kwargs=kwargs,\n            priority=p",
          "time_taken": 554.754805803299
        }
      ],
      "elapsed_seconds": 810.8
    },
    {
      "round": 243,
      "timestamp": 1771136015.6213691,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator, Tuple\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        # Handle comparison with None values\n        if other is None:\n            return False\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优雅关闭等操作。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n        timeout: 默认任务超时时间（秒）\n        \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> result = future.result()\n        >>> print(result)  # 10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None, timeout: Optional[float] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n            timeout: 默认任务超时时间（秒）\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self.timeout = timeout\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._shutdown = False\n        self._lock = threading.Lock()\n        self._task_queue = queue.PriorityQueue()\n        self._worker_threads: List[threading.Thread] = []\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown:\n       ",
          "time_taken": 36.292763233184814
        }
      ],
      "elapsed_seconds": 335.1
    },
    {
      "round": 244,
      "timestamp": 1771136225.101797,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=47)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "from typing import Any, Callable, Type, TypeVar, Tuple, Optional, Union, overload\nimport asyncio\nimport functools\nimport logging\nimport time\nimport inspect\nfrom typing_extensions import Literal\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 执行最终失败: {e}\"\n                        )\n                        raise\n            raise last_exception  # 这行代码实际上不会被执行\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result ",
          "time_taken": 207.8210060596466
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, Optional\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submitted_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"支持优先级比较\"\"\"\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority < other.priority\n\nclass TaskPool(Executor):\n    \"\"\"基于线程的并发任务池\"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._work_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._worker_threads = []\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, name=f\"TaskPoolWorker-{i}\")\n            thread.daemon = True\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程主循环\"\"\"\n        while True:\n            try:\n                priority, task = self._work_queue.get(timeout=1.0)\n                \n                if self._shutdown:\n                    break\n                    \n                try:\n                    result = task.func(*task.args, **task.kwargs)\n                    task.future.set_result(result)\n                except Exception as e:\n                    task.future.set_exception(e)\n                finally:\n                    self._work_queue.task_done()\n                    \n            except queue.Empty:\n                if self._shutdown:\n                    break\n                continue\n            except Excepti",
          "time_taken": 189.20632004737854
        }
      ],
      "elapsed_seconds": 209.3
    },
    {
      "round": 245,
      "timestamp": 1771136630.6745658,
      "passed": 7,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算（索引为2）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 253.2363519668579
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治策略的排序算法。它将数组分成两半，\n    递归地对两半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保纯函数特性\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 2, 8, 1],          # 小列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n ",
          "time_taken": 266.3691830635071
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens: List[Token] = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                self.tokens.append(Token('MINUS', '-'))\n                self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        number_str = self.expression[start:self.pos]\n        try:\n            if '.' in number_str:\n                number = float(number_str)\n            else:\n                number = int(number_str)\n            self",
          "time_taken": 82.2837278842926
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, hobbies: list[str], scores: dict[str, int]) -> str:\n        return f\"{name} is {age} y",
          "time_taken": 33.94002318382263
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发批量处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 阶段处理函数\n            data: 输入数据\n            \n        Returns:\n            处理结果\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[",
          "time_taken": 21.426326036453247
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 243.53715991973877
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom concurrent.futures import Future\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 1\n    NORMAL = 2\n    HIGH = 3\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count()\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._lock = threading.Lock()\n        self._initialize_workers()\n    \n    def _initialize_workers(self) -> None:\n        \"\"\"初始化工作线程\"\"\"\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self) -> None:\n        \"\"\"工作线程主循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 使用超时机制避免无限等待\n                task = self._task_queue.get(timeout=1.0)\n                self._execute_task(task)\n                self._task_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                # 记录错误但不中断工作线程\n                print(f\"Worker error: {e}\")",
          "time_taken": 64.53642392158508
        }
      ],
      "elapsed_seconds": 405.5
    },
    {
      "round": 246,
      "timestamp": 1771136888.380951,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 257.6
    },
    {
      "round": 247,
      "timestamp": 1771136930.336191,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "from typing import Any, Callable, Type, TypeVar, Tuple, Optional, Union\nimport asyncio\nimport functools\nimport logging\nimport time\nimport inspect\nfrom asyncio import iscoroutinefunction\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    # Check if the exception is in our retryable exceptions\n                    if not isinstance(e, exceptions):\n                        raise  # Re-raise if not in our retryable exceptions\n                    \n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 执行最终失败: {e}\"\n                        )\n                        raise\n            raise last_exception  # This line won't be reached\n        \n        @functools.wraps(func)\n        async def ",
          "time_taken": 41.282180070877075
        }
      ],
      "elapsed_seconds": 41.9
    },
    {
      "round": 248,
      "timestamp": 1771137215.402291,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 285.0
    },
    {
      "round": 249,
      "timestamp": 1771137237.113523,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=48)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "from typing import Any, Callable, Type, TypeVar, Tuple, Optional, Union\nimport asyncio\nimport functools\nimport logging\nimport time\nimport inspect\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 执行失败 (尝试 {attempt + 1}/{max_retries + 1}): {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(\n                            f\"函数 {func.__name__} 执行最终失败: {e}\"\n                        )\n                        raise\n            raise last_exception  # 这行代码实际上不会被执行\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                  ",
          "time_taken": 21.06187915802002
        }
      ],
      "elapsed_seconds": 21.6
    },
    {
      "round": 250,
      "timestamp": 1771137763.900796,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试边界情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    \n    # 测试正常情况\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 测试负数情况\n    print(f\"fibonacci(-1) = {fibonacci(-1)}\")  # []\n",
          "time_taken": 349.2781686782837
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种基于分治思想的稳定排序算法。它将数组递归地分成两半，\n    分别排序后再合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]\n    \n    # 验证原列表未被修改\n    original = [3, 1, 4, 1, 5]\n    sorted_result = merge_sort(original)\n    assert original == [3, 1, 4, 1, 5]  # 原列表不变\n ",
          "time_taken": 363.28585171699524
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                num_str = self.expression[start:self.pos]\n                self.tokens.append(Token('NUMBER', float(num_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    # This is a negative sign, not a subtraction\n                    start = self.pos\n                    self.pos += 1\n                    # Parse the following number\n                    while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                        self.pos += 1\n                    num_str = self.expression[start:self.pos]\n                    self.tokens.append(Token('NUMBER', float(num_str)))\n                else:\n                    self.tokens.append(Token('-', '-'))\n                    self.pos += ",
          "time_taken": 308.4052710533142
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（包括 Optional）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，则只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，则只检查是否为 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n   ",
          "time_taken": 52.7907600402832
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, Tuple, Union, Awaitable\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以该因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.warning(\n                            f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}. \"\n                            f\"将在 {current_delay:.2f} 秒后重试...\"\n                        )\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise\n            raise last_exception\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n        ",
          "time_taken": 324.5454320907593
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理结果\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurr",
          "time_taken": 21.75214195251465
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic operations\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 338.9498291015625
        }
      ],
      "elapsed_seconds": 526.7
    },
    {
      "round": 251,
      "timestamp": 1771137903.648934,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            \n            # 为每次调用创建独立的尝试计数器\n            attempt_counter = 0\n            \n            while attempt_counter <= max_retries:\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt_counter == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                        raise e\n                    \n                    logger.warning(f\"函数 {func.__name__} 第 {attempt_counter + 1} 次调用失败: {e}\")\n                    logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n                    attempt_counter += 1\n                    \n            # 理论上不会到达这里，但为了类型检查加上\n            raise RuntimeError(\"重试逻辑异常\")\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            \n            # 为每次调用创建独立的尝试计数器\n            attempt_counter = 0\n            \n            while attempt_counter <= max_retries:\n                try:\n                    result = await func(*args, **k",
          "time_taken": 137.6944088935852
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom concurrent.futures import Future\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 1\n    NORMAL = 2\n    HIGH = 3\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    # 用于优先级队列的排序\n    _id: int = field(default_factory=int)\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        if self.priority.value != other.priority.value:\n            return self.priority.value < other.priority.value\n        return self._id < other._id  # 确保相同优先级时按提交顺序执行\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._lock = threading.Lock()\n        self._task_id_counter = 0\n        self._initialize_workers()\n    \n    def _initialize_workers(self) -> None:\n        \"\"\"初始化工作线程\"\"\"\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self) -> None:\n        \"\"\"工作线程主循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 使用超时机制避免无限等待\n                task = self._task_queue.get(timeout=1.0)\n                self._ex",
          "time_taken": 37.2651150226593
        }
      ],
      "elapsed_seconds": 139.7
    },
    {
      "round": 252,
      "timestamp": 1771137969.1708841,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Any, Callable, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable[..., Any]\n    args: Tuple[Any, ...]\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现并发执行任务，支持任务优先级、超时控制等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or threading.active_count()\n        self._workers: List[threading.Thread] = []\n        self._task_queue: queue.PriorityQueue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._lock = threading.Lock()\n        self._initialize_workers()\n    \n    def _initialize_workers(self):\n        \"\"\"初始化工作线程\"\"\"\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker_loop, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 使用超时机制避免长时间阻塞\n                task = self._task_queue.get(timeout=1.0)\n                self._execute_task(task)\n                self._task_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception:\n                # 避免线程崩溃\n                continue\n    \n    def _execute_task(self, task: Task):\n        \"\"\"执行单个任务\"\"\"\n        try:\n            if task.timeout:\n     ",
          "time_taken": 64.89977979660034
        }
      ],
      "elapsed_seconds": 65.4
    },
    {
      "round": 253,
      "timestamp": 1771138028.550891,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"用于优先队列比较\"\"\"\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行异步任务，支持任务优先级、超时控制和优雅关闭。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown = False\n        self._lock = threading.Lock()\n        \n        # 用于存储任务队列\n        self._task_queue = queue.PriorityQueue()\n        self._worker_threads: List[threading.Thread] = []\n        self._start_workers()\n    \n    def _start_workers(self) -> None:\n        \"\"\"启动工作线程\"\"\"\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self) -> None:\n        \"\"\"工作线程循环\"\"\"\n        while not self._shutdown:\n            try:\n                # 从优先队列中获取任务\n                task = self._task_queue.get(timeout=1.0)\n                if task is None:  # 退出信号\n                    break\n                \n                # 执行任务\n          ",
          "time_taken": 58.7247531414032
        }
      ],
      "elapsed_seconds": 59.3
    },
    {
      "round": 254,
      "timestamp": 1771138029.021995,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=49)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 255,
      "timestamp": 1771138308.3625758,
      "passed": 7,
      "total": 8,
      "avg_score": 7.44,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证边界条件\n    print(f\"fibonacci(-1) = {fibonacci(-1)}\")  # []\n    print(f\"fibonacci(15) = {fibonacci(15)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n",
          "time_taken": 213.8650941848755
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，它将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n        assert test_case == original",
          "time_taken": 226.87564301490784
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, parse the following number\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token('NUMBER', float(number_str)))\n                else:\n                    s",
          "time_taken": 89.09460496902466
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        if isinstance(expected_type, type):\n            return isinstance(value, expected_type)\n        else:\n            return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    # 测试函数1: 基本类型检查\n    @type_check\n    def add(a: int, b: int) -> int:\n        return a + b\n    \n    p",
          "time_taken": 39.18358492851257
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom collections import defaultdict\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池，基于线程实现\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 超时控制\n    - 任务优先级\n    - 可配置的最大工作线程数\n    \n    Example:\n        pool = TaskPool(max_workers=4)\n        future = pool.submit(func, arg1, arg2)\n        result = future.result()\n        pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为CPU核心数\n        \"\"\"\n        self.max_workers = max_workers or threading.active_count()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._work_queue = queue.PriorityQueue()\n        self._threads = set()\n        self._idle_semaphore = threading.Semaphore(0)\n        self._result_queue = queue.Queue()\n        self._running_tasks = 0\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.add(thread)\n    \n    def _worker(self) -> None:\n        \"\"\"\n        工作线程函数\n        \"\"\"\n        while True:\n            try:\n                # 从优先级队列中获取任务\n                priority, task_id, func, args, kwargs, timeout, future = self._work_queue.get(timeout=1)\n                \n                if self._shutdown:\n                    break\n                \n                # 记录任务开始\n                self._running_tasks += 1\n                \n                try:\n                    # 执行任务\n                    if timeout is not None:\n                        # 使用超时控制\n                        result = self._execute_with_timeout(func, args, kwargs, timeout)\n                    else:\n                        result",
          "time_taken": 70.01972198486328
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录性能统计\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n    ",
          "time_taken": 20.188052892684937
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 202.7157220840454
        }
      ],
      "elapsed_seconds": 279.2
    },
    {
      "round": 256,
      "timestamp": 1771138466.796885,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Tuple, Union, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子，每次重试延迟时间乘以此因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            attempt_counter = 0\n            \n            while True:\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    attempt_counter += 1\n                    if attempt_counter > max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                        raise e\n                    \n                    logger.warning(f\"函数 {func.__name__} 第 {attempt_counter} 次调用失败: {e}\")\n                    logger.info(f\"等待 {current_delay:.2f} 秒后重试...\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n                    \n            # 理论上不会到达这里\n            raise RuntimeError(\"重试逻辑异常\")\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            attempt_counter = 0\n            \n            while True:\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    attempt_counter += 1\n                    if attempt_",
          "time_taken": 157.77545714378357
        }
      ],
      "elapsed_seconds": 158.3
    },
    {
      "round": 257,
      "timestamp": 1771138486.035125,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义装饰器的参数类型\nRetryConfig = Tuple[int, float, float, Tuple[Type[Exception], ...]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                        raise e\n                    \n                    logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}，将在 {current_delay:.2f} 秒后重试\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            \n            # 理论上不会执行到这里\n            raise RuntimeError(\"意外的重试逻辑\")\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"异步函数 {func.__name__} 最终失败，抛出原始异常: {e}\")\n                      ",
          "time_taken": 18.580068111419678
        }
      ],
      "elapsed_seconds": 19.1
    },
    {
      "round": 258,
      "timestamp": 1771138587.312135,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "from typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\nimport asyncio\nimport functools\nimport logging\nimport time\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\n\n# 定义装饰器参数类型\nRetryConfig = Tuple[int, float, float, Tuple[Type[Exception], ...]]\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    自动重试装饰器，支持同步和异步函数\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（指数退避）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"异步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    if attempt > 0:\n                        logger.info(f\"函数 {func.__name__} 在第 {attempt} 次重试后成功执行\")\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败，抛出异常: {e}\")\n                        raise\n                    else:\n                        logger.warning(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试失败: {e}\")\n                        logger.info(f\"等待 {current_delay:.2f} 秒后进行下一次重试...\")\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n            \n            # 理论上不会到达这里，但为了类型检查添加返回\n            raise RuntimeError(\"意外的重试循环结束\")\n        \n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            \"\"\"同步函数包装器\"\"\"\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    ",
          "time_taken": 100.5047390460968
        }
      ],
      "elapsed_seconds": 101.1
    },
    {
      "round": 259,
      "timestamp": 1771138587.784539,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=50)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 260,
      "timestamp": 1771138840.281225,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能（大数测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 235.33465790748596
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法，时间复杂度为O(n log n)，\n    空间复杂度为O(n)。该函数是纯函数，不修改原始列表。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，按升序排列\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序后:   {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 250.1384677886963
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type_: TokenType, value: Union[float, str]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens: List[Token] = []\n    \n    def peek(self) -> str:\n        if self.pos < len(self.expression):\n            return self.expression[self.pos]\n        return \"\"\n    \n    def advance(self) -> str:\n        if self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            self.pos += 1\n            return char\n        return \"\"\n    \n    def skip_whitespace(self):\n        while self.peek().isspace():\n            self.advance()\n    \n    def read_number(self) -> float:\n        num_str = \"\"\n        while self.peek().isdigit() or self.peek() == '.':\n            num_str += self.advance()\n        return float(num_str)\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        while self.pos < len(self.expression):\n            self.skip_whitespace()\n            \n            if self.peek() == '':\n                break\n            \n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                # Read number (including decimals)\n                number = self.read_number()\n                self.tokens.append(Token(TokenType.NUMBER, number))\n            elif char == '+':\n                self.tokens.append(Token(TokenType.PLUS, '+'))\n                self.advance()\n            elif char == '-':\n                # Check if this is a negative number\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n  ",
          "time_taken": 112.31818699836731
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况，尝试使用 isinstance 检查\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, items: list[int], data: dict[str, int]) -> str:\n        return f\"x={",
          "time_taken": 35.44003486633301
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段并记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_func = self.stages[stage_name]\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 记录成功执行的统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_nam",
          "time_taken": 23.051727056503296
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: TaskPriority = TaskPriority.NORMAL\n    submit_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"支持优先级比较\"\"\"\n        if self.priority == other.priority:\n            return self.submit_time < other.submit_time\n        return self.priority.value < other.priority.value\n\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行任务、优雅关闭等操作。\n    使用线程实现并发执行。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        if max_workers is None:\n            import multiprocessing\n            max_workers = multiprocessing.cpu_count()\n        \n        self.max_workers = max_workers\n        self._work_queue = queue.PriorityQueue()\n        self._threads: List[threading.Thread] = []\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._idle_lock = threading.Lock()\n        self._idle_count = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: TaskPriority = TaskPriority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n",
          "time_taken": 92.50398325920105
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Union, Tuple, Optional\n\nfrom typing_extensions import ParamSpec\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\nP = ParamSpec('P')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    自动重试装饰器，支持指数退避和异步函数。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（延迟时间按此因子指数增长）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise  # 重新抛出原始异常\n                    \n                    logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                    logger.info(f\"将在 {current_delay:.2f} 秒后重试...\")\n                    \n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n                    \n            # 理论上不会到达这里，但为了类型检查添加\n            raise RuntimeError(\"Unexpected execution path\")\n        \n        # Check if the original function is a coroutine function\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        else:\n            @functools.wraps(func)\n            def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n                current_delay = dela",
          "time_taken": 211.9787139892578
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\"\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 225.48589777946472
        }
      ],
      "elapsed_seconds": 252.3
    },
    {
      "round": 261,
      "timestamp": 1771138840.754219,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 262,
      "timestamp": 1771138841.231412,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 263,
      "timestamp": 1771138841.708234,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 264,
      "timestamp": 1771138842.189705,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=51)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 265,
      "timestamp": 1771139881.359007,
      "passed": 6,
      "total": 8,
      "avg_score": 7.0,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.current_char = self.expression[self.pos] if self.expression else None\n    \n    def advance(self):\n        \"\"\"Move to the next character in the expression.\"\"\"\n        self.pos += 1\n        if self.pos >= len(self.expression):\n            self.current_char = None\n        else:\n            self.current_char = self.expression[self.pos]\n    \n    def skip_whitespace(self):\n        \"\"\"Skip whitespace characters.\"\"\"\n        while self.current_char and self.current_char.isspace():\n            self.advance()\n    \n    def read_number(self) -> Token:\n        \"\"\"Read a number (integer or float) from the expression.\"\"\"\n        num_str = \"\"\n        while self.current_char and (self.current_char.isdigit() or self.current_char == '.'):\n            num_str += self.current_char\n            self.advance()\n        return Token(TokenType.NUMBER, float(num_str))\n    \n    def tokenize(self) -> List[Token]:\n        \"\"\"Convert the expression string into a list of tokens.\"\"\"\n        tokens = []\n        while self.current_char is not None:\n            self.skip_whitespace()\n            \n            if self.current_char is None:\n                break\n                \n            if self.current_char.isdigit() or self.current_char == '.':\n                tokens.append(self.read_number())\n            elif self.current_char == '+':\n                tokens.append(Token(TokenType.PLUS, '+'))\n                self.advance()\n            e",
          "time_taken": 400.03575325012207
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 529.4917397499084
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以保证纯函数特性\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试重复元素\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]\n    \n    # 测试负数\n    assert merge_sort([-3, -1, -4, -1, -5, -9, -2, -6]) == [-9, -6, -5, -4, -3, -2, -1, -1]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 541.8924400806427
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": false,
          "score": 5.0,
          "error": "retry agent error: 'NoneType' object is not subscriptable",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:  # 无参数的 list\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:  # 无参数的 dict\n            return True\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数，会在运行时检查参数和返回值类型\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名并绑定参数\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['ret",
          "time_taken": 302.9368588924408
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的最终数据\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stag",
          "time_taken": 24.586482763290405
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\"\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 519.7386698722839
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, as_completed\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nimport heapq\n\n\n@dataclass(order=True)\nclass PrioritizedTask:\n    \"\"\"带优先级的任务\"\"\"\n    priority: int\n    task_id: int = field(compare=False)\n    fn: Callable = field(compare=False)\n    args: tuple = field(compare=False)\n    kwargs: dict = field(compare=False)\n    timeout: Optional[float] = field(default=None)\n    future: Optional[Future] = field(default=None, compare=False)\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、超时控制和优先级管理。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(lambda x: x*2, 5)\n        >>> result = future.result()\n        >>> print(result)  # 10\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._work_queue = queue.PriorityQueue()\n        self._threads = []\n        self._task_id_counter = 0\n        self._task_id_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.append(thread)\n    \n    def _get_next_task_id(self) -> int:\n        \"\"\"获取下一个任务ID\"\"\"\n        with self._task_id_lock:\n            self._task_id_counter += 1\n            return self._task_id_counter\n    \n    def _worker(self) -> None:\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown:\n            try:\n                # 从优先级队列中获取任务\n                prioritized_task = self._work_queue.get(timeout=1)\n                task_id =",
          "time_taken": 463.34036016464233
        }
      ],
      "elapsed_seconds": 1039.1
    },
    {
      "round": 266,
      "timestamp": 1771140044.6823108,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况，尝试使用 isinstance 检查\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, items: list[int], data: dict[str, int]) -> str:\n        return f\"x={",
          "time_taken": 17.95508098602295
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Tuple, Optional, Union\n\nfrom typing_extensions import ParamSpec\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\nP = ParamSpec('P')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    自动重试装饰器，支持指数退避和异步函数。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（延迟时间按此因子指数增长）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise  # 重新抛出原始异常\n                    \n                    logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                    logger.info(f\"将在 {current_delay:.2f} 秒后重试...\")\n                    \n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n                    \n            # This line should never be reached due to the raise above\n            raise RuntimeError(\"Unexpected execution path\")\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = func(*args, ",
          "time_taken": 162.6496558189392
        }
      ],
      "elapsed_seconds": 163.2
    },
    {
      "round": 267,
      "timestamp": 1771140389.894805,
      "passed": 7,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": false,
          "score": 0.0,
          "error": "'NoneType' object is not subscriptable",
          "code_generated": "",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型参数的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 如果是普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否是 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否是 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底处理：如果是普通类型则使用 isinstance 检查\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    \n    # 其他情况返回 True（避免过于严格的检查）\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hi",
          "time_taken": 17.477592945098877
        }
      ],
      "elapsed_seconds": 345.1
    },
    {
      "round": 268,
      "timestamp": 1771140535.9489741,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（如 Optional[X] 等价于 Union[X, None]）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，则只检查是否为 list\n        if not args:\n            return isinstance(value, list)\n        # 检查每个元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，则只检查是否为 dict\n        if not args:\n            return isinstance(value, dict)\n        # 检查每个键值对是否匹配\n        return all(\n            _matches_type(k, args[0]) and _matches_type(v, args[1]) \n            for k, v in value.items()\n        )\n    \n    # 兜底情况：如果 expected_type 是一个类型，则检查是否匹配\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        装饰后的函数，会在运行时检查参数和返回值的类型\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查每个参数的类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错",
          "time_taken": 36.4028160572052
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport logging\nimport time\nfrom typing import Any, Callable, Type, TypeVar, Tuple, Union, Optional\n\nfrom typing_extensions import ParamSpec\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# 类型变量\nT = TypeVar('T')\nP = ParamSpec('P')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    自动重试装饰器，支持指数退避和异步函数。\n    \n    Args:\n        max_retries: 最大重试次数\n        delay: 初始延迟时间（秒）\n        backoff: 退避因子（延迟时间按此因子指数增长）\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @functools.wraps(func)\n        async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            current_delay = delay\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 最终失败: {e}\")\n                        raise  # 重新抛出原始异常\n                    \n                    logger.warning(f\"函数 {func.__name__} 第 {attempt + 1} 次调用失败: {e}\")\n                    logger.info(f\"将在 {current_delay:.2f} 秒后重试...\")\n                    \n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n                    \n            # 理论上不会到达这里，但为了类型检查添加\n            raise RuntimeError(\"Unexpected execution path\")\n        \n        # Check if the original function is a coroutine function\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        else:\n            @functools.wraps(func)\n            def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n                current_delay = dela",
          "time_taken": 145.5465440750122
        }
      ],
      "elapsed_seconds": 146.0
    },
    {
      "round": 269,
      "timestamp": 1771144358.1823978,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=52)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Type, TypeVar, Union, Callable, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay} seconds...\")\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. No more retries.\")\n                        raise\n            \n            raise last_exception\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attem",
          "time_taken": 12.447103023529053
        }
      ],
      "elapsed_seconds": 12.8
    },
    {
      "round": 270,
      "timestamp": 1771144540.1902668,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 165.59491205215454
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，通过将数组递归地分成两半，分别排序后再合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 已排序的左列表\n        right: 已排序的右列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {test_case} -> {sorted_result}\")\n",
          "time_taken": 179.7928807735443
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\nimport re\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and \\\n                      (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"+\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position-1] in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    while self.position < len(self.expression) and \\\n                          (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token(\"NUMBER\", float(number_str)))\n    ",
          "time_taken": 129.60480904579163
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果是普通类型，使用isinstance检查\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例使用\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, scores: list[int], info: dict[str, int]) -> str:\n        return f",
          "time_taken": 33.762001276016235
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Callable, Type, Any, Union, Awaitable\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        if asyncio.iscoroutinefunction(func):\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay} seconds...\")\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. No more retries.\")\n                            raise\n                raise last_exception\n            return async_wrapper\n        else:\n            @functools.wraps(func)\n            def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return func(*args, **kwargs)\n     ",
          "time_taken": 140.0882909297943
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理结果\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        \"\"\"\n        并发处理一批数据\n        \n     ",
          "time_taken": 20.610652923583984
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator, Union\nfrom collections import namedtuple\n\n# 定义任务优先级包装器\nTaskItem = namedtuple('TaskItem', ['priority', 'submit_time', 'future', 'fn', 'args', 'kwargs'])\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池，使用线程实现\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 任务超时控制\n    - 任务优先级支持\n    - 优雅关闭\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，如果为None则使用CPU核心数\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._workers: List[threading.Thread] = []\n        self._work_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._idle_semaphore = threading.Semaphore(0)\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级 (数字越小优先级越高)\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"Cannot submit tasks to a shutdown pool\")\n        \n        future = Future()\n        task = TaskItem(priority, time.time(), future, fn, args, kwargs)\n        \n        # 将任务加入优先队列\n        self._work_queue.put(task)\n        self._idle_semaphore.release()\n        \n        # 如果设置了超时，启动超时检查\n        if timeout is not None:\n            def timeout_check():\n              ",
          "time_taken": 111.63782691955566
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still valid)\n    print(cache.get(\"d\"))  # Should return 4 (still valid)\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 155.39504194259644
        }
      ],
      "elapsed_seconds": 181.9
    },
    {
      "round": 271,
      "timestamp": 1771144540.666778,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 272,
      "timestamp": 1771144884.734556,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 273,
      "timestamp": 1771144885.158566,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 274,
      "timestamp": 1771144885.609429,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=53)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 275,
      "timestamp": 1771145067.9032729,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 157.74414324760437
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，它将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保纯函数特性\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([5, 2, 8, 2, 1]) == [1, 2, 2, 5, 8]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 171.6061508655548
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                self.tokens.append(Token('MINUS', '-'))\n                self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        number_str = self.expression[start:self.pos]\n        try:\n            if '.' in number_str:\n                number = float(number_str)\n            else:\n                number = int(number_str)\n            self.tokens.append(Token('NUMBER', n",
          "time_taken": 119.94924688339233
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        result = func(*args, **kwargs)\n        \n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: x}\n    \n    # 正确调用\n    try:\n        result = example_func(1, \"test\"",
          "time_taken": 34.13056707382202
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Callable, Type, Union, Any, Optional\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay}s...\")\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. No more retries.\")\n            raise last_exception\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retry",
          "time_taken": 130.73044085502625
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_fn = self.stages[stage_name]\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_sta",
          "time_taken": 20.912166833877563
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为2的LRU缓存\n    cache = LRUCache(2)\n    \n    # 测试基本功能\n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    print(cache.get(1))  # 应该输出 \"value1\"\n    \n    # 测试容量限制\n    cache.put(3, \"value3\")  # 这会删除最久未使用的项(1)\n    print(cache.get(1))  # 应该输出 None\n    print(cache.get(2))  # 应该输出 \"value2\"\n    print(cache.get(3))  # 应该输出 \"value3\"\n    \n    # 测试TTL功能\n    cache.put(4, \"value4\", ttl=1)  # 1秒后过期\n    print(cache.get(4))  # 应该输出 \"value4\"\n    time.sleep(1.1)  # 等待1.1秒\n    print(cache.get(4))  # 应该输出 None（已过期）\n    \n    # 测试线程安全\n    import concurrent.futures\n    \n    def test_thread_safe():\n        for i in range(10):\n            cache.put(i, f\"value{i}\")\n            cache.get(i)\n    \n    # 多线程测试\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        futures = [executor.submit(test_thread_safe) for _ in range(5)]\n        for future in futures:\n            future.result()\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 147.92750906944275
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom concurrent.futures import Future, TimeoutError\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        return self.priority.value < other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等操作。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._lock = threading.Lock()\n        self._running = False\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        self._running = True\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从任务队列获取任务，设置超时避免无限等待\n                task = ",
          "time_taken": 110.70291566848755
        }
      ],
      "elapsed_seconds": 182.2
    },
    {
      "round": 276,
      "timestamp": 1771145068.36704,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 277,
      "timestamp": 1771145068.849349,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 278,
      "timestamp": 1771145069.3238652,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 279,
      "timestamp": 1771145069.806158,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=54)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 280,
      "timestamp": 1771145696.364416,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率（大数值测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 302.83256697654724
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n        assert ",
          "time_taken": 315.9002859592438
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                value = float(self.expression[start:self.position])\n                self.tokens.append(Token(\"NUMBER\", value))\n                \n            elif char == '+':\n                self.tokens.append(Token(\"+\", char))\n                self.position += 1\n                \n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Parse the following number\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position ",
          "time_taken": 266.9131529331207
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, items: list[int], data: dict[str, int]) -> str:\n        return f\"x={x}, y={y}, items={i",
          "time_taken": 34.33288764953613
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Callable, Type, Tuple, Union, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为同步和异步函数添加自动重试功能\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay}s...\")\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. No more retries.\")\n                        raise\n            raise last_exception\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed wi",
          "time_taken": 277.6214642524719
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序和并发处理数据。\n    \"\"\"\n    \n    def __init__(self):\n        self._stages: Dict[str, Callable] = {}\n        self._stats: Dict[str, Dict[str, Any]] = defaultdict(\n            lambda: {\"calls\": 0, \"total_time\": 0.0, \"errors\": 0}\n        )\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self._stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self._stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self._stats[stage_name][\"calls\"] += 1\n            self._stats[stage_name][\"total_time\"] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self._stats[stage_name][\"calls\"] += 1\n            self._stats[stage_name][\"total_time\"] += (time.time() - start_time)\n            self._stats[stage_name][\"errors\"] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self._stages:\n            result = await self._process_stage(stage_name, result)\n        return result\n    \n ",
          "time_taken": 21.15227699279785
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\"\n    print(cache.get(\"b\"))  # Should return None\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 292.62338519096375
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    submitted_time: float = field(default_factory=time.time)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较\"\"\"\n        return self.priority < other.priority\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持任务提交、批量执行、优雅关闭等操作。\n    支持任务优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        self.max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，可用于获取任务结果或检查任务状态\n            \n        Raises:\n            RuntimeError: 当任务池已关闭时抛出\n        \"\"\"\n        if self._shutdown_event.is_set():\n            raise RuntimeError(\"TaskPool has been shut down\")\n        \n        future = Future()\n        task = Task(fn, args, kwargs, future, priority)\n        \n        with self._l",
          "time_taken": 394.93670678138733
        }
      ],
      "elapsed_seconds": 626.5
    },
    {
      "round": 281,
      "timestamp": 1771145743.784672,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future, TimeoutError\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"用于优先级队列比较 - 优先级高的任务排在前面\"\"\"\n        return self.priority.value > other.priority.value\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优雅关闭等操作。\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n            \n        Raises:\n            ValueError: 当max_workers小于等于0时抛出异常\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._lock = threading.Lock()\n        self._running = False\n        \n        # 启动工作线程\n        self._start_workers()\n    \n    def _start_workers(self):\n        \"\"\"启动工作线程\"\"\"\n        self._running = True\n        for i in range(self.max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self):\n        \"\"\"工作线程函数\"\"\"\n        while not self._shutdown_event.is_set():\n            try",
          "time_taken": 46.858100175857544
        }
      ],
      "elapsed_seconds": 47.3
    },
    {
      "round": 282,
      "timestamp": 1771145772.565632,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    priority: int = 0\n    timeout: Optional[float] = None\n    submitted_time: float = field(default_factory=time.time)\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    支持：\n    - 提交单个任务 (submit)\n    - 批量执行任务 (map)\n    - 优雅关闭 (shutdown)\n    - 任务超时控制\n    - 任务优先级\n    - 线程安全\n    \n    Example:\n        >>> pool = TaskPool(max_workers=4)\n        >>> future = pool.submit(print, \"Hello\", timeout=5.0, priority=1)\n        >>> result = future.result()\n        >>> pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._work_queue = queue.PriorityQueue()\n        self._threads: List[threading.Thread] = []\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._idle_semaphore = threading.Semaphore(0)\n        self._results: dict[str, Any] = {}\n        self._task_counter = 0\n        self._task_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, timeout: Optional[float] = None, \n               priority: int = 0, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            timeout: 任务超时时间（秒）\n            priority: 任务优先级（数值越小优先级越高）\n            **kwar",
          "time_taken": 28.135032176971436
        }
      ],
      "elapsed_seconds": 28.7
    },
    {
      "round": 283,
      "timestamp": 1771145804.498411,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPool-Worker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，可用于获取任务结果或取消任务\n        \"\"\"\n        if not self._running:\n            raise RuntimeError(\"TaskPool is shutdown\")\n            \n        task = Task(fn, args, kwargs, priority, timeout)\n        self._task_queue.put(task)\n        return task.future\n    \n    de",
          "time_taken": 29.743276119232178
        }
      ],
      "elapsed_seconds": 31.8
    },
    {
      "round": 284,
      "timestamp": 1771145804.9840808,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=55)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 285,
      "timestamp": 1771146431.0731819,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 282.5464918613434
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种分治算法，将数组递归地分成两半，分别排序后再合并。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序列表\n        right: 右侧已排序列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序结果: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 296.7210488319397
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[float, str]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                    self.position += 1\n                number_str = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", \"+\"))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in \"(+-*/\":\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Parse the following number\n                    while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n                        self.position += 1\n                    number_str = self.expression[start:self.position]\n                    self.tokens.append(Token(\"NUMBER\", float(number_str)))\n",
          "time_taken": 249.0057351589203
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    # 特殊处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 如果没有原始类型（普通类型如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（如 Optional[X] 等价于 Union[X, None]）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果有参数，检查每个元素\n        if args:\n            return all(_matches_type(v, args[0]) for v in value)\n        # 如果没有参数，只检查是否为 list\n        return isinstance(value, list)\n    \n    # 处理 dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果有参数，检查键值对\n        if args:\n            return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                      for k, v in value.items())\n        # 如果没有参数，只检查是否为 dict\n        return isinstance(value, dict)\n    \n    # 兜底情况\n    return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['ret",
          "time_taken": 41.128830909729004
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Union, Tuple, Any\n\n# 设置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[TypeVar, ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能\n    \n    Args:\n        max_retries: 最大重试次数（不包括首次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"Failed after {max_retries + 1} attempts. Last exception: {e}\")\n                        raise\n                    logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay} seconds...\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"Failed after {max_retries + 1} attempts. Last exception: {e}\")\n                        raise\n                    logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay} seconds...\")\n                    await async",
          "time_taken": 258.98743414878845
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concur",
          "time_taken": 22.520625352859497
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为2的LRU缓存\n    cache = LRUCache(2)\n    \n    # 测试基本功能\n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    print(cache.get(1))  # 应该返回 \"value1\"\n    \n    # 测试容量限制\n    cache.put(3, \"value3\")  # 应该删除key=2的项\n    print(cache.get(2))  # 应该返回 None\n    \n    # 测试TTL过期\n    cache.put(4, \"value4\", ttl=1)  # 1秒后过期\n    print(cache.get(4))  # 应该返回 \"value4\"\n    time.sleep(1.1)  # 等待过期\n    print(cache.get(4))  # 应该返回 None\n    \n    # 测试线程安全\n    import concurrent.futures\n    \n    def worker(thread_id):\n        for i in range(10):\n            cache.put(f\"{thread_id}-{i}\", f\"value-{thread_id}-{i}\")\n            cache.get(f\"{thread_id}-{i}\")\n    \n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        futures = [executor.submit(worker, i) for i in range(5)]\n        for future in futures:\n            future.result()\n    \n    print(\"Thread safety test completed\")\n",
          "time_taken": 272.53105211257935
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future, ThreadPoolExecutor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@dataclass\n@total_ordering\nclass Task:\n    \"\"\"任务数据类，支持优先级比较\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，数字越小优先级越高\"\"\"\n        if isinstance(other, Task):\n            return self.priority < other.priority\n        return NotImplemented\n    \n    def __hash__(self):\n        # 为Task类添加hash方法，使其可哈希\n        return id(self)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持任务优先级、超时控制等功能。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self._max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._worker_threads = []\n        \n        # 启动工作线程\n        if max_workers is not None:\n            for _ in range(max_workers):\n                thread = threading.Thread(target=self._worker_loop, daemon=True)\n                thread.start()\n                self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数位置参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"TaskPool has been sh",
          "time_taken": 376.50128412246704
        }
      ],
      "elapsed_seconds": 626.0
    },
    {
      "round": 286,
      "timestamp": 1771146465.193863,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    # 用于优先队列比较的唯一标识符，避免比较函数的不稳定性\n    _id: int = field(default_factory=lambda: time.time() * 1000000)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较，优先级数字越小越高\"\"\"\n        if self.priority == other.priority:\n            # 如果优先级相同，按提交时间排序（先进先出）\n            return self._id < other._id\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n            \n        Raises:\n            ValueError: 当max_workers小于等于0时抛出异常\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        self._shutdown_lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPool-Worker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            t",
          "time_taken": 33.5522518157959
        }
      ],
      "elapsed_seconds": 34.0
    },
    {
      "round": 287,
      "timestamp": 1771146910.710061,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future, ThreadPoolExecutor\nimport heapq\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(init=False)\n    \n    def __post_init__(self):\n        self.future = Future()\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self._max_workers = max_workers\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._shutdown_lock = threading.Lock()\n        self._shutdown = False\n        self._task_queue = queue.PriorityQueue()\n        self._task_counter = 0\n        self._worker_threads: List[threading.Thread] = []\n        \n        # 启动工作线程\n        self._start_worker_threads()\n    \n    def _start_worker_threads(self):\n        \"\"\"启动工作线程\"\"\"\n        if self._max_workers is None:\n            # 如果没有指定工作线程数，使用默认值\n            import multiprocessing\n            self._max_workers = multiprocessing.cpu_count()\n        \n        for i in range(self._max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def _worker_loop(self):\n        \"\"\"工作线程循环\"\"\"\n        while True:\n            try:\n                # 从任务队列获取任务\n                priority, task_id, task = self._task_queue.get(timeout=1.0)\n                \n                if self._shutdown and task_id == -1:  # 用于关闭信号\n                    break\n                \n                # 执行任务\n                try:\n                    if task.timeout:\n                        result = self._executor.submit(\n                            task.func, ",
          "time_taken": 361.87141275405884
        }
      ],
      "elapsed_seconds": 445.4
    },
    {
      "round": 288,
      "timestamp": 1771146941.206625,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import Future\nimport heapq\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    \n    def __lt__(self, other):\n        \"\"\"优先级比较\"\"\"\n        return self.priority < other.priority\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n            \n        Raises:\n            ValueError: 当max_workers小于等于0时抛出异常\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._workers = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPool-Worker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，可用于获取任务结果或取消任务\n            \n        Raises:\n            RuntimeError: 当任务池已关闭时抛出异常\n        \"\"\"\n        if not self._running:\n            raise RuntimeError(\"TaskPool is shutdown\")",
          "time_taken": 29.925156831741333
        }
      ],
      "elapsed_seconds": 30.4
    },
    {
      "round": 289,
      "timestamp": 1771146974.753813,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=56)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport concurrent.futures\nfrom typing import Callable, Any, List, Optional, Union\nfrom concurrent.futures import Future\nimport heapq\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass Priority(Enum):\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: Priority = Priority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    TaskPool 使用线程池来并发执行任务，支持任务优先级、超时控制和优雅关闭。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: Priority = Priority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数的关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Example:\n            >>> def my_task(x, y):\n            ...     return x + y\n            >>> future = task_pool.submit(my_task, 1, 2, priority=Priority.HIGH)\n            >>> result = ",
          "time_taken": 32.981592893600464
        }
      ],
      "elapsed_seconds": 33.5
    },
    {
      "round": 290,
      "timestamp": 1771147469.636854,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的效率问题\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 341.78762316703796
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分为两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [1, 1, 1, 1],          # 重复元素\n        [-3, -1, -4, -1, -5]   # 负数列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n     ",
          "time_taken": 354.21467995643616
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def consume(self) -> str:\n        char = self.peek()\n        self.position += 1\n        return char\n    \n    def is_digit(self, char: str) -> bool:\n        return char.isdigit()\n    \n    def is_operator(self, char: str) -> bool:\n        return char in '+-*/'\n    \n    def is_parenthesis(self, char: str) -> bool:\n        return char in '()'\n    \n    def is_whitespace(self, char: str) -> bool:\n        return char.isspace()\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.position = 0\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if self.is_whitespace(char):\n                self.consume()\n                continue\n            \n            if self.is_operator(char) or self.is_parenthesis(char):\n                self.tokens.append(Token(char, char))\n                self.consume()\n            elif self.is_digit(char) or char == '.':\n                # Parse number (including floats)\n                num_str = ''\n                while self.position < len(self.expression) and (self.is_digit(self.peek()) or self.peek() == '.'):\n                    num_str += self.consume()\n                self.tokens.append(Token('NUMBER', float(num_str)))\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n\nclass Parser:\n    def __init__(self, tokens: List[Token]):\n        self.toke",
          "time_taken": 305.3317623138428
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果是类型则检查类型，否则返回True\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"\n    运行时类型检查装饰器\n    \n    Args:\n        func: 要装饰的函数\n        \n    Returns:\n        带类型检查的包装函数\n    \"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    # 测试基本类型\n    @type_check\n    def a",
          "time_taken": 48.899057149887085
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Callable, Type, Tuple, Union, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，用于自动重试函数调用。\n    \n    Args:\n        max_retries: 最大重试次数（不包括首次调用）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay} seconds...\")\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. No more retries.\")\n            raise last_exception\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed with {ty",
          "time_taken": 316.08684396743774
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序和并发处理数据。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段的处理\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功执行的统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n        r",
          "time_taken": 23.645988941192627
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 331.9970769882202
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 207, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/concurrent/futures/_base.py\", line 447, in result\n    raise TimeoutError()\nconcurrent.futures._base.TimeoutError",
          "code_generated": "import threading\nimport queue\nimport time\nimport concurrent.futures\nfrom concurrent.futures import Future, Executor\nfrom typing import Callable, Any, List, Optional, Iterator\nfrom dataclasses import dataclass, field\nfrom collections import namedtuple\n\n# 定义任务优先级\nTaskPriority = namedtuple('TaskPriority', ['priority', 'timestamp'])\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timestamp: float = field(default_factory=time.time)\n    timeout: Optional[float] = None\n    \n    def __hash__(self):\n        return id(self)\n\nclass TaskPool(Executor):\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行任务、优雅关闭等操作\n    使用线程池实现并发执行\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，如果为None则使用默认值\n        \"\"\"\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._work_queue = queue.PriorityQueue()\n        self._threads: List[threading.Thread] = []\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._futures: set = set()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Raises:\n            RuntimeError: 如果任务池已关闭\n        \"\"\"\n        if self._shutdown:\n            raise RuntimeError(\"Cannot schedule new tasks after shutdown\")\n        \n        # 创建任务\n        task = Task(fn, args, kwa",
          "time_taken": 374.8715341091156
        }
      ],
      "elapsed_seconds": 494.8
    },
    {
      "round": 291,
      "timestamp": 1771147538.874272,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Union\nfrom concurrent.futures import Future, ThreadPoolExecutor\nimport heapq\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass Priority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: Priority = Priority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    # 用于优先级队列的唯一标识符\n    task_id: int = field(default_factory=lambda: int(time.time() * 1000000))\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    TaskPool 使用线程池来并发执行任务，支持任务优先级、超时控制和优雅关闭。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: Priority = Priority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数的关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Example:\n            >>> def my_task(x, y):\n            ...   ",
          "time_taken": 68.67635130882263
        }
      ],
      "elapsed_seconds": 69.1
    },
    {
      "round": 292,
      "timestamp": 1771179785.148492,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 210, in <module>\n  File \"<string>\", line 183, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'object' and 'object'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n# Sentinel object to signal worker shutdown\n_SHUTDOWN_SENTINEL = object()\n\n@total_ordering\n@dataclass\nclass Task:\n    priority: int\n    seq: int\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: ConcurrentFuture\n    \n    def __lt__(self, other):\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        return self.seq < other.seq\n\nclass Future(ConcurrentFuture):\n    \"\"\"Future object for TaskPool tasks\"\"\"\n    \n    def __init__(self, task: Task):\n        super().__init__()\n        self._task = task\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        Return the result of the task.\n        \n        Args:\n            timeout: The number of seconds to wait for the result.\n            \n        Returns:\n            The result of the task.\n            \n        Raises:\n            Exception: If the task raised an exception, it will be re-raised.\n        \"\"\"\n        try:\n            return super().result(timeout)\n        except Exception as e:\n            # If the task raised an exception, re-raise it\n            if hasattr(self._task, '_exception') and self._task._exception is not None:\n                raise self._task._exception\n            raise\n\nclass TaskPool:\n    \"\"\"A thread pool for executing tasks concurrently.\"\"\"\n    \n    def __init__(self, max_workers: int = 4, timeout: Optional[float] = None):\n        \"\"\"\n        Initialize the TaskPool.\n        \n        Args:\n            max_workers: The maximum number of worker threads.\n            timeout: The default timeout for tasks.\n        \"\"\"\n        self.max_workers = max_workers\n        self.timeout = timeout\n        self._tasks = queue.PriorityQueue()\n        self._workers: List[threading.Thread] = []",
          "time_taken": 75.65063571929932
        }
      ],
      "elapsed_seconds": 242.5
    },
    {
      "round": 293,
      "timestamp": 1771179820.34641,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Union\nfrom concurrent.futures import Future\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass Priority(Enum):\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: Priority = Priority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    TaskPool 使用线程池来并发执行任务，支持任务优先级、超时控制和优雅关闭。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._running = True\n        self._task_queue = queue.PriorityQueue()\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        self._shutdown_lock = threading.Lock()\n        \n        # 使用唯一的sentinel来关闭worker\n        self._sentinel = object()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: Priority = Priority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数的关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Example:\n            >>> def my_task(x, y):\n            ...     return x + y\n            >>> future = task_pool.submit(my_task, 1, 2, priority=Priority.HIGH)\n            >>> result = future.re",
          "time_taken": 34.63538694381714
        }
      ],
      "elapsed_seconds": 35.1
    },
    {
      "round": 294,
      "timestamp": 1771180061.258975,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=57)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 235, in <module>\n  File \"<string>\", line 185, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'object' and 'object'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    priority: int\n    seq: int\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: 'Future'\n    \n    def __lt__(self, other):\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        return self.seq < other.seq\n\nclass Future(ConcurrentFuture):\n    \"\"\"包装 concurrent.futures.Future 以提供更好的异常处理\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._lock = threading.Lock()\n    \n    def set_result(self, result):\n        with self._lock:\n            if not self._done:\n                self._result = result\n                self._done = True\n                super().set_result(result)\n    \n    def set_exception(self, exception):\n        with self._lock:\n            if not self._done:\n                self._exception = exception\n                self._done = True\n                super().set_exception(exception)\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务异常则重新抛出原始异常\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n        \"\"\"\n        try:\n            # 先检查是否已完成\n            if self._done:\n                if self._exception:\n                    raise self._exception\n                return self._result\n            \n            # 等待任务完成\n            super().result(timeout)\n            \n            # 重新检查异常\n            if self._exception:\n                raise self._exception\n            return self._result\n            \n        except Exception as e:\n            if isinstance(e, TimeoutErr",
          "time_taken": 73.52409720420837
        }
      ],
      "elapsed_seconds": 240.8
    },
    {
      "round": 295,
      "timestamp": 1771180193.1770382,
      "passed": 8,
      "total": 8,
      "avg_score": 8.69,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率：大数测试\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 113.82249593734741
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法，时间复杂度为 O(n log n)。\n    该函数是纯函数，不会修改输入列表，而是返回一个新的已排序列表。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，保持原有元素的相对顺序（稳定排序）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 一般情况\n        [5, 2, 8, 1],          # 小列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  输入: {orig",
          "time_taken": 129.628582239151
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                self.tokens.append(Token('MINUS', char))\n                self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n            self.expression[self.position].isdigit() or \n            self.expression[self.position] == '.'\n        ):\n            self.position += 1\n        number_str = self.expression[start:self.position]\n        try:\n            if '.' in number_str:\n                number = float(numbe",
          "time_taken": 80.75248694419861
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Union\nfrom concurrent.futures import Future\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass Priority(Enum):\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: Priority = Priority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    TaskPool 使用线程池来并发执行任务，支持任务优先级、超时控制和优雅关闭。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._running = True\n        self._task_queue = queue.PriorityQueue()\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        self._shutdown_lock = threading.Lock()\n        \n        # 使用唯一sentinel对象关闭worker\n        self._sentinel = object()\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: Priority = Priority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数的关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Example:\n            >>> def my_task(x, y):\n            ...     return x + y\n            >>> future = task_pool.submit(my_task, 1, 2, priority=Priority.HIGH)\n            >>> result = future.re",
          "time_taken": 60.489447832107544
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: x}\n    \n    # 正确的调用\n    t",
          "time_taken": 34.033003091812134
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Tuple, Union, Any\n\n# 设置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[TypeVar('E'), ...] = (Exception,)\n) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟倍数因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 在第 {attempt + 1} 次尝试后抛出异常: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1} 次尝试失败: {e}\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n                    \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 在第 {attempt + 1} 次尝试后抛出异常: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1} 次尝试失败: {e}\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n           ",
          "time_taken": 91.10637092590332
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（同步或异步）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段并记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_fn = self.stages[stage_name]\n        is_coroutine = asyncio.iscoroutinefunction(stage_fn)\n        \n        try:\n            if is_coroutine:\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n        finally:\n            end_time = time.time()\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (end_time - start_time)\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        \"\"\"\n  ",
          "time_taken": 21.88762593269348
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (new entry)\n",
          "time_taken": 103.4997329711914
        }
      ],
      "elapsed_seconds": 131.8
    },
    {
      "round": 296,
      "timestamp": 1771180510.722199,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 235, in <module>\n  File \"<string>\", line 202, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'object' and 'object'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n# 唯一的sentinel对象，用于关闭worker\n_SENTINEL = object()\n\n@total_ordering\n@dataclass\nclass _Task:\n    priority: int\n    seq: int\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    future: 'Future'\n    \n    def __lt__(self, other):\n        if isinstance(other, _Task):\n            return (self.priority, self.seq) < (other.priority, other.seq)\n        return NotImplemented\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    代表一个异步任务的未来结果。\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: BaseException) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务异常则重新抛出原始异常。\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 如果任务执行时抛出异常，则重新抛出原始异常\n            TimeoutError: 如果超时\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现。\n    \n    Examples:\n        >>> pool = T",
          "time_taken": 157.94494080543518
        }
      ],
      "elapsed_seconds": 317.4
    },
    {
      "round": 297,
      "timestamp": 1771180538.357356,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Union\nfrom concurrent.futures import Future\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport heapq\n\nclass Priority(Enum):\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: Priority = Priority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    TaskPool 使用线程池来并发执行任务，支持任务优先级、超时控制和优雅关闭。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        self._shutdown_lock = threading.Lock()\n        self._sentinel = object()  # 唯一的sentinel对象，避免None的比较问题\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: Priority = Priority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数的关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Example:\n            >>> def my_task(x, y):\n            ...     return x + y\n            >>> future = task_pool.submit(my_task, 1, 2, priority=Priority.HIGH)\n            >>> result = future.re",
          "time_taken": 27.08984923362732
        }
      ],
      "elapsed_seconds": 27.5
    },
    {
      "round": 298,
      "timestamp": 1771180758.826196,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 196, in <module>\n  File \"<string>\", line 59, in result\n  File \"<string>\", line 53, in result\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/concurrent/futures/_base.py\", line 447, in result\n    raise TimeoutError()\nconcurrent.futures._base.TimeoutError",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom functools import total_ordering\n\n# 全局唯一sentinel对象，用于关闭worker\n_SENTINEL = object()\n\n@total_ordering\nclass _TaskItem:\n    \"\"\"任务项，用于优先队列排序\"\"\"\n    def __init__(self, priority: int, seq: int, payload: Tuple[Callable, tuple, dict]):\n        self.priority = priority\n        self.seq = seq\n        self.payload = payload\n    \n    def __lt__(self, other):\n        if isinstance(other, _TaskItem):\n            if self.priority == other.priority:\n                return self.seq < other.seq\n            return self.priority < other.priority\n        return NotImplemented\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务执行结果的包装类\"\"\"\n    def __init__(self, fn: Callable, args: tuple, kwargs: dict):\n        super().__init__()\n        self._fn = fn\n        self._args = args\n        self._kwargs = kwargs\n        self._result = None\n        self._exception = None\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务执行结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 如果任务执行过程中抛出异常，则重新抛出原始异常\n        \"\"\"\n        try:\n            # 等待任务完成\n            result = super().result(timeout)\n            return result\n        except Exception as e:\n            # 如果任务执行失败，重新抛出原始异常\n            if self._exception is not None:\n                raise self._exception\n            raise e\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现并发执行任务\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._work_queue = queue.PriorityQueue()\n        self._workers = set()\n        ",
          "time_taken": 82.41642117500305
        }
      ],
      "elapsed_seconds": 220.4
    },
    {
      "round": 299,
      "timestamp": 1771180787.2437482,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=58)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Union\nfrom concurrent.futures import Future\nimport heapq\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass Priority(Enum):\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: Priority = Priority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    TaskPool 使用线程池来并发执行任务，支持任务优先级、超时控制和优雅关闭。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        self._shutdown_lock = threading.Lock()\n        self._sentinel = object()  # 唯一的sentinel对象用于关闭worker\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: Priority = Priority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数的关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Example:\n            >>> def my_task(x, y):\n            ...     return x + y\n            >>> future = task_pool.submit(my_task, 1, 2, priority=Priority.HIGH)\n            >>> result = future.resu",
          "time_taken": 27.87064790725708
        }
      ],
      "elapsed_seconds": 28.3
    },
    {
      "round": 300,
      "timestamp": 1771189554.681547,
      "passed": 6,
      "total": 8,
      "avg_score": 7.56,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 从第3个数开始计算（索引为2）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 100.07136368751526
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 152, in <module>\n  File \"<string>\", line 142, in evaluate\n  File \"<string>\", line 33, in tokenize\n  File \"<string>\", line 59, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n\n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative number\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n\n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (self.expression[self.position].isdigit() or self.expression[self.position] == '.'):\n            se",
          "time_taken": 84.4679548740387
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的排序算法，采用分治法策略。\n    将数组递归地分成两半，分别排序后合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保纯函数特性\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 117.03272223472595
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass\nfrom threading import Thread, Event, Condition, Lock\nfrom queue import PriorityQueue, Empty\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple\nimport itertools\n\n@dataclass\nclass _FutureState:\n    done: bool = False\n    result: Any = None\n    error: Optional[BaseException] = None\n\nclass Future:\n    def __init__(self) -> None:\n        self._state = _FutureState()\n        self._cv = Condition()\n    \n    def set_result(self, value: Any) -> None:\n        with self._cv:\n            self._state.result = value\n            self._state.done = True\n            self._cv.notify_all()\n    \n    def set_exception(self, err: BaseException) -> None:\n        with self._cv:\n            self._state.error = err\n            self._state.done = True\n            self._cv.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        with self._cv:\n            self._cv.wait(timeout)\n            if not self._state.done:\n                raise TimeoutError(\"Result is not ready\")\n            if self._state.error is not None:\n                raise self._state.error\n            return self._state.result\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        self._q: PriorityQueue[Tuple[int, int, str, Any]] = PriorityQueue()\n        self._seq = itertools.count()\n        self._shutdown = Event()\n        self._workers: List[Thread] = []\n        self._lock = Lock()\n        \n        # Start workers\n        for _ in range(max_workers):\n            t = Thread(target=self._worker, daemon=True)\n            t.start()\n            self._workers.append(t)\n    \n    def _worker(self) -> None:\n        while not self._shutdown.is_set():\n            try:\n                # Use timeout to allow shutdown checking\n                item = self._q.get(timeout=1.0)\n                priority, seq, kind, payload = item\n                \n                if kind == 'stop':\n                    # Worker stop signal\n                    break\n  ",
          "time_taken": 209.25482559204102
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, z: typing.Optional[typing.List[int]] = None) -> str:\n        return f\"x={x}, y={y}, z={z}\"",
          "time_taken": 32.38509273529053
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Type, Union, Awaitable\n\n# 设置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，用于自动重试函数调用\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次调用）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 抛出异常 {type(e).__name__}: {e}\")\n                        raise\n                    logger.warning(f\"第 {attempt + 1}/{max_retries} 次尝试失败: {type(e).__name__}: {e}\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            \n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 抛出异常 {type(e).__name__}: {e}\")\n                        raise\n                    logger.warning(f\"第 {attempt + 1}/{max_retries} 次尝试失败: {type(e).__name__}: {e}\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n        \n        # 判",
          "time_taken": 75.20179080963135
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持按顺序执行阶段和并发处理批次数据。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是异步或同步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段的处理。\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['errors'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any]",
          "time_taken": 20.290446043014526
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"one\")\n    cache.put(2, \"two\")\n    print(cache.get(1))  # Should return \"one\"\n    \n    cache.put(3, \"three\")  # This should evict key 2\n    print(cache.get(2))  # Should return None\n    \n    # Test TTL functionality\n    cache.put(4, \"four\", ttl=1)  # Expires in 1 second\n    print(cache.get(4))  # Should return \"four\"\n    \n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(4))  # Should return None\n    \n    # Test LRU behavior\n    cache.put(5, \"five\")\n    cache.put(6, \"six\")\n    print(cache.get(5))  # Should return None (evicted due to LRU)\n    print(cache.get(6))  # Should return \"six\"\n",
          "time_taken": 89.95680689811707
        }
      ],
      "elapsed_seconds": 516.7
    },
    {
      "round": 301,
      "timestamp": 1771190010.7113972,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass\nfrom threading import Thread, Event, Condition, Lock\nfrom queue import PriorityQueue, Empty\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple\nimport itertools\n\n@dataclass\nclass _FutureState:\n    done: bool = False\n    result: Any = None\n    error: Optional[BaseException] = None\n\nclass Future:\n    def __init__(self) -> None:\n        self._state = _FutureState()\n        self._cv = Condition()\n    \n    def set_result(self, value: Any) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.result = value\n            self._cv.notify_all()\n    \n    def set_exception(self, err: BaseException) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.error = err\n            self._cv.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        with self._cv:\n            self._cv.wait(timeout)\n            if not self._state.done:\n                raise TimeoutError(\"Future timed out\")\n            if self._state.error is not None:\n                raise self._state.error\n            return self._state.result\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        self._q: PriorityQueue[Tuple[int, int, str, Any]] = PriorityQueue()\n        self._seq = itertools.count()\n        self._shutdown = Event()\n        self._workers: List[Thread] = []\n        self._lock = Lock()\n        \n        # Start workers\n        for _ in range(max_workers):\n            t = Thread(target=self._worker, daemon=True)\n            t.start()\n            self._workers.append(t)\n    \n    def _worker(self) -> None:\n        while not self._shutdown.is_set():\n            try:\n                # Use timeout to periodically check shutdown event\n                item = self._q.get(timeout=1.0)\n                priority, seq, kind, payload = item\n                \n                if kind == 'stop':\n                    break\n                \n                # P",
          "time_taken": 175.28524017333984
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 183, in <module>\n  File \"<string>\", line 171, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 64, in _read_number\nValueError: Invalid number",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 76.20601606369019
        }
      ],
      "elapsed_seconds": 456.0
    },
    {
      "round": 302,
      "timestamp": 1771190408.766054,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass\nfrom threading import Thread, Event, Condition, Lock\nfrom queue import PriorityQueue, Empty\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple\nimport itertools\n\n@dataclass\nclass _FutureState:\n    done: bool = False\n    result: Any = None\n    error: Optional[BaseException] = None\n\nclass Future:\n    def __init__(self) -> None:\n        self._state = _FutureState()\n        self._cv = Condition()\n    \n    def set_result(self, value: Any) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.result = value\n            self._cv.notify_all()\n    \n    def set_exception(self, err: BaseException) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.error = err\n            self._cv.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        with self._cv:\n            self._cv.wait(timeout)\n            if not self._state.done:\n                raise TimeoutError(\"Future result timeout\")\n            if self._state.error:\n                raise self._state.error\n            return self._state.result\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        self._q: PriorityQueue[Tuple[int, int, str, Any]] = PriorityQueue()\n        self._seq = itertools.count()\n        self._shutdown = Event()\n        self._workers: List[Thread] = []\n        self._lock = Lock()\n        \n        # start workers\n        for _ in range(max_workers):\n            worker = Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self) -> None:\n        # item = (priority, seq, kind, payload)\n        # if kind == 'stop': break\n        # else payload = (fn, args, kwargs, future)\n        while not self._shutdown.is_set():\n            try:\n                item = self._q.get(timeout=1.0)\n                priority, seq, kind, payload = item\n                \n                if ki",
          "time_taken": 178.6853392124176
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 72, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 188, in <module>\n  File \"<string>\", line 176, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 75, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 70.45906400680542
        }
      ],
      "elapsed_seconds": 397.9
    },
    {
      "round": 303,
      "timestamp": 1771190902.3084002,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass\nfrom threading import Thread, Event, Condition, Lock\nfrom queue import PriorityQueue, Empty\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple\nimport itertools\n\n@dataclass\nclass _FutureState:\n    done: bool = False\n    result: Any = None\n    error: Optional[BaseException] = None\n\nclass Future:\n    def __init__(self) -> None:\n        self._state = _FutureState()\n        self._cv = Condition()\n    \n    def set_result(self, value: Any) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.result = value\n            self._cv.notify_all()\n    \n    def set_exception(self, err: BaseException) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.error = err\n            self._cv.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        with self._cv:\n            self._cv.wait(timeout)\n            if not self._state.done:\n                raise TimeoutError(\"Future did not complete within the given timeout\")\n            if self._state.error is not None:\n                raise self._state.error\n            return self._state.result\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        self._q: PriorityQueue[Tuple[int, int, str, Any]] = PriorityQueue()\n        self._seq = itertools.count()\n        self._shutdown = Event()\n        self._workers: List[Thread] = []\n        self._lock = Lock()\n        \n        # Start workers\n        for _ in range(max_workers):\n            worker = Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _worker(self) -> None:\n        while not self._shutdown.is_set():\n            try:\n                # Wait for a task with timeout to allow shutdown checking\n                item = self._q.get(timeout=1.0)\n                priority, seq, kind, payload = item\n                \n                if kind == 'stop':\n        ",
          "time_taken": 193.1821973323822
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 68, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 184, in <module>\n  File \"<string>\", line 172, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 71, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 73.2058732509613
        }
      ],
      "elapsed_seconds": 493.4
    },
    {
      "round": 304,
      "timestamp": 1771191370.5977879,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=59)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass\nfrom threading import Thread, Event, Condition, Lock\nfrom queue import PriorityQueue, Empty\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple\nimport itertools\n\n@dataclass\nclass _FutureState:\n    done: bool = False\n    result: Any = None\n    error: Optional[BaseException] = None\n\nclass Future:\n    def __init__(self) -> None:\n        self._state = _FutureState()\n        self._cv = Condition()\n    \n    def set_result(self, value: Any) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.result = value\n            self._cv.notify_all()\n    \n    def set_exception(self, err: BaseException) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.error = err\n            self._cv.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        with self._cv:\n            self._cv.wait(timeout)\n            if not self._state.done:\n                raise TimeoutError(\"Future result timed out\")\n            if self._state.error is not None:\n                raise self._state.error\n            return self._state.result\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        self._q: PriorityQueue[Tuple[int, int, str, Any]] = PriorityQueue()\n        self._seq = itertools.count()\n        self._shutdown = Event()\n        self._workers: List[Thread] = []\n        self._lock = Lock()\n        \n        # Start workers\n        for _ in range(max_workers):\n            thread = Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._workers.append(thread)\n    \n    def _worker(self) -> None:\n        while not self._shutdown.is_set():\n            try:\n                # Get task from queue with timeout\n                item = self._q.get(timeout=1.0)\n                priority, seq, kind, payload = item\n                \n                if kind == 'stop':\n                    # Stop signal received\n             ",
          "time_taken": 178.75974106788635
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 186, in <module>\n  File \"<string>\", line 174, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 64, in _read_number\nValueError: Invalid number",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 81.15201091766357
        }
      ],
      "elapsed_seconds": 468.2
    },
    {
      "round": 305,
      "timestamp": 1771192160.3948421,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 164.29524421691895
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Optional\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以保证纯函数特性\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两部分\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两部分\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [1, 1, 1, 1],          # 重复元素\n        [-3, -1, -4, -1, -5]   # 负数列表\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == orig",
          "time_taken": 177.75479865074158
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass\nfrom threading import Thread, Event, Condition, Lock\nfrom queue import PriorityQueue, Empty\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple\nimport itertools\n\n@dataclass\nclass _FutureState:\n    done: bool = False\n    result: Any = None\n    error: Optional[BaseException] = None\n\nclass Future:\n    def __init__(self) -> None:\n        self._state = _FutureState()\n        self._cv = Condition()\n    \n    def set_result(self, value: Any) -> None:\n        with self._cv:\n            self._state.result = value\n            self._state.done = True\n            self._state.error = None\n            self._cv.notify_all()\n    \n    def set_exception(self, err: BaseException) -> None:\n        with self._cv:\n            self._state.error = err\n            self._state.done = True\n            self._cv.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        with self._cv:\n            if not self._cv.wait(timeout):\n                raise TimeoutError(\"Result is not ready\")\n            if self._state.error is not None:\n                raise self._state.error\n            return self._state.result\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        self._q: PriorityQueue[Tuple[int, int, str, Any]] = PriorityQueue()\n        self._seq = itertools.count()\n        self._shutdown = Event()\n        self._workers: List[Thread] = []\n        self._lock = Lock()\n        \n        # Start workers\n        for _ in range(max_workers):\n            thread = Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._workers.append(thread)\n    \n    def _worker(self) -> None:\n        while not self._shutdown.is_set():\n            try:\n                # Use timeout to periodically check shutdown event\n                item = self._q.get(timeout=1.0)\n                priority, seq, kind, payload = item\n                \n                if kind == 'stop':\n                    break\n          ",
          "time_taken": 260.33976221084595
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 185, in <module>\n  File \"<string>\", line 173, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 63, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 151.55115389823914
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, items: list[int], mapping: dict[str, int]) -> str:\n        return f\"{x}: {y}: {item",
          "time_taken": 83.1168303489685
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Type, Union, Awaitable\n\n# 设置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能\n    \n    Args:\n        max_retries: 最大重试次数（不包括首次执行）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 重试 {max_retries} 次后仍然失败，异常: {e}\")\n                        raise\n                    logger.warning(f\"第 {attempt + 1}/{max_retries} 次尝试失败: {func.__name__} 异常: {e}\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n                    \n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 重试 {max_retries} 次后仍然失败，异常: {e}\")\n                        raise\n                    logger.warning(f\"第 {attempt + 1}/{max_retries} 次尝试失败: {func.__name__} 异常: {e}\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= back",
          "time_taken": 140.39474487304688
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持添加处理阶段、顺序执行和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(",
          "time_taken": 69.93958616256714
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 153.14374899864197
        }
      ],
      "elapsed_seconds": 789.7
    },
    {
      "round": 306,
      "timestamp": 1771192631.068903,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass\nfrom threading import Thread, Event, Condition, Lock\nfrom queue import PriorityQueue, Empty\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple\nimport itertools\n\n@dataclass\nclass _FutureState:\n    done: bool = False\n    result: Any = None\n    error: Optional[BaseException] = None\n\nclass Future:\n    def __init__(self) -> None:\n        self._state = _FutureState()\n        self._cv = Condition()\n    \n    def set_result(self, value: Any) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.result = value\n            self._cv.notify_all()\n    \n    def set_exception(self, err: BaseException) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.error = err\n            self._cv.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        with self._cv:\n            self._cv.wait(timeout)\n            if not self._state.done:\n                raise TimeoutError(\"Future result timed out\")\n            if self._state.error:\n                raise self._state.error\n            return self._state.result\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        self._q: PriorityQueue[Tuple[int, int, str, Any]] = PriorityQueue()\n        self._seq = itertools.count()\n        self._shutdown = Event()\n        self._workers: List[Thread] = []\n        self._lock = Lock()\n        \n        # Start workers\n        for _ in range(max_workers):\n            thread = Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._workers.append(thread)\n    \n    def _worker(self) -> None:\n        while not self._shutdown.is_set():\n            try:\n                # Get task from queue with timeout to allow shutdown checking\n                item = self._q.get(timeout=1.0)\n                priority, seq, kind, payload = item\n                \n                if kind == 'stop':\n                    break\n               ",
          "time_taken": 178.86768698692322
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 69, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 185, in <module>\n  File \"<string>\", line 173, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 72, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 69.43008518218994
        }
      ],
      "elapsed_seconds": 470.6
    },
    {
      "round": 307,
      "timestamp": 1771193227.1063669,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass\nfrom threading import Thread, Event, Condition, Lock\nfrom queue import PriorityQueue, Empty\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple\nimport itertools\n\n@dataclass\nclass _FutureState:\n    done: bool = False\n    result: Any = None\n    error: Optional[BaseException] = None\n\nclass Future:\n    def __init__(self) -> None:\n        self._state = _FutureState()\n        self._cv = Condition()\n    \n    def set_result(self, value: Any) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.result = value\n            self._cv.notify_all()\n    \n    def set_exception(self, err: BaseException) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.error = err\n            self._cv.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        with self._cv:\n            self._cv.wait(timeout)\n            if not self._state.done:\n                raise TimeoutError(\"Result is not available\")\n            if self._state.error is not None:\n                raise self._state.error\n            return self._state.result\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        self._q: PriorityQueue[Tuple[int, int, str, Any]] = PriorityQueue()\n        self._seq = itertools.count()\n        self._shutdown = Event()\n        self._workers: List[Thread] = []\n        self._lock = Lock()\n        \n        # Start workers\n        for _ in range(max_workers):\n            t = Thread(target=self._worker, daemon=True)\n            t.start()\n            self._workers.append(t)\n    \n    def _worker(self) -> None:\n        # item = (priority, seq, kind, payload)\n        # if kind == 'stop': break\n        # else payload = (fn, args, kwargs, future)\n        while not self._shutdown.is_set():\n            try:\n                # Use a small timeout to check shutdown flag regularly\n                item = self._q.get(timeout=0.1)\n                prio",
          "time_taken": 200.94106197357178
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 69, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 185, in <module>\n  File \"<string>\", line 173, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 72, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 81.67627286911011
        }
      ],
      "elapsed_seconds": 595.9
    },
    {
      "round": 308,
      "timestamp": 1771193816.827617,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass\nfrom threading import Thread, Event, Condition, Lock\nfrom queue import PriorityQueue, Empty\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple\nimport itertools\n\n@dataclass\nclass _FutureState:\n    done: bool = False\n    result: Any = None\n    error: Optional[BaseException] = None\n\nclass Future:\n    def __init__(self) -> None:\n        self._state = _FutureState()\n        self._cv = Condition()\n    \n    def set_result(self, value: Any) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.result = value\n            self._cv.notify_all()\n    \n    def set_exception(self, err: BaseException) -> None:\n        with self._cv:\n            self._state.done = True\n            self._state.error = err\n            self._cv.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        with self._cv:\n            self._cv.wait(timeout)\n            if not self._state.done:\n                raise TimeoutError(\"Result is not ready\")\n            if self._state.error is not None:\n                raise self._state.error\n            return self._state.result\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        self._q: PriorityQueue[Tuple[int, int, str, Any]] = PriorityQueue()\n        self._seq = itertools.count()\n        self._shutdown = Event()\n        self._workers: List[Thread] = []\n        self._lock = Lock()\n        \n        # start workers\n        for _ in range(max_workers):\n            thread = Thread(target=self._worker, daemon=True)\n            thread.start()\n            self._workers.append(thread)\n    \n    def _worker(self) -> None:\n        # item = (priority, seq, kind, payload)\n        # if kind == 'stop': break\n        # else payload = (fn, args, kwargs, future)\n        while not self._shutdown.is_set():\n            try:\n                item = self._q.get(timeout=1.0)\n                priority, seq, kind, payload = item\n                \n           ",
          "time_taken": 196.41598081588745
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 72, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 191, in <module>\n  File \"<string>\", line 179, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 75, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 80.7378249168396
        }
      ],
      "elapsed_seconds": 589.6
    },
    {
      "round": 309,
      "timestamp": 1771194260.10721,
      "passed": 6,
      "total": 8,
      "avg_score": 7.5,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=60)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 4.0,
          "error": "Execution timed out (60s)",
          "code_generated": "from dataclasses import dataclass\nfrom threading import Thread, Event, Condition, Lock\nfrom queue import PriorityQueue, Empty\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple\nimport itertools\n\n@dataclass\nclass _FutureState:\n    done: bool = False\n    result: Any = None\n    error: Optional[BaseException] = None\n\nclass Future:\n    def __init__(self) -> None:\n        self._state = _FutureState()\n        self._cv = Condition()\n    \n    def set_result(self, value: Any) -> None:\n        with self._cv:\n            self._state.result = value\n            self._state.done = True\n            self._state.error = None\n            self._cv.notify_all()\n    \n    def set_exception(self, err: BaseException) -> None:\n        with self._cv:\n            self._state.error = err\n            self._state.done = True\n            self._cv.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        with self._cv:\n            if not self._cv.wait(timeout):\n                raise TimeoutError(\"Result is not ready\")\n            if self._state.error is not None:\n                raise self._state.error\n            return self._state.result\n\nclass TaskPool:\n    def __init__(self, max_workers: int = 4):\n        self._q: PriorityQueue[Tuple[int, int, str, Any]] = PriorityQueue()\n        self._seq = itertools.count()\n        self._shutdown = Event()\n        self._workers: List[Thread] = []\n        self._lock = Lock()\n        \n        # Start workers\n        for _ in range(max_workers):\n            t = Thread(target=self._worker, daemon=True)\n            t.start()\n            self._workers.append(t)\n    \n    def _worker(self) -> None:\n        while not self._shutdown.is_set():\n            try:\n                # Use timeout to periodically check if shutdown was called\n                item = self._q.get(timeout=1.0)\n                priority, seq, kind, payload = item\n                \n                if kind == 'stop':\n                    break\n                \n",
          "time_taken": 176.0970480442047
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 185, in <module>\n  File \"<string>\", line 173, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 64, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 67.24503493309021
        }
      ],
      "elapsed_seconds": 443.2
    },
    {
      "round": 310,
      "timestamp": 1771200168.3373592,
      "passed": 8,
      "total": 8,
      "avg_score": 8.69,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证边界情况\n    assert fibonacci(0) == []\n    assert fibonacci(1) == [0]\n    assert fibonacci(5) == [0, 1, 1, 2, 3]\n    assert fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    print(\"所有测试通过!\")\n",
          "time_taken": 155.55668306350708
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组递归地分成两半，分别排序后合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保纯函数特性\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {test_case} -> {sorted_result}\")\n    \n    # 验证原列表未被修改\n    original = [3, 1, 4, 1, 5]\n    merged = merge_sort(original)\n    p",
          "time_taken": 169.5885157585144
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus (at start or after '(')\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n            self.expression[self.position].isdigit() o",
          "time_taken": 120.25693893432617
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        if isinstance(expected_type, type):\n            return isinstance(value, expected_type)\n        return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, scores: list[int], info: dict[str, int]) -> str:\n        return",
          "time_taken": 33.89500904083252
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Type, TypeVar, Union, Callable, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay}s...\")\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. No more retries.\")\n                        raise\n            \n            raise last_exception\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n          ",
          "time_taken": 131.3614239692688
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Union\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序和并发处理数据。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            return result\n            \n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序处理所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n      ",
          "time_taken": 21.12315082550049
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\"\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 145.71072483062744
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Union\nfrom concurrent.futures import Future, ThreadPoolExecutor\nimport heapq\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass Priority(Enum):\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: Priority = Priority.NORMAL\n    timeout: Optional[float] = None\n    future: Future = field(default_factory=Future)\n    submit_time: float = field(default_factory=time.time)\n    # 用于优先级队列的唯一标识符，避免比较对象\n    task_id: int = field(default_factory=lambda: int(time.time() * 1000000))\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    TaskPool 使用线程池来并发执行任务，支持任务优先级、超时控制和优雅关闭。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_workers: Optional[int] = None):\n        self.max_workers = max_workers or min(32, (threading.active_count() or 1) + 4)\n        self._executor = None\n        self._task_queue = queue.PriorityQueue()\n        self._running = True\n        self._worker_threads: List[threading.Thread] = []\n        self._lock = threading.Lock()\n        self._task_counter = 0\n        \n        # 创建线程池执行器\n        self._executor = ThreadPoolExecutor(max_workers=self.max_workers)\n        \n        # 启动工作线程\n        for _ in range(self.max_workers):\n            thread = threading.Thread(target=self._worker_loop, daemon=True)\n            thread.start()\n            self._worker_threads.append(thread)\n    \n    def submit(self, fn: Callable, *args, priority: Priority = Priority.NORMAL, \n               timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数的参数\n            priority: 任务优先级，默认为NORMAL\n            timeout: 任务超时时间（秒），None表示无超时\n            **kwargs: 函数的关键字参数\n            \n        Returns:\n            Future对象，用于获取任务结果\n            \n        Example:\n      ",
          "time_taken": 98.97007012367249
        }
      ],
      "elapsed_seconds": 172.7
    },
    {
      "round": 311,
      "timestamp": 1771200410.315219,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 61, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 158, in <module>\n  File \"<string>\", line 148, in evaluate\n  File \"<string>\", line 32, in tokenize\n  File \"<string>\", line 64, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                tokens.append(self._read_number())\n            elif char == '+':\n                tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative number\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    tokens.append(self._read_number())\n                else:\n                    tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return tokens\n    \n    def _read_number(self) -> Token:\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n            self.pos += 1\n        number_str = self.expression[start:self.pos]\n        try:\n            if '.",
          "time_taken": 69.0190680027008
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务数据结构，支持优先级比较\"\"\"\n    priority: int\n    task_id: int\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float] = None\n    \n    def __lt__(self, other):\n        # 优先级高的任务排在前面\n        if self.priority != other.priority:\n            return self.priority > other.priority\n        # 优先级相同时，按任务ID排序（保证可比较）\n        return self.task_id < other.task_id\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务结果的Future对象\"\"\"\n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n        self._result = None\n        self._exception = None\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 如果任务执行失败，抛出原始异常\n        \"\"\"\n        # 等待任务完成\n        if not self.done():\n            # 这里简化处理，实际应该使用条件变量等待\n            start_time = time.time()\n            while not self.done():\n                if timeout is not None and time.time() - start_time > timeout:\n                    raise TimeoutError(\"Task timed out\")\n                time.sleep(0.001)  # 短暂休眠避免忙等\n        \n        if self._exception:\n            raise self._exception\n        return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭等操作。\n    使用线程池执行任务，支持优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._result_map: dict[int, Future",
          "time_taken": 33.70005679130554
        }
      ],
      "elapsed_seconds": 241.9
    },
    {
      "round": 312,
      "timestamp": 1771200741.464585,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 69, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 188, in <module>\n  File \"<string>\", line 176, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 72, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 73.32362604141235
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 230, in <module>\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务包装类，用于支持优先级和比较\"\"\"\n    priority: int\n    task_id: int\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float] = None\n    \n    def __eq__(self, other):\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority == other.priority and self.task_id == other.task_id\n    \n    def __lt__(self, other):\n        if not isinstance(other, Task):\n            return NotImplemented\n        if self.priority == other.priority:\n            return self.task_id < other.task_id\n        return self.priority < other.priority\n\nclass Future(ConcurrentFuture):\n    \"\"\"Future 类，用于表示异步任务的结果\"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n        self._result = None\n        self._exception = None\n        \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务失败则抛出原始异常\n        \n        Args:\n            timeout: 等待超时时间\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 任务执行时抛出的原始异常\n            TimeoutError: 超时\n        \"\"\"\n        try:\n            if timeout is not None:\n                # 使用 threading.Event 实现超时等待\n                event = threading.Event()\n                self.add_done_callback(lambda f: event.set())\n                if not event.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            if self._exception:\n                raise self._exception\n            return self._result\n        except Exception as e:\n            raise e\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池实现异步任务执行，支持任务优先级、超时、批量执行等功能\n    \"\"\"\n    \n    def __init__(self, max_workers: i",
          "time_taken": 79.92447185516357
        }
      ],
      "elapsed_seconds": 331.0
    },
    {
      "round": 313,
      "timestamp": 1771200989.954338,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 183, in <module>\n  File \"<string>\", line 171, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 63, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 74.31919145584106
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务数据结构，支持优先级比较\"\"\"\n    priority: int\n    task_id: int\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float] = None\n    \n    def __lt__(self, other):\n        # 优先级高的任务排在前面\n        if self.priority != other.priority:\n            return self.priority > other.priority\n        # 优先级相同时，按任务ID排序（保证可比较）\n        return self.task_id < other.task_id\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务结果的Future对象\"\"\"\n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n        self._result = None\n        self._exception = None\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 如果任务执行失败，抛出原始异常\n            TimeoutError: 如果任务超时\n        \"\"\"\n        # 等待任务完成\n        if not self.done():\n            # 使用条件变量等待任务完成\n            with self._condition:\n                if not self.done():\n                    if not self._condition.wait(timeout):\n                        raise TimeoutError(\"Task timed out\")\n        \n        if self._exception:\n            raise self._exception\n        return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭等操作。\n    使用线程池执行任务，支持优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._result_map: dict[int, Future] = {}\n        self._task_counter = 0\n ",
          "time_taken": 29.1212100982666
        }
      ],
      "elapsed_seconds": 248.4
    },
    {
      "round": 314,
      "timestamp": 1771201249.19472,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=61)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=11)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 184, in <module>\n  File \"<string>\", line 172, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 63, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 83.71911096572876
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom concurrent.futures import Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n\n@dataclass(order=True)\nclass PrioritizedTask:\n    \"\"\"带优先级的任务\"\"\"\n    priority: int\n    task_id: int = field(compare=False)\n    fn: Callable = field(compare=False)\n    args: Tuple = field(compare=False)\n    kwargs: dict = field(compare=False)\n    timeout: Optional[float] = field(compare=False)\n    future: 'TaskFuture' = field(compare=False)\n\n    def __post_init__(self):\n        if self.priority is None:\n            self.priority = TaskPriority.NORMAL.value\n\n\nclass TaskFuture(ConcurrentFuture):\n    \"\"\"任务的 Future 对象\"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._result_set = threading.Event()\n\n    def set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        self._result = result\n        self._done = True\n        self._result_set.set()\n        super().set_result(result)\n\n    def set_exception(self, exception: Exception):\n        \"\"\"设置任务异常\"\"\"\n        self._exception = exception\n        self._done = True\n        self._result_set.set()\n        super().set_exception(exception)\n\n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的原始异常\n            TimeoutError: 超时异常\n        \"\"\"\n        if not self._result_set.wait(timeout):\n            raise TimeoutError(f\"Task {self._task_id} timed out\")\n        \n        if self._exception:\n            raise self._exception\n         ",
          "time_taken": 42.78238224983215
        }
      ],
      "elapsed_seconds": 259.1
    },
    {
      "round": 315,
      "timestamp": 1771201684.690549,
      "passed": 6,
      "total": 8,
      "avg_score": 7.62,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表。如果n<=0，返回空列表\n        \n    Examples:\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 测试负数情况\n    print(f\"fibonacci(-1) = {fibonacci(-1)}\") # []\n",
          "time_taken": 123.94654107093811
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 136.05390739440918
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 186, in <module>\n  File \"<string>\", line 174, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 64, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 102.09594130516052
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 204, in <module>\n  File \"<string>\", line 62, in result\n  File \"<string>\", line 196, in _execute_task\n  File \"<string>\", line 47, in set_result\nAttributeError: 'super' object has no attribute '_set_result'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务数据类，用于优先级队列\"\"\"\n    priority: int\n    timestamp: float\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: 'Future'\n    \n    def __eq__(self, other):\n        if not isinstance(other, Task):\n            return NotImplemented\n        return (self.priority, self.timestamp) == (other.priority, other.timestamp)\n    \n    def __lt__(self, other):\n        if not isinstance(other, Task):\n            return NotImplemented\n        return (self.priority, self.timestamp) < (other.priority, other.timestamp)\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务结果的Future对象\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done_event = threading.Event()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        self._result = result\n        self._done_event.set()\n        # 直接调用父类方法，而不是super()._set_result\n        super()._set_result(result)\n    \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        self._exception = exception\n        self._done_event.set()\n        # 直接调用父类方法，而不是super()._set_exception\n        super()._set_exception(exception)\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果，支持超时\"\"\"\n        if not self._done_event.wait(timeout):\n            raise TimeoutError(\"Task timed out\")\n        \n        if self._exception:\n            raise self._exception\n        return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n       ",
          "time_taken": 103.90216040611267
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: x}\n    \n    # 正确调用\n ",
          "time_taken": 33.638580322265625
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Union, Tuple, Any, Type\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    装饰器工厂，用于为函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括首次执行）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logging.warning(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay} seconds...\")\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logging.error(f\"All {max_retries + 1} attempts failed with {type(e).__name__}: {e}\")\n                        raise\n            raise RuntimeError(\"Unreachable code\")\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logging",
          "time_taken": 98.03363013267517
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（同步或异步）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['errors'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        ret",
          "time_taken": 21.291040897369385
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 112.82481098175049
        }
      ],
      "elapsed_seconds": 435.4
    },
    {
      "round": 316,
      "timestamp": 1771201888.870395,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 69, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 184, in <module>\n  File \"<string>\", line 172, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 72, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 76.48986005783081
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom concurrent.futures import Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\n\nclass TaskPriority(Enum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n\n@dataclass(order=True)\nclass PrioritizedTask:\n    \"\"\"带优先级的任务\"\"\"\n    priority: int\n    task_id: int = field(compare=False)\n    fn: Callable = field(compare=False)\n    args: Tuple = field(compare=False)\n    kwargs: dict = field(compare=False)\n    timeout: Optional[float] = field(compare=False)\n    future: 'TaskFuture' = field(compare=False)\n\n    def __post_init__(self):\n        if self.priority is None:\n            self.priority = TaskPriority.NORMAL.value\n\n\nclass TaskFuture(ConcurrentFuture):\n    \"\"\"任务的 Future 对象\"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._result_set = threading.Event()\n\n    def set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        self._result = result\n        self._done = True\n        self._result_set.set()\n        super().set_result(result)\n\n    def set_exception(self, exception: Exception):\n        \"\"\"设置任务异常\"\"\"\n        self._exception = exception\n        self._done = True\n        self._result_set.set()\n        super().set_exception(exception)\n\n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的原始异常\n            TimeoutError: 超时异常\n        \"\"\"\n        if not self._result_set.wait(timeout):\n            raise TimeoutError(f\"Task {self._task_id} timed out\")\n        \n        if self._exception:\n            raise self._exception\n         ",
          "time_taken": 29.604879140853882
        }
      ],
      "elapsed_seconds": 204.1
    },
    {
      "round": 317,
      "timestamp": 1771202270.9195788,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 72, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 191, in <module>\n  File \"<string>\", line 179, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 75, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 253.82441306114197
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务包装类，用于优先级队列比较\"\"\"\n    priority: int\n    task_id: int\n    func: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float] = None\n    \n    def __lt__(self, other):\n        if self.priority == other.priority:\n            return self.task_id < other.task_id\n        return self.priority < other.priority\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务执行结果的Future对象\"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n        self._result = None\n        self._exception = None\n        self._done = False\n\n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n            TimeoutError: 超时异常\n        \"\"\"\n        if not self._done:\n            # 等待任务完成\n            if not self._wait(timeout):\n                raise TimeoutError(f\"Task {self._task_id} timed out\")\n        \n        if self._exception:\n            raise self._exception\n            \n        return self._result\n\n    def _wait(self, timeout: Optional[float]) -> bool:\n        \"\"\"等待任务完成\"\"\"\n        if self._done:\n            return True\n            \n        # 简化实现：在实际应用中可能需要更复杂的等待机制\n        start_time = time.time()\n        while not self._done:\n            if timeout is not None and time.time() - start_time > timeout:\n                return False\n            time.sleep(0.001)  # 短暂休眠避免忙等待\n        return True\n\nclass TaskPool:\n    \"\"\"可复用的并发任务池\"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线",
          "time_taken": 208.894216299057
        }
      ],
      "elapsed_seconds": 381.9
    },
    {
      "round": 318,
      "timestamp": 1771214542.5329769,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 177, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a unary minus, treat it as part of the following number\n                    self.position += 1\n                    # Read the number that follows\n                    if self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self._read_number()\n                    else:\n                        raise ValueError(\"Unexpected character after minus sign\")\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n ",
          "time_taken": 70.96092891693115
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务数据类，支持优先级比较\"\"\"\n    priority: int\n    task_id: int\n    func: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float] = None\n    \n    def __lt__(self, other):\n        # 优先级高的任务排在前面（数字越小优先级越高）\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        # 相同优先级时，按任务ID排序保证稳定性\n        return self.task_id < other.task_id\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务结果的Future对象\"\"\"\n    \n    def __init__(self, task: Task):\n        super().__init__()\n        self._task = task\n        self._result = None\n        self._exception = None\n        self._done = False\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果超时则抛出异常\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            TimeoutError: 超时\n            Exception: 任务执行过程中抛出的异常\n        \"\"\"\n        if not self._done:\n            # 等待任务完成\n            if timeout is not None:\n                # 使用线程等待\n                start_time = time.time()\n                while not self._done and (time.time() - start_time) < timeout:\n                    time.sleep(0.01)  # 短暂休眠避免忙等待\n                \n                if not self._done:\n                    raise TimeoutError(\"Task timed out\")\n            else:\n                # 无超时等待\n                while not self._done:\n                    time.sleep(0.01)\n        \n        if self._exception:\n            raise self._exception\n        \n        return self._result\n\nclass TaskPool:\n    \"\"\"可复用的并发任务池\"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n     ",
          "time_taken": 24.906442880630493
        }
      ],
      "elapsed_seconds": 235.9
    },
    {
      "round": 319,
      "timestamp": 1771214785.061429,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=62)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=12)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 68, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 184, in <module>\n  File \"<string>\", line 172, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 71, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n ",
          "time_taken": 44.274346351623535
        }
      ],
      "elapsed_seconds": 242.4
    },
    {
      "round": 320,
      "timestamp": 1771217773.704354,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能（大数值测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 183.64511585235596
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\n\ndef merge_sort(arr: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    对输入列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。它将数组分成两半，\n    递归地对两半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的数字列表（支持整数和浮点数）\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([3.14, 2.71, 1.41])\n        [1.41, 2.71, 3.14]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[Union[int, float]], right: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, ",
          "time_taken": 202.3115038871765
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 74, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 196, in <module>\n  File \"<string>\", line 178, in evaluate\n  File \"<string>\", line 42, in tokenize\n  File \"<string>\", line 77, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or a dot\n                is_unary = (\n                    self.position == 0 or \n                    (self.tokens and self.tokens[-1].type == 'LPAREN')\n                )\n                if is_unary and self.position + 1 < len(self.expression) and (\n                    self.expression[self.position + 1].isdigit() or \n                    self.expression[self.position + 1] == '.'\n                ):\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.po",
          "time_taken": 191.9059088230133
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数类型\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（包括 Optional）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数类型，则只检查是否为 list\n        if not args:\n            return True\n        # 检查每个元素是否匹配参数类型\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数类型，则只检查是否为 dict\n        if not args:\n            return True\n        # 检查每个键值对是否匹配参数类型\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底处理\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError",
          "time_taken": 58.69599175453186
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Union, Tuple, Any, Type\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次执行）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logging.error(f\"Function {func.__name__} failed after {max_retries + 1} attempts\")\n                        raise\n                    logging.warning(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay} seconds...\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logging.error(f\"Function {func.__name__} failed after {max_retries + 1} attempts\")\n                        raise\n                    logging.warning(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay} seconds...\")\n                    await asyncio.sleep(current_delay)",
          "time_taken": 160.39079093933105
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import IntEnum\n\nclass Priority(IntEnum):\n    \"\"\"任务优先级枚举\"\"\"\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable[..., Any]\n    args: tuple\n    kwargs: dict\n    priority: Priority = Priority.NORMAL\n    timeout: Optional[float] = None\n    future: 'Future' = field(default_factory=lambda: Future())\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"实现优先级比较\"\"\"\n        if self.priority != other.priority:\n            return self.priority > other.priority  # 高优先级先执行\n        return id(self) < id(other)  # 相同优先级按提交顺序\n\nclass Future(ConcurrentFuture):\n    \"\"\"自定义 Future 类\"\"\"\n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果，支持超时\"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n            \n            return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    支持提交单个任务、批量执行、优雅关闭、超时控制和优先级调度。\n    使用线程实现并发执行。\n    \"\"\"\n    \n    def __init__(self, max_work",
          "time_taken": 118.85110807418823
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持按顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，并记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n  ",
          "time_taken": 44.36386775970459
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still exists)\n    print(cache.get(\"d\"))  # Should return 4 (still exists)\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 173.17194604873657
        }
      ],
      "elapsed_seconds": 348.0
    },
    {
      "round": 321,
      "timestamp": 1771218034.41203,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 72, in _read_number\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 191, in <module>\n  File \"<string>\", line 175, in evaluate\n  File \"<string>\", line 40, in tokenize\n  File \"<string>\", line 75, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or dot\n                if (self.position == 0 or \n                    self.expression[self.position - 1] == '(' or\n                    self.expression[self.position - 1] in ['+', '-', '*', '/']) and \\\n                   self.position + 1 < len(self.expression) and \\\n                   (self.expression[self.position + 1].isdigit() or \n                    self.expression[self.position + 1] == '.'):\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.p",
          "time_taken": 80.49743366241455
        }
      ],
      "elapsed_seconds": 260.6
    },
    {
      "round": 322,
      "timestamp": 1771218286.010299,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 196, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus (at start or after '(')\n                if (self.position == 0 or \n                    (self.position > 0 and \n                     self.expression[self.position - 1] in '(+-*/')):\n                    self._read_negative_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self",
          "time_taken": 77.31416821479797
        }
      ],
      "elapsed_seconds": 251.5
    },
    {
      "round": 323,
      "timestamp": 1771218313.354922,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or a dot\n                if (self.position == 0 or \n                    self.tokens[-1].type == 'LPAREN' if self.tokens else False) and \\\n                   self.position + 1 < len(self.expression) and \\\n                   (self.expression[self.position + 1].isdigit() or \n                    self.expression[self.position + 1] == '.'):\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self",
          "time_taken": 26.842078924179077
        }
      ],
      "elapsed_seconds": 27.2
    },
    {
      "round": 324,
      "timestamp": 1771218728.319315,
      "passed": 7,
      "total": 8,
      "avg_score": 8.0,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=63)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=13)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Execution timed out (60s)",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        \n    def tokenize(self) -> List[Token]:\n        tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n                \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                value = self.expression[start:self.pos]\n                tokens.append(Token('NUMBER', float(value)))\n                \n            elif char == '+' or char == '-' or char == '*' or char == '/':\n                tokens.append(Token('OPERATOR', char))\n                \n            elif char == '(' or char == ')':\n                tokens.append(Token('PAREN', char))\n            else:\n                raise ValueError(f\"Invalid character: {char}\")\n                \n        return tokens\n\nclass Parser:\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.pos = 0\n        \n    def peek(self) -> Token:\n        if self.pos < len(self.tokens):\n            return self.tokens[self.pos]\n        return None\n        \n    def consume(self) -> Token:\n        if self.pos < len(self.tokens):\n            token = self.tokens[self.pos]\n            self.pos += 1\n            return token\n        raise ValueError(\"Unexpected end of expression\")\n        \n    def parse_expression(self) -> float:\n        \"\"\"Parse addition an",
          "time_taken": 246.50175309181213
        }
      ],
      "elapsed_seconds": 414.9
    },
    {
      "round": 325,
      "timestamp": 1771219241.450936,
      "passed": 7,
      "total": 8,
      "avg_score": 8.19,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率：大数值测试\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 233.66972708702087
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素并合并\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],\n        [42],\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [5, 2, 8, 1],\n        [1, 2, 3, 4, 5],\n        [5, 4, 3, 2, 1],\n        [1, 1, 1, 1],\n        [-3, -1, -4, -1, -5, -9, -2, -6]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {test_case} -> {sorted_result}\")\n        \n        # 验证原列表未被修改\n        print(f\"原列表未变: {test_case}\")\n        print()\n",
          "time_taken": 248.8298909664154
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 178, in <module>\n  File \"<string>\", line 162, in evaluate\n  File \"<string>\", line 41, in tokenize\n  File \"<string>\", line 73, in _read_number\nValueError: Invalid number: empty number",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or decimal point\n                is_unary = (\n                    self.position == 0 or \n                    (self.tokens and self.tokens[-1].type == 'LPAREN')\n                )\n                if is_unary and self.position + 1 < len(self.expression):\n                    next_char = self.expression[self.position + 1]\n                    if next_char.isdigit() or next_char == '.':\n                        self._read_number()\n                    else:\n                        self.tokens.append(Token('MINUS', char))\n                        self.position += 1\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.pos",
          "time_taken": 241.005380153656
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: x}\n    \n    # 正确调用\n    t",
          "time_taken": 35.973180294036865
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Type, Union, Callable, Any, Tuple, Awaitable\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 重试 {attempt} 次后抛出异常 {type(e).__name__}: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1} 次尝试失败: {type(e).__name__}: {e}\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            return None\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 重试 {attempt} 次后抛出异常 {type(e).__name__}: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1} 次尝试失败: {type(e).__name__}: {e}\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n            return None\n    ",
          "time_taken": 204.56619906425476
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Any, Callable, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    DONE = \"done\"\n    CANCELLED = \"cancelled\"\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(init=False)\n    \n    def __post_init__(self):\n        self.future = Future()\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"优先级比较，优先级数字越小越优先\"\"\"\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        # 如果优先级相同，按提交时间排序\n        return id(self) < id(other)\n\nclass Future(ConcurrentFuture):\n    \"\"\"自定义 Future 类，支持超时和异常处理\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果，支持超时\"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n            \n            return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    提供线程池功能，支持提交任务、批量执行、",
          "time_taken": 201.27307677268982
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序处理和并发批量处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 阶段处理函数\n            data: 输入数据\n            \n        Returns:\n            处理结果\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序处理数据\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any],",
          "time_taken": 21.102232217788696
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 示例用法和测试\nif __name__ == \"__main__\":\n    # 创建一个容量为3的LRU缓存\n    cache = LRUCache(3)\n    \n    # 测试基本功能\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    cache.put(\"c\", 3)\n    \n    print(cache.get(\"a\"))  # 输出: 1\n    print(cache.get(\"b\"))  # 输出: 2\n    \n    # 测试容量限制（应该淘汰最久未使用的项）\n    cache.put(\"d\", 4)  # 这会淘汰 \"a\"\n    print(cache.get(\"a\"))  # 输出: None\n    print(cache.get(\"b\"))  # 输出: 2\n    print(cache.get(\"c\"))  # 输出: 3\n    print(cache.get(\"d\"))  # 输出: 4\n    \n    # 测试TTL过期\n    cache.put(\"e\", 5, ttl=1)  # 1秒后过期\n    print(cache.get(\"e\"))  # 输出: 5\n    time.sleep(1.1)\n    print(cache.get(\"e\"))  # 输出: None (已过期)\n    \n    # 测试更新已存在的key\n    cache.put(\"f\", 6)\n    cache.put(\"f\", 7)  # 更新f的值\n    print(cache.get(\"f\"))  # 输出: 7\n",
          "time_taken": 222.1592538356781
        }
      ],
      "elapsed_seconds": 513.0
    },
    {
      "round": 326,
      "timestamp": 1771223282.945761,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 195, in <module>\n  File \"<string>\", line 177, in evaluate\n  File \"<string>\", line 39, in tokenize\n  File \"<string>\", line 68, in _read_number\nValueError: Invalid number: empty number",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or a dot\n                if (self.position == 0 or \n                    (self.tokens and self.tokens[-1].type == 'LPAREN')) and \\\n                   self.position + 1 < len(self.expression) and \\\n                   (self.expression[self.position + 1].isdigit() or \n                    self.expression[self.position + 1] == '.'):\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.",
          "time_taken": 72.19554591178894
        }
      ],
      "elapsed_seconds": 241.5
    },
    {
      "round": 327,
      "timestamp": 1771223560.090336,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 195, in <module>\n  File \"<string>\", line 177, in evaluate\n  File \"<string>\", line 39, in tokenize\n  File \"<string>\", line 68, in _read_number\nValueError: Invalid number: empty number",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or a dot\n                is_unary = (self.position == 0 or \n                           (self.tokens and self.tokens[-1].type == 'LPAREN'))\n                if is_unary and self.position + 1 < len(self.expression) and \\\n                   (self.expression[self.position + 1].isdigit() or \n                    self.expression[self.position + 1] == '.'):\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n      ",
          "time_taken": 73.03627920150757
        }
      ],
      "elapsed_seconds": 277.1
    },
    {
      "round": 328,
      "timestamp": 1771223820.495084,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 194, in <module>\n  File \"<string>\", line 176, in evaluate\n  File \"<string>\", line 36, in tokenize\n  File \"<string>\", line 67, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus (at start or after '(')\n                if (self.position == 0 or \n                    (self.position > 0 and \n                     self.expression[self.position - 1] in '(+-*/')):\n                    # This is a unary minus, read the following number\n                    self._read_number()\n                else:\n                    # This is a binary minus\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.t",
          "time_taken": 76.48673939704895
        }
      ],
      "elapsed_seconds": 260.3
    },
    {
      "round": 329,
      "timestamp": 1771224067.4247549,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=64)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=14)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=29)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 191, in <module>\n  File \"<string>\", line 173, in evaluate\n  File \"<string>\", line 33, in tokenize\n  File \"<string>\", line 63, in _read_number\nValueError: Invalid number",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus (at start or after '(')\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n            self.expression[self.position].isdigit() or \n      ",
          "time_taken": 74.56561088562012
        }
      ],
      "elapsed_seconds": 246.8
    },
    {
      "round": 330,
      "timestamp": 1771224322.747531,
      "passed": 7,
      "total": 8,
      "avg_score": 8.19,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 133.7924451828003
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组递归地分成两半，分别排序后合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保纯函数特性\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {test_case} -> {sorted_result}\")\n    \n    # 验证原列表未被修改\n    original = [3, 1, 4, 1, 5]\n    merge_sort(original)\n    print(f\"原列表未被修改: {original}\")\n",
          "time_taken": 148.41083598136902
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 195, in <module>\n  File \"<string>\", line 177, in evaluate\n  File \"<string>\", line 39, in tokenize\n  File \"<string>\", line 68, in _read_number\nValueError: Invalid number",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or a dot\n                if (self.position == 0 or \n                    (self.tokens and self.tokens[-1].type == 'LPAREN')) and \\\n                   self.position + 1 < len(self.expression) and \\\n                   (self.expression[self.position + 1].isdigit() or \n                    self.expression[self.position + 1] == '.'):\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.",
          "time_taken": 150.83191108703613
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型注解的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型检查\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型 (包括 Optional)\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n ",
          "time_taken": 40.912551164627075
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Union, Tuple, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[TypeVar('E'), ...] = (Exception,)\n) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能\n    \n    Args:\n        max_retries: 最大重试次数（不包括首次执行）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟倍数因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 重试 {attempt} 次后抛出异常 {type(e).__name__}: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1} 次尝试失败: {type(e).__name__}: {e}\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            raise RuntimeError(\"不应到达此处\")\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 重试 {attempt} 次后抛出异常 {type(e).__name__}: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1} 次尝试失败: {type(e).__name__}: {e}\")\n                 ",
          "time_taken": 110.61484026908875
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段并记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_func = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_na",
          "time_taken": 26.32019567489624
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None due to expiration\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None as it was evicted due to capacity limit\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 123.18987703323364
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom queue import PriorityQueue\n\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(default_factory=lambda: Future())\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"用于优先队列比较\"\"\"\n        return self.priority < other.priority\n\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务结果的 Future 对象\n    \n    提供了对任务结果的异步访问能力，支持超时等待\n    \"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的原始异常\n            TimeoutError: 超时异常\n        \"\"\"\n        with self._condition:\n            if self._exception is not None:\n                raise self._exception\n            if self._result is not None:\n                return self._result\n                \n            if timeout is not None:\n                # 等待指定时间\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            else:\n                # 永久等待\n                self._condition.wait()\n                ",
          "time_taken": 80.59605693817139
        }
      ],
      "elapsed_seconds": 255.2
    },
    {
      "round": 331,
      "timestamp": 1771224540.1926122,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 188, in <module>\n  File \"<string>\", line 170, in evaluate\n  File \"<string>\", line 33, in tokenize\n  File \"<string>\", line 62, in _read_number\nValueError: Invalid number: empty number",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus (at start or after '(')\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return self.tokens\n    \n    def _read_number(self):\n        start = self.position\n        while self.position < len(self.expression) and (\n            self.expression[self.position].isdigit() or \n      ",
          "time_taken": 76.11220788955688
        }
      ],
      "elapsed_seconds": 217.3
    },
    {
      "round": 332,
      "timestamp": 1771225241.949887,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 182, in <module>\n  File \"<string>\", line 166, in evaluate\n  File \"<string>\", line 37, in tokenize\n  File \"<string>\", line 67, in _read_number\nValueError: Invalid number: empty number",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or dot\n                if (self.position == 0 or self.expression[self.position - 1] == '(') and \\\n                   (self.position + 1 < len(self.expression) and \n                    (self.expression[self.position + 1].isdigit() or self.expression[self.position + 1] == '.')):\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.",
          "time_taken": 99.43838572502136
        }
      ],
      "elapsed_seconds": 272.8
    },
    {
      "round": 333,
      "timestamp": 1771225546.7376251,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 184, in <module>\n  File \"<string>\", line 168, in evaluate\n  File \"<string>\", line 38, in tokenize\n  File \"<string>\", line 69, in _read_number\nValueError: Invalid number: empty",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and followed by a digit or a dot\n                if (self.position == 0 or \n                    self.expression[self.position - 1] == '(' or\n                    self.expression[self.position - 1] in ['+', '-', '*', '/']):\n                    # It's a unary minus, we'll parse it as part of the number\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.position +=",
          "time_taken": 116.60202479362488
        }
      ],
      "elapsed_seconds": 304.7
    },
    {
      "round": 334,
      "timestamp": 1771225575.500422,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=65)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=15)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=30)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or a dot\n                if (self.position == 0 or \n                    self.tokens[-1].type == 'LPAREN' if self.tokens else False) and \\\n                   self.position + 1 < len(self.expression) and \\\n                   (self.expression[self.position + 1].isdigit() or \n                    self.expression[self.position + 1] == '.'):\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self",
          "time_taken": 28.252449989318848
        }
      ],
      "elapsed_seconds": 28.6
    },
    {
      "round": 335,
      "timestamp": 1771225957.9536262,
      "passed": 7,
      "total": 8,
      "avg_score": 8.19,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 124.27844619750977
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，通过将数组分成两半，递归地对每一半进行排序，\n    然后将两个已排序的半部分合并成一个完整的已排序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余的元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        print(f\"  排序后:   {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 136.9086730480194
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 154, in <module>\n  File \"<string>\", line 137, in evaluate\n  File \"<string>\", line 34, in tokenize\n  File \"<string>\", line 70, in _read_number\nValueError: Invalid number: empty",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        tokens = []\n        self.pos = 0\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number(tokens)\n            elif char == '+':\n                tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                # A '-' is a negative sign if it's at the beginning or after an opening parenthesis or operator\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_number(tokens)\n                else:\n                    tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return tokens\n    \n    def _read_number(self, tokens: List[Token]):\n        start = self.pos\n        while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[sel",
          "time_taken": 155.543762922287
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果无法识别的类型，使用 isinstance 检查\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, hobbies: list[str], metadata: dict[str, int]) -> str:\n      ",
          "time_taken": 35.8918879032135
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Type, TypeVar, Union, Callable, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟倍数，每次重试延迟时间会乘以该值\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay}s...\")\n                        await asyncio.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.info(f\"All {max_retries + 1} attempts failed with {type(e).__name__}: {e}\")\n                        raise e\n            \n            raise last_exception\n        \n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt ",
          "time_taken": 100.78075098991394
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发批量处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录成功统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage_name, r",
          "time_taken": 21.97806191444397
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry should expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 113.38551712036133
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务数据类，支持优先级比较\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    created_time: float = field(default_factory=time.time)\n    \n    def __eq__(self, other):\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority == other.priority\n    \n    def __lt__(self, other):\n        if not isinstance(other, Task):\n            return NotImplemented\n        return self.priority < other.priority\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务结果的未来对象\"\"\"\n    \n    def __init__(self, task: Task):\n        super().__init__()\n        self._task = task\n        self._result = None\n        self._exception = None\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n            TimeoutError: 超时\n        \"\"\"\n        try:\n            if timeout is not None:\n                # 等待结果，带超时\n                self._result = self._result  # 触发等待\n                return super().result(timeout=timeout)\n            else:\n                return super().result()\n        except Exception as e:\n            # 重新抛出原始异常\n            raise e\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行任务，支持优先级和超时控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._t",
          "time_taken": 75.45500802993774
        }
      ],
      "elapsed_seconds": 382.3
    },
    {
      "round": 336,
      "timestamp": 1771225985.970326,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or a dot\n                if (self.position == 0 or \n                    self.tokens[-1].type == 'LPAREN' if self.tokens else False) and \\\n                   self.position + 1 < len(self.expression) and \\\n                   (self.expression[self.position + 1].isdigit() or \n                    self.expression[self.position + 1] == '.'):\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self",
          "time_taken": 27.443585872650146
        }
      ],
      "elapsed_seconds": 27.9
    },
    {
      "round": 337,
      "timestamp": 1771226288.123741,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 196, in <module>\n  File \"<string>\", line 151, in evaluate\n  File \"<string>\", line 45, in tokenize\n  File \"<string>\", line 77, in _read_number\nValueError: Invalid number",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type_: str, value: Union[float, str]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token(TokenType.PLUS, char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, read the following number\n                    self._read_number(is_negative=True)\n                else:\n                    self.tokens.append(Token(TokenType.MINUS, char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token(TokenType.MULTIPLY, char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token(TokenType.DIVIDE, char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token(TokenType.LPAREN, char))\n                self.position += 1\n            elif char == ')':\n                self.tokens.append(Token(TokenType.RPAREN, char",
          "time_taken": 115.71439671516418
        }
      ],
      "elapsed_seconds": 302.0
    },
    {
      "round": 338,
      "timestamp": 1771227175.744498,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a unary minus\n                # It's unary if it's at the beginning or after an opening parenthesis\n                # and the next character is a digit or a dot\n                if (self.position == 0 or \n                    self.tokens[-1].type == 'LPAREN' if self.tokens else False) and \\\n                   self.position + 1 < len(self.expression) and \\\n                   (self.expression[self.position + 1].isdigit() or \n                    self.expression[self.position + 1] == '.'):\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', char))\n                    self.position += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', char))\n                self.position += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', char))\n                self.position += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                self",
          "time_taken": 26.472175121307373
        }
      ],
      "elapsed_seconds": 26.9
    },
    {
      "round": 339,
      "timestamp": 1771227222.859312,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=66)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=16)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=31)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return ''\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.position = 0\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                number_str = ''\n                while self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                    number_str += self.advance()\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.advance()\n            elif char == '-':\n                # Check if this is a negative sign\n                # A negative sign is valid if it's at the beginning or after '('\n                if self.position == 0 or self.peek() == '(':\n                    # Look ahead to see if the next character is a digit or '.'\n                    next_pos = self.position + 1\n                    if next_pos < len(self.expression) and (self.expression[next_pos].isdigit() or self.expression[next_pos] == '.'):\n                        # This is a negative number\n                        self.advance()  ",
          "time_taken": 46.646745920181274
        }
      ],
      "elapsed_seconds": 47.0
    },
    {
      "round": 340,
      "timestamp": 1771227573.268662,
      "passed": 7,
      "total": 8,
      "avg_score": 8.19,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 测试负数情况\n    print(f\"fibonacci(-1) = {fibonacci(-1)}\")  # []\n",
          "time_taken": 116.16768002510071
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保纯函数特性\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试随机列表\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    \n    # 测试包含重复元素的列表\n    assert merge_sort([5, 2, 8, 2, 1]) == [1, 2, 2, 5, 8]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 129.09507513046265
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 163, in <module>\n  File \"<string>\", line 157, in evaluate\nNameError: name 'self' is not defined",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n    \n    def tokenize(self) -> List[Token]:\n        tokens = []\n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            if char.isspace():\n                self.position += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number(tokens)\n            elif char == '(':\n                tokens.append(Token('LPAREN', char))\n                self.position += 1\n            elif char == ')':\n                tokens.append(Token('RPAREN', char))\n                self.position += 1\n            elif char == '*':\n                tokens.append(Token('MUL', char))\n                self.position += 1\n            elif char == '/':\n                tokens.append(Token('DIV', char))\n                self.position += 1\n            elif char == '+':\n                tokens.append(Token('ADD', char))\n                self.position += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] in '(+-*/':\n                    # This is a negative sign, read the following number\n                    self._read_number(tokens, is_negative=True)\n                else:\n                    # This is a subtraction operator\n                    tokens.append(Token('SUB', char))\n                    self.position += 1\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        return tokens\n    \n    def _read_number(self, tokens: List[Token], is_negative: bool = False):\n        start = self.position\n        #",
          "time_taken": 160.9263892173767
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务包装类，支持优先级比较\"\"\"\n    priority: int\n    task_id: int\n    func: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float] = None\n    \n    def __lt__(self, other):\n        if isinstance(other, Task):\n            # 优先级高的任务排在前面（数字小优先级高）\n            if self.priority != other.priority:\n                return self.priority < other.priority\n            # 优先级相同时，按任务ID排序（保证可比较性）\n            return self.task_id < other.task_id\n        return NotImplemented\n\nclass Future(ConcurrentFuture):\n    \"\"\"Future对象，用于获取任务结果\"\"\"\n    \n    def __init__(self, task_id: int, result_queue: queue.Queue):\n        super().__init__()\n        self._task_id = task_id\n        self._result_queue = result_queue\n        self._result = None\n        self._exception = None\n        self._done = False\n        \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n            TimeoutError: 超时异常\n        \"\"\"\n        if not self._done:\n            try:\n                # 从队列中获取结果\n                result = self._result_queue.get(timeout=timeout)\n                self._done = True\n                if isinstance(result, Exception):\n                    raise result\n                self._result = result\n            except queue.Empty:\n                raise TimeoutError(\"Task timed out\")\n        \n        if self._exception:\n            raise self._exception\n        \n        return self._result\n    \n    def exception(self, timeout: Optional[float] = None) -> Optional[Exception]:\n        \"\"\"\n        获取任务异常\n        \n        ",
          "time_taken": 57.11331820487976
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型检查\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # Union 类型检查\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # List 类型检查\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:  # 无参数的 List\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # Dict 类型检查\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:  # 无参数的 Dict\n            return True\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) for k, v in value.items())\n    \n    # 兜底检查\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n ",
          "time_taken": 34.59416699409485
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Union, Tuple, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[TypeVar('E'), ...] = (Exception,)\n) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    装饰器工厂，为同步和异步函数添加自动重试功能\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 在第 {attempt + 1} 次尝试后抛出异常: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1} 次尝试失败: {func.__name__} 抛出异常: {e}\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 在第 {attempt + 1} 次尝试后抛出异常: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1} 次尝试失败: {func.__name__} 抛出异常: {e}\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n ",
          "time_taken": 93.26710987091064
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序处理和并发批量处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（同步或异步）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理结果\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序处理所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], c",
          "time_taken": 20.357694387435913
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 105.39919996261597
        }
      ],
      "elapsed_seconds": 350.3
    },
    {
      "round": 341,
      "timestamp": 1771227599.841877,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return ''\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.position = 0\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                number_str = ''\n                while self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                    number_str += self.advance()\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char == '+':\n                self.tokens.append(Token('+', '+'))\n                self.advance()\n            elif char == '-':\n                # Check if this is a negative sign\n                # A negative sign is valid if it's at the beginning or after '('\n                if self.position == 0 or self.peek() == '(':\n                    # Look ahead to see if the next character is a digit or '.'\n                    next_pos = self.position + 1\n                    if next_pos < len(self.expression) and (self.expression[next_pos].isdigit() or self.expression[next_pos] == '.'):\n                        # This is a negative number\n                        self.advance()  ",
          "time_taken": 26.079877853393555
        }
      ],
      "elapsed_seconds": 26.5
    },
    {
      "round": 342,
      "timestamp": 1771227623.392061,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return ''\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                number_str = ''\n                while self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                    number_str += self.advance()\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            \n            elif char == '+' or char == '-' or char == '*' or char == '/':\n                # Handle unary minus\n                if char == '-' and (self.position == 0 or self.peek() == '('):\n                    # This is a unary minus, so we should parse the following number\n                    # and make it negative\n                    if self.position + 1 < len(self.expression) and (self.expression[self.position + 1].isdigit() or self.expression[self.position + 1] == '.'):\n                        self.advance()  # Skip the minus sign\n                        number_str = '-'\n                        while self.position < len(self.expression) and (self.peek()",
          "time_taken": 23.05338978767395
        }
      ],
      "elapsed_seconds": 23.4
    },
    {
      "round": 343,
      "timestamp": 1771227667.359891,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        tokens = []\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                value = self.expression[start:self.pos]\n                tokens.append(Token('NUMBER', float(value)))\n            elif char == '(':\n                tokens.append(Token('LPAREN', char))\n                self.pos += 1\n            elif char == ')':\n                tokens.append(Token('RPAREN', char))\n                self.pos += 1\n            elif char == '+':\n                tokens.append(Token('PLUS', char))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                # A '-' is a negative sign if it's at the beginning or after an operator or '('\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    # This is a negative sign, read the following number\n                    start = self.pos\n                    self.pos += 1  # skip the '-'\n                    # Now read the number that follows\n                    while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                        self.pos += 1\n                    value = self.expression[star",
          "time_taken": 43.469107151031494
        }
      ],
      "elapsed_seconds": 43.9
    },
    {
      "round": 344,
      "timestamp": 1771227667.856222,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=67)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=17)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=32)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 345,
      "timestamp": 1771227833.970473,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n: 要返回的斐波那契数的个数\n        \n    Returns:\n        包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算剩余的斐波那契数\n    # 避免了指数级递归的效率问题\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 148.74975085258484
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度为 O(n log n)，空间复杂度为 O(n)。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基本情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试空列表\n    assert merge_sort([]) == []\n    \n    # 测试单元素列表\n    assert merge_sort([42]) == [42]\n    \n    # 测试已排序列表\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # 测试逆序列表\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    \n    # 测试重复元素\n    assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]\n    \n    # 测试负数\n    assert merge_sort([-3, -1, -4, -1, -5, -9, -2, -6, -5, -3]) == [-9, -6, -5, -5, -4, -3, -3, -2, -1, -1]\n    \n    print(\"所有测试通过！\")\n",
          "time_taken": 162.3133900165558
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return ''\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.position = 0\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including decimals)\n                number_str = ''\n                while self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                    number_str += self.advance()\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char in '+-*/()':\n                # Handle unary minus\n                if char == '-' and (self.position == 0 or self.peek() == '('):\n                    # Check if next char is a number\n                    old_pos = self.position\n                    self.advance()  # Skip the minus\n                    if self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                        # This is a negative number\n                        number_str = '-'\n                        while self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                            number_str += self.advance",
          "time_taken": 109.88829803466797
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\nfrom typing import Protocol\n\n# 定义任务优先级比较协议\nclass Comparable(Protocol):\n    def __lt__(self, other) -> bool: ...\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(default_factory=lambda: Future())\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"实现任务优先级比较\"\"\"\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        # 如果优先级相同，比较任务提交时间（越早越先执行）\n        return id(self) < id(other)\n\nclass Future(ConcurrentFuture):\n    \"\"\"可等待的未来结果\"\"\"\n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._condition = threading.Condition()\n        self._done = False\n        \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n            \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n            \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果，支持超时\"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n                \n            return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、超时控制和优先级调度。\n    \n    Example:\n     ",
          "time_taken": 87.73590230941772
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, hobbies: list[str], info: dict[str, int]) -> str:\n        return f\"Name: {name}, Age: ",
          "time_taken": 37.391802072525024
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Type, Union, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，用于自动重试函数调用\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次成功尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 重试 {attempt} 次后抛出异常: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1} 次尝试失败: {func.__name__} 抛出异常: {e}\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            raise RuntimeError(\"不应该到达这里\")\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 重试 {attempt} 次后抛出异常: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1} 次尝试失败: {func.__name__} 抛出异常: {e}\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n            raise RuntimeError(",
          "time_taken": 120.89149212837219
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理器，支持顺序执行和并发处理。\n    \n    支持添加异步或同步阶段，自动识别函数类型并处理。\n    提供详细的统计信息，包括调用次数、平均执行时间、错误计数等。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data: Dict[str, Dict[str, Any]] = defaultdict(\n            lambda: {\"calls\": 0, \"total_time\": 0.0, \"errors\": 0}\n        )\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        stage_func = self.stages[stage_name]\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 记录成功统计\n            self.stats_data[stage_name][\"calls\"] += 1\n            self.stats_data[stage_name][\"total_time\"] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name][\"calls\"] += 1\n            self.stats_data[stage_name][\"total_time\"] += (time.time() - start_time)\n            self.stats_data[stage_name][\"errors\"] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in se",
          "time_taken": 23.741488218307495
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    \n    print(cache.get(1))  # Should return \"value1\"\n    \n    cache.put(3, \"value3\")  # This should evict key 2\n    \n    print(cache.get(2))  # Should return None (evicted)\n    print(cache.get(3))  # Should return \"value3\"\n    \n    # Test TTL functionality\n    cache.put(4, \"value4\", ttl=1)  # 1 second TTL\n    print(cache.get(4))  # Should return \"value4\"\n    \n    time.sleep(1.1)  # Wait for TTL to expire\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test LRU eviction with TTL\n    cache.put(5, \"value5\", ttl=2)\n    cache.put(6, \"value6\")\n    cache.put(7, \"value7\")  # This should evict key 5 (expired) and key 6\n    \n    print(cache.get(5))  # Should return None (expired and evicted)\n    print(cache.get(6))  # Should return None (evicted)\n    print(cache.get(7))  # Should return \"value7\"\n",
          "time_taken": 138.25128602981567
        }
      ],
      "elapsed_seconds": 166.0
    },
    {
      "round": 346,
      "timestamp": 1771227966.416118,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.3
    },
    {
      "round": 347,
      "timestamp": 1771227966.858691,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 348,
      "timestamp": 1771227967.303675,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 349,
      "timestamp": 1771227967.740733,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=68)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=18)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=33)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 350,
      "timestamp": 1771228639.6864362,
      "passed": 6,
      "total": 8,
      "avg_score": 7.69,
      "pass_rate": 0.75,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算剩余的斐波那契数\n    # 从第3个数开始计算\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 135.88754200935364
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种基于分治思想的稳定排序算法。它将数组分成两半，\n    递归地对两半进行排序，然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的列表\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始列表: {original}\")\n        prin",
          "time_taken": 148.9450466632843
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 167, in <module>\n  File \"<string>\", line 150, in evaluate\n  File \"<string>\", line 35, in tokenize\n  File \"<string>\", line 63, in _read_number\nValueError: Invalid number:",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.tokens = []\n        self.pos = 0\n\n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.pos = 0\n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            if char.isspace():\n                self.pos += 1\n                continue\n            elif char.isdigit() or char == '.':\n                self._read_number()\n            elif char == '+':\n                self.tokens.append(Token('PLUS', '+'))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                # A '-' is a negative sign if it's at the beginning or after an opening parenthesis or operator\n                if self.pos == 0 or self.expression[self.pos - 1] in '(+-*/':\n                    self._read_number()\n                else:\n                    self.tokens.append(Token('MINUS', '-'))\n                    self.pos += 1\n            elif char == '*':\n                self.tokens.append(Token('MULTIPLY', '*'))\n                self.pos += 1\n            elif char == '/':\n                self.tokens.append(Token('DIVIDE', '/'))\n                self.pos += 1\n            elif char == '(':\n                self.tokens.append(Token('LPAREN', '('))\n                self.pos += 1\n            elif char == ')':\n                self.tokens.append(Token('RPAREN', ')'))\n                self.pos += 1\n            else:\n                raise ValueError(f\"Invalid character: {char}\")\n        return self.tokens\n\n    def _read_number(self):\n        start = self.pos\n        # Read the number (including decimal point)\n        while self.pos < len(self.expr",
          "time_taken": 172.20458102226257
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（包括 Optional）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 List 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return True\n        # 检查每个元素\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 Dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return True\n        # 检查键值对\n        key_type, value_type = args\n        return all(_matches_type(k, key_type) and _matches_type(v, value_type) for k, v in value.items())\n    \n    # 兜底情况\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')",
          "time_taken": 56.1575140953064
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Type, TypeVar, Union, Callable, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 重试 {max_retries} 次后仍失败，异常: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1}/{max_retries} 次尝试失败: {func.__name__} 异常: {e}\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            raise RuntimeError(\"不应到达此行\")\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"最终失败: {func.__name__} 重试 {max_retries} 次后仍失败，异常: {e}\")\n                        raise\n                    logger.info(f\"第 {attempt + 1}/{max_retries} 次尝试失败: {func.__name__} 异常: {e}\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n   ",
          "time_taken": 110.52283120155334
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理器，支持顺序执行和并发批量处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误计数\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['errors'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage_n",
          "time_taken": 40.25123620033264
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    \n    print(cache.get(1))  # Should return \"value1\"\n    \n    cache.put(3, \"value3\")  # This should evict key 2\n    \n    print(cache.get(2))  # Should return None (evicted)\n    print(cache.get(3))  # Should return \"value3\"\n    \n    # Test TTL functionality\n    cache.put(4, \"value4\", ttl=1)  # 1 second TTL\n    print(cache.get(4))  # Should return \"value4\"\n    \n    time.sleep(1.1)  # Wait for TTL to expire\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test thread safety\n    import concurrent.futures\n    \n    def test_thread():\n        for i in range(10):\n            cache.put(i, f\"value_{i}\")\n            cache.get(i % 5)\n    \n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        futures = [executor.submit(test_thread) for _ in range(5)]\n        for future in futures:\n            future.result()\n    \n    print(\"",
          "time_taken": 126.01944994926453
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom concurrent.futures import TimeoutError as ConcurrentTimeoutError\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom dataclasses import dataclass, field\nfrom queue import PriorityQueue\nimport functools\n\n@dataclass\nclass _Task:\n    \"\"\"内部任务类，用于优先级队列\"\"\"\n    priority: int\n    creation_time: float\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: 'Future'\n    \n    def __lt__(self, other: '_Task') -> bool:\n        # 优先级高的先执行，优先级相同时按创建时间排序\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        return self.creation_time < other.creation_time\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务执行结果的 Future 对象\n    \n    提供了等待任务完成和获取结果的方法\n    \"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._condition = threading.Condition()\n        \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务失败则抛出原始异常\n        \n        Args:\n            timeout: 等待超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            ConcurrentTimeoutError: 超时异常\n            Exception: 任务执行时抛出的异常\n        \"\"\"\n        with self._condition:\n            if not self.done():\n                if not self._condition.wait(timeout):\n                    raise ConcurrentTimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n            \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self.set_result_called = True\n            self._condition.notify_all()\n            \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exc",
          "time_taken": 316.6616768836975
        }
      ],
      "elapsed_seconds": 671.9
    },
    {
      "round": 351,
      "timestamp": 1771228692.9309518,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return ''\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.position = 0\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including decimals)\n                number_str = ''\n                while self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                    number_str += self.advance()\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char in '+-*/()':\n                # Handle unary minus\n                if char == '-' and (self.position == 0 or self.peek() == '('):\n                    # Check if next char is a number\n                    old_pos = self.position\n                    self.advance()  # Skip the minus\n                    if self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                        # This is a negative number\n                        number_str = '-'\n                        while self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                            number_str += self.advance",
          "time_taken": 52.68588709831238
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\nfrom typing import Protocol\n\n# 定义任务优先级比较协议\nclass Comparable(Protocol):\n    def __lt__(self, other) -> bool: ...\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(default_factory=lambda: Future())\n    # 添加时间戳用于优先级比较\n    timestamp: float = field(default_factory=time.time)\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"实现任务优先级比较\"\"\"\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        # 如果优先级相同，比较任务提交时间（越早越先执行）\n        return self.timestamp < other.timestamp\n\nclass Future(ConcurrentFuture):\n    \"\"\"可等待的未来结果\"\"\"\n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._condition = threading.Condition()\n        self._done = False\n        \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n            \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n            \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果，支持超时\"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n                \n            return self._result\n\nclass TaskPool:\n    ",
          "time_taken": 28.60070013999939
        }
      ],
      "elapsed_seconds": 53.1
    },
    {
      "round": 352,
      "timestamp": 1771229010.616816,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return ''\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.position = 0\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including decimals)\n                number_str = ''\n                while self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                    number_str += self.advance()\n                self.tokens.append(Token('NUMBER', float(number_str)))\n            elif char == '+' or char == '-' or char == '*' or char == '/':\n                # Check if this is a unary minus\n                if char == '-' and (self.position == 0 or self.peek() == '('):\n                    # This is a unary minus, we'll parse the following number as negative\n                    # For now, we'll just add the minus sign as a token, and let the parser handle it\n                    self.tokens.append(Token('MINUS', char))\n                else:\n                    # This is a binary minus or plus\n                    self.tokens.append(Token('OPERATOR', char))\n                self.advance()\n            elif char == '(' or char == ')':\n        ",
          "time_taken": 74.42994213104248
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 221, in <module>\n  File \"<string>\", line 186, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(default_factory=lambda: Future())\n    # 添加时间戳用于比较，避免优先级相同导致的比较错误\n    timestamp: float = field(default_factory=time.time)\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"用于优先级队列比较\"\"\"\n        if self.priority == other.priority:\n            # 如果优先级相同，按时间戳排序\n            return self.timestamp < other.timestamp\n        return self.priority < other.priority\n\nclass Future(ConcurrentFuture):\n    \"\"\"可等待的任务结果\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: BaseException) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果\"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n\nclass TaskPool:\n    \"\"\"可复用的并发任务池\"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_worke",
          "time_taken": 98.725350856781
        }
      ],
      "elapsed_seconds": 317.6
    },
    {
      "round": 353,
      "timestamp": 1771229085.396325,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return ''\n    \n    def skip_whitespace(self):\n        while self.peek().isspace():\n            self.advance()\n    \n    def read_number(self) -> float:\n        # Read a number (integer or float) from current position\n        start = self.position\n        while self.peek() and (self.peek().isdigit() or self.peek() == '.'):\n            self.advance()\n        return float(self.expression[start:self.position])\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        tokens = []\n        \n        while self.position < len(self.expression):\n            self.skip_whitespace()\n            \n            if self.peek() == '':\n                break\n                \n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                # Handle number (including float)\n                num = self.read_number()\n                tokens.append(Token('NUMBER', num))\n            elif char == '+':\n                tokens.append(Token('+', '+'))\n                self.advance()\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    # Negative number: check if next char is digit or ",
          "time_taken": 74.23134398460388
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\nfrom typing import Protocol\n\n# 定义任务优先级比较协议\nclass Comparable(Protocol):\n    def __lt__(self, other) -> bool: ...\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(default_factory=lambda: Future())\n    # 添加任务创建时间戳，用于优先级相同的情况\n    created_at: float = field(default_factory=time.time)\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"实现任务优先级比较\"\"\"\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        # 如果优先级相同，比较任务创建时间（越早越先执行）\n        return self.created_at < other.created_at\n\nclass Future(ConcurrentFuture):\n    \"\"\"可等待的未来结果\"\"\"\n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._condition = threading.Condition()\n        self._done = False\n        \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n            \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n            \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果，支持超时\"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n                \n            return self._result\n\nclass Tas",
          "time_taken": 27.434113025665283
        }
      ],
      "elapsed_seconds": 74.7
    },
    {
      "round": 354,
      "timestamp": 1771229123.256809,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=69)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=19)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=34)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom queue import PriorityQueue\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: int = 0\n    timeout: Optional[float] = None\n    future: 'Future' = field(default_factory=lambda: Future())\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"支持优先级队列比较\"\"\"\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        # 当优先级相同时，按提交时间排序\n        return id(self) < id(other)\n\nclass Future(ConcurrentFuture):\n    \"\"\"自定义Future类，支持超时和异常处理\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果，支持超时\"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n            \n            return self._result\n\nclass TaskPool:\n    \"\"\"可复用的并发任务池\n    \n    使用线程实现的并发任务池，支持任务提交、批量执行、优先级和超时控制。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为CPU核心数\n    \"\"\"\n    \n    def __init__(self, max_wo",
          "time_taken": 37.36852407455444
        }
      ],
      "elapsed_seconds": 37.8
    },
    {
      "round": 355,
      "timestamp": 1771229780.163111,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算剩余的斐波那契数\n    # 从第3个数开始计算（索引为2）\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 354.5810432434082
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": false,
          "score": 4.5,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 206, in <module>\nAssertionError",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n    \n    def _is_digit(self, char: str) -> bool:\n        return char.isdigit()\n    \n    def _is_decimal(self, char: str) -> bool:\n        return char == '.'\n    \n    def _is_operator(self, char: str) -> bool:\n        return char in '+-*/'\n    \n    def _is_parenthesis(self, char: str) -> bool:\n        return char in '()'\n    \n    def _is_whitespace(self, char: str) -> bool:\n        return char.isspace()\n    \n    def _peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def _advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return ''\n    \n    def _skip_whitespace(self):\n        while self._is_whitespace(self._peek()):\n            self._advance()\n    \n    def _parse_number(self) -> Token:\n        start = self.position\n        has_decimal = False\n        \n        while self._peek() and (self._is_digit(self._peek()) or self._is_decimal(self._peek())):\n            if self._is_decimal(self._peek()):\n                if has_decimal:\n                    break\n                has_decimal = True\n            self._advance()\n        \n        value = self.expression[start:self.position]\n        return Token('NUMBER', float(value))\n    \n    def _parse_token(self) -> Token:\n        self._skip_whitespace()\n        \n        if not self._peek():\n            return Token('EOF', '')\n        \n        char = self._peek()\n        \n        if self._is_operator(char):\n            # Check if this is a negat",
          "time_taken": 395.55510234832764
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法，时间复杂度为O(n log n)。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理空列表和单元素列表的边界情况\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不被修改\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1, 9],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原列表: {original}\")\n        print(f\"  排序后: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 366.10140013694763
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_function(x: int, y: str, z: typing.List[int]) -> typing.Dict[str, int]:\n        return {y: x}\n    \n    ",
          "time_taken": 36.63882374763489
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Callable, Type, Union, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，用于自动重试函数调用。\n    \n    Args:\n        max_retries: 最大重试次数（不包括首次调用）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay}s...\")\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. No more retries.\")\n                \n                raise last_exception\n            \n            return async_wrapper\n        else:\n            # 同步函数处理\n            @functools.wraps(func)\n            def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return func(",
          "time_taken": 331.38392305374146
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (still in cache)\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 344.23634910583496
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持添加阶段、顺序处理数据和批量并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return result\n    \n    async def process_batch(self, items: L",
          "time_taken": 24.320063829421997
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\n\n@dataclass(order=True)\nclass PrioritizedTask:\n    \"\"\"表示具有优先级的任务\"\"\"\n    priority: int\n    task_id: int = field(compare=False)\n    fn: Callable = field(compare=False)\n    args: tuple = field(compare=False)\n    kwargs: dict = field(compare=False)\n    timeout: Optional[float] = field(compare=False)\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务执行结果的包装类\"\"\"\n    \n    def __init__(self, task_id: int, task_pool: 'TaskPool'):\n        super().__init__()\n        self._task_id = task_id\n        self._task_pool = task_pool\n        self._result = None\n        self._exception = None\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的原始异常\n            TimeoutError: 超时异常\n        \"\"\"\n        # 等待任务完成\n        if not self.done():\n            # 从任务池获取结果\n            try:\n                result = self._task_pool._get_result(self._task_id, timeout)\n                if isinstance(result, Exception):\n                    raise result\n                return result\n            except queue.Empty:\n                raise TimeoutError(\"Task timed out\")\n        \n        # 如果任务已完成，直接返回结果或异常\n        if self._exception:\n            raise self._exception\n        return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    该类提供了一个基于线程的并发任务执行池，支持任务提交、批量执行、\n    优雅关闭以及任务优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大并发工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self._max_workers = max_wor",
          "time_taken": 363.0649631023407
        }
      ],
      "elapsed_seconds": 656.8
    },
    {
      "round": 356,
      "timestamp": 1771234787.217238,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return ''\n    \n    def skip_whitespace(self):\n        while self.peek().isspace():\n            self.advance()\n    \n    def read_number(self) -> float:\n        # Read a number (integer or float) from current position\n        start = self.position\n        while self.peek() and (self.peek().isdigit() or self.peek() == '.'):\n            self.advance()\n        return float(self.expression[start:self.position])\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        tokens = []\n        \n        while self.position < len(self.expression):\n            self.skip_whitespace()\n            \n            if self.peek() == '':\n                break\n                \n            char = self.peek()\n            \n            if char.isdigit() or char == '.':\n                # Handle number (including float)\n                num = self.read_number()\n                tokens.append(Token('NUMBER', num))\n            elif char == '+':\n                tokens.append(Token('+', '+'))\n                self.advance()\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.position == 0 or self.expression[self.position - 1] == '(':\n                    # Negative number: check if next char is digit or ",
          "time_taken": 23.880170822143555
        }
      ],
      "elapsed_seconds": 24.3
    },
    {
      "round": 357,
      "timestamp": 1771234807.556725,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[int, float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.pos < len(self.expression):\n            return self.expression[self.pos]\n        return ''\n    \n    def consume(self) -> str:\n        if self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            self.pos += 1\n            return char\n        return ''\n    \n    def is_digit(self, char: str) -> bool:\n        return char.isdigit()\n    \n    def is_decimal_point(self, char: str) -> bool:\n        return char == '.'\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.pos = 0\n        \n        while self.pos < len(self.expression):\n            char = self.peek()\n            \n            if char.isspace():\n                self.consume()\n                continue\n                \n            if char in '+-*/()':\n                self.tokens.append(Token(char, char))\n                self.consume()\n                continue\n            \n            if self.is_digit(char):\n                # Parse number (integer or float)\n                num_str = ''\n                is_float = False\n                \n                while self.pos < len(self.expression):\n                    c = self.peek()\n                    if self.is_digit(c):\n                        num_str += c\n                        self.consume()\n                    elif self.is_decimal_point(c):\n                        num_str += c\n                        is_float = True\n                        self.consume()\n                    else:\n                        break\n                \n                if is_float:\n                    s",
          "time_taken": 19.87016487121582
        }
      ],
      "elapsed_seconds": 20.3
    },
    {
      "round": 358,
      "timestamp": 1771234830.6149812,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass TokenType:\n    NUMBER = \"NUMBER\"\n    PLUS = \"PLUS\"\n    MINUS = \"MINUS\"\n    MULTIPLY = \"MULTIPLY\"\n    DIVIDE = \"DIVIDE\"\n    LPAREN = \"LPAREN\"\n    RPAREN = \"RPAREN\"\n    EOF = \"EOF\"\n\nclass Token:\n    def __init__(self, type_: str, value: Union[float, str] = None):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.pos = 0\n        self.current_char = self.expression[self.pos] if self.expression else None\n    \n    def advance(self):\n        \"\"\"Move to the next character in the expression.\"\"\"\n        self.pos += 1\n        if self.pos >= len(self.expression):\n            self.current_char = None\n        else:\n            self.current_char = self.expression[self.pos]\n    \n    def skip_whitespace(self):\n        \"\"\"Skip whitespace characters.\"\"\"\n        while self.current_char and self.current_char.isspace():\n            self.advance()\n    \n    def read_number(self) -> Token:\n        \"\"\"Read a number (integer or float) from the input.\"\"\"\n        num_str = \"\"\n        while self.current_char and (self.current_char.isdigit() or self.current_char == '.'):\n            num_str += self.current_char\n            self.advance()\n        return Token(TokenType.NUMBER, float(num_str))\n    \n    def tokenize(self) -> List[Token]:\n        \"\"\"Convert the expression string into a list of tokens.\"\"\"\n        tokens = []\n        while self.current_char is not None:\n            self.skip_whitespace()\n            \n            if self.current_char is None:\n                break\n                \n            if self.current_char.isdigit() or self.current_char == '.':\n                # Handle numbers\n                tokens.append(self.read_number())\n            elif self.current_char == '+':\n                tokens.append(Token(TokenType.PLUS))\n              ",
          "time_taken": 22.556151866912842
        }
      ],
      "elapsed_seconds": 22.9
    },
    {
      "round": 359,
      "timestamp": 1771234831.119678,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=70)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=20)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=35)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 360,
      "timestamp": 1771235509.57994,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算后续的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")  # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")  # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")  # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")  # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 209.07748198509216
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    它将数组分成两半，递归地对两半进行排序，然后将排序后的两半合并。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表（原列表不变）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原列表: {original}\")\n        print(f\"  排序后: {sorted_result}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 224.3693118095398
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 14, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/dataclasses.py\", line 1013, in wrap\n    return _process_class(cls, init, repr, eq, order, unsafe_hash, frozen)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/dataclasses.py\", line 970, in _process_class\n    raise TypeError(f'Cannot overwrite attribute {name} '\nTypeError: Cannot overwrite attribute __lt__ in class PriorityTask. Consider using functools.total_ordering",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Any, Callable, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\nfrom functools import total_ordering\n\n@dataclass(order=True)\n@total_ordering\nclass PriorityTask:\n    \"\"\"任务包装类，支持优先级比较\"\"\"\n    priority: int\n    task_id: int = field(compare=False)\n    func: Callable = field(compare=False)\n    args: tuple = field(compare=False)\n    kwargs: dict = field(compare=False)\n    timeout: Optional[float] = field(compare=False)\n    \n    def __lt__(self, other):\n        # 优先级高的任务先执行\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        # 优先级相同时，按任务ID排序\n        return self.task_id < other.task_id\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务结果包装类\"\"\"\n    \n    def __init__(self, task_id: int, task_pool: 'TaskPool'):\n        super().__init__()\n        self._task_id = task_id\n        self._task_pool = task_pool\n        self._result = None\n        self._exception = None\n        \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 如果任务执行失败，抛出原始异常\n            TimeoutError: 如果超时\n        \"\"\"\n        # 等待任务完成\n        if not self._done():\n            # 如果任务池已关闭且任务未完成，则直接抛出异常\n            if not self._task_pool._running:\n                raise RuntimeError(\"TaskPool has been shut down\")\n            \n            # 等待任务完成\n            self._wait(timeout)\n            \n        if self._exception:\n            raise self._exception\n            \n        return self._result\n        \n    def _set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        self._result = result\n        self.set_result(result)\n        \n    def _set_exception(self, exception: Exception):\n        \"\"\"设置任务异常\"\"\"\n        self._excepti",
          "time_taken": 389.1151649951935
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List, Union\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.tokens: List[Token] = []\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.pos = 0\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char in \"+-*/()\":\n                self.tokens.append(Token(char, char))\n                self.pos += 1\n            elif char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                number_str = self.expression[start:self.pos]\n                self.tokens.append(Token(\"NUMBER\", float(number_str)))\n            else:\n                raise ValueError(f\"Unexpected character: {char}\")\n        \n        return self.tokens\n\nclass Parser:\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.pos = 0\n    \n    def peek(self) -> Token:\n        if self.pos < len(self.tokens):\n            return self.tokens[self.pos]\n        return Token(\"EOF\", None)\n    \n    def consume(self, expected_type: str) -> Token:\n        token = self.peek()\n        if token.type == expected_type:\n            self.pos += 1\n            return token\n        else:\n            raise ValueError(f\"Expected {expected_type}, got {token.type}\")\n    \n    def parse_expression(self) -> float:\n        \"\"\"Parse addition and subtraction (lowest precedence)\"\"\"",
          "time_taken": 224.8909568786621
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型原型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取泛型参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型（包括 Optional）\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数，只检查是否为 list\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数，只检查是否为 dict\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底处理\n    else:\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # 获取函数签名和绑定参数\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeErr",
          "time_taken": 48.97487998008728
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Union, Tuple, Any\n\n# 设置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[TypeVar, ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，用于自动重试函数调用\n    \n    Args:\n        max_retries: 最大重试次数（不包括首次调用）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟倍数\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        if asyncio.iscoroutinefunction(func):\n            # 异步函数处理\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay} seconds...\")\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. No more retries.\")\n                            raise\n                raise last_exception\n            \n            return async_wrapper\n        else:\n            # 同步函数处理\n            @functools.wraps(func)\n            def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n  ",
          "time_taken": 186.0521001815796
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段的处理。\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[Any],",
          "time_taken": 19.988940954208374
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)  # This should evict \"b\" (least recently used)\n    print(cache.get(\"b\"))  # Should return None (evicted)\n    print(cache.get(\"a\"))  # Should return 1 (still in cache)\n    print(cache.get(\"d\"))  # Should return 4 (still in cache)\n",
          "time_taken": 201.0544331073761
        }
      ],
      "elapsed_seconds": 678.3
    },
    {
      "round": 361,
      "timestamp": 1771235541.942803,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\n\n@dataclass(order=True)\nclass PrioritizedTask:\n    \"\"\"表示具有优先级的任务\"\"\"\n    priority: int\n    task_id: int = field(compare=False)\n    fn: Callable = field(compare=False)\n    args: tuple = field(compare=False)\n    kwargs: dict = field(compare=False)\n    timeout: Optional[float] = field(compare=False)\n    # 添加一个用于排序的字段，避免None与任务元组直接比较\n    _order: int = field(default=0, compare=False)\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务执行结果的包装类\"\"\"\n    \n    def __init__(self, task_id: int, task_pool: 'TaskPool'):\n        super().__init__()\n        self._task_id = task_id\n        self._task_pool = task_pool\n        self._result = None\n        self._exception = None\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的原始异常\n            TimeoutError: 超时异常\n        \"\"\"\n        # 等待任务完成\n        if not self.done():\n            # 从任务池获取结果\n            try:\n                result = self._task_pool._get_result(self._task_id, timeout)\n                if isinstance(result, Exception):\n                    raise result\n                return result\n            except queue.Empty:\n                raise TimeoutError(\"Task timed out\")\n        \n        # 如果任务已完成，直接返回结果或异常\n        if self._exception:\n            raise self._exception\n        return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    该类提供了一个基于线程的并发任务执行池，支持任务提交、批量执行、\n    优雅关闭以及任务优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大并发工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueEr",
          "time_taken": 31.71603298187256
        }
      ],
      "elapsed_seconds": 32.3
    },
    {
      "round": 362,
      "timestamp": 1771235569.8538501,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom queue import PriorityQueue\nimport heapq\n\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    代表一个异步任务的未来结果。\n    \n    与 concurrent.futures.Future 相似，但提供了更明确的超时和异常处理。\n    \"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: BaseException) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务未完成则等待。\n        \n        Args:\n            timeout: 等待超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            TimeoutError: 等待超时\n            Exception: 任务执行时抛出的异常\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n            \n            return self._result\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现。\n    \n    提供提交单个任务、批量执行任务、优雅关闭等功能。\n    支持任务优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池。\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self._max_workers = max_workers\n        self._workers: List[thr",
          "time_taken": 27.2528018951416
        }
      ],
      "elapsed_seconds": 27.8
    },
    {
      "round": 363,
      "timestamp": 1771235653.244433,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Any, Callable, List, Optional, Tuple, Union\nfrom queue import PriorityQueue\nimport heapq\n\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务的未来结果对象，继承自 concurrent.futures.Future\n    \n    提供了对任务结果的异步访问和超时控制。\n    \"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务失败则抛出原始异常\n        \n        Args:\n            timeout: 等待结果的超时时间（秒）\n            \n        Returns:\n            任务的执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n            TimeoutError: 超时未获取到结果\n        \"\"\"\n        return super().result(timeout)\n    \n    @property\n    def task_id(self) -> int:\n        \"\"\"获取任务ID\"\"\"\n        return self._task_id\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现\n    \n    提供了提交单个任务、批量执行任务、优雅关闭等功能。\n    支持任务优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self._max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = PriorityQueue()\n        self._results: dict[int, Future] = {}\n        self._shutdown_event = threading.Event()\n        self._task_counter = 0\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPool-Worker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执",
          "time_taken": 82.70158386230469
        }
      ],
      "elapsed_seconds": 83.3
    },
    {
      "round": 364,
      "timestamp": 1771261739.2000818,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=71)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=21)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=36)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 365,
      "timestamp": 1771262428.3408508,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算剩余的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 326.9990539550781
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入列表进行归并排序。\n    \n    归并排序是一种分治算法，通过递归地将数组分成两半，\n    然后将已排序的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n        assert test",
          "time_taken": 341.748007774353
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.tokens: List[Token] = []\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        self.pos = 0\n        self.tokens = []\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.pos\n                while self.pos < len(self.expression) and (\n                    self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'\n                ):\n                    self.pos += 1\n                value = self.expression[start:self.pos]\n                self.tokens.append(Token('NUMBER', float(value)))\n                \n            elif char == '+' or char == '-' or char == '*' or char == '/':\n                # Check if this is a unary minus\n                if char == '-' and (\n                    self.pos == 0 or \n                    self.expression[self.pos - 1] in '(+-*/'\n                ):\n                    # This is a unary minus, parse the following number\n                    start = self.pos\n                    self.pos += 1  # Skip the minus sign\n                    # Now parse the number that follows\n                    while self.pos < len(self.expression) and (\n                        self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'\n                    ):\n                        self.pos += 1\n                    value = self.expression[start:self.pos]\n                    self.to",
          "time_taken": 290.0358979701996
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果origin不是已知的容器类型，尝试使用isinstance检查\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, z: typing.Optional[typing.List[int]] = None) -> str:\n    ",
          "time_taken": 36.0652129650116
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Callable, Type, Tuple, Union, Any\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟倍数，每次重试延迟时间会乘以该值\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay} seconds...\")\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.info(f\"All {max_retries + 1} attempts failed with {type(e).__name__}: {e}\")\n                        raise e\n            \n            # 理论上不会执行到这里\n            raise last_exception\n            \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retrie",
          "time_taken": 301.44767904281616
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序执行和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"fn must be callable\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, fn: Callable, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息\n        \n        Args:\n            stage_name: 阶段名称\n            fn: 阶段处理函数\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        start_time = time.time()\n        try:\n            if asyncio.iscoroutinefunction(fn):\n                result = await fn(data)\n            else:\n                result = fn(data)\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            return result\n        except Exception as e:\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name, fn in self.stages.items():\n            result = await self._process_single_stage(stage_name, fn, result)\n        return result\n    \n    async def process_batch(self, items: List[",
          "time_taken": 22.594448804855347
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test basic functionality\n    cache = LRUCache(2)\n    \n    cache.put(1, \"value1\")\n    cache.put(2, \"value2\")\n    print(cache.get(1))  # Should return \"value1\"\n    \n    cache.put(3, \"value3\")  # This should evict key 2\n    print(cache.get(2))  # Should return None\n    \n    # Test TTL functionality\n    cache.put(4, \"value4\", ttl=1)  # 1 second TTL\n    print(cache.get(4))  # Should return \"value4\"\n    time.sleep(1.1)\n    print(cache.get(4))  # Should return None (expired)\n    \n    # Test LRU eviction\n    cache.put(5, \"value5\")\n    cache.put(6, \"value6\")\n    print(cache.get(5))  # Should return None (evicted due to LRU)\n    print(cache.get(6))  # Should return \"value6\"\n",
          "time_taken": 317.146733045578
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 230, in <module>\n  File \"<string>\", line 36, in result\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/concurrent/futures/_base.py\", line 447, in result\n    raise TimeoutError()\nconcurrent.futures._base.TimeoutError",
          "code_generated": "import threading\nimport queue\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Any, Callable, List, Optional, Tuple, Union\nfrom queue import PriorityQueue\nimport time\n\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务的未来结果对象，继承自 concurrent.futures.Future\n    \n    提供了任务结果的获取和超时处理功能\n    \"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的原始异常\n            TimeoutError: 超时异常\n        \"\"\"\n        return super().result(timeout)\n    \n    def exception(self, timeout: Optional[float] = None) -> Optional[BaseException]:\n        \"\"\"\n        获取任务执行异常\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行异常或 None\n        \"\"\"\n        return super().exception(timeout)\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池实现任务的并发执行，支持任务提交、批量执行、优先级和超时控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self._max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue: PriorityQueue = PriorityQueue()\n        self._futures: dict[int, Future] = {}\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._task_id_counter = 0\n        self._task_id_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def _get_next_task_id(self) -> int:\n        \"\"\"获取下",
          "time_taken": 424.53245878219604
        }
      ],
      "elapsed_seconds": 689.1
    },
    {
      "round": 366,
      "timestamp": 1771262470.655169,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Any, Callable, List, Optional, Tuple, Union\nfrom queue import PriorityQueue\nimport heapq\n\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务的未来结果对象，继承自 concurrent.futures.Future\n    \n    提供了对任务结果的异步访问和超时控制。\n    \"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务失败则抛出原始异常\n        \n        Args:\n            timeout: 等待结果的超时时间（秒）\n            \n        Returns:\n            任务的执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n            TimeoutError: 超时未获取到结果\n        \"\"\"\n        return super().result(timeout)\n    \n    @property\n    def task_id(self) -> int:\n        \"\"\"获取任务ID\"\"\"\n        return self._task_id\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现\n    \n    提供了提交单个任务、批量执行任务、优雅关闭等功能。\n    支持任务优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数，默认为4\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self._max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = PriorityQueue()\n        self._results: dict[int, Future] = {}\n        self._shutdown_event = threading.Event()\n        self._task_counter = 0\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPool-Worker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执",
          "time_taken": 41.754990100860596
        }
      ],
      "elapsed_seconds": 42.2
    },
    {
      "round": 367,
      "timestamp": 1771262499.775319,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Any, Callable, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务类，支持优先级比较\"\"\"\n    priority: int\n    task_id: int\n    func: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float] = None\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"优先级比较，数值越小优先级越高\"\"\"\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        return self.task_id < other.task_id\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务结果的 Future 对象\"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n        \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n            TimeoutError: 超时异常\n        \"\"\"\n        return super().result(timeout)\n    \n    def exception(self, timeout: Optional[float] = None) -> Optional[Exception]:\n        \"\"\"\n        获取任务异常\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务异常或 None\n        \"\"\"\n        return super().exception(timeout)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现，支持任务提交、批量执行、超时控制和优先级调度。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self._max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._futures: dict[int, Future] = {}\n        self._shutdown_event = threading.Eve",
          "time_taken": 28.58868098258972
        }
      ],
      "elapsed_seconds": 29.0
    },
    {
      "round": 368,
      "timestamp": 1771262673.717234,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom queue import PriorityQueue\nimport functools\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务执行结果的包装类，支持超时等待和异常处理\n    \"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，支持超时等待\n        \n        Args:\n            timeout: 等待超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的原始异常\n            TimeoutError: 等待超时\n        \"\"\"\n        try:\n            return super().result(timeout)\n        except Exception as e:\n            # 重新抛出原始异常\n            raise e\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现\n    \n    支持提交单个任务、批量任务执行、任务优先级和超时控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self._max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._futures: dict[int, Future] = {}\n        self._task_counter = 0\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数值越小优先级越高）\n            timeo",
          "time_taken": 173.36546397209167
        }
      ],
      "elapsed_seconds": 173.8
    },
    {
      "round": 369,
      "timestamp": 1771262674.227645,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=72)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=22)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=5)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=37)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 370,
      "timestamp": 1771262988.120804,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方式计算后续的斐波那契数\n    # 从第3个数开始计算\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能（大数值测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 121.38042378425598
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理空列表和单元素列表的边界情况\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保原列表不变\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序左右两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并已排序的两半\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 已排序的左列表\n        right: 已排序的右列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余的元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试各种情况\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4],          # 已排序列表\n        [4, 3, 2, 1],          # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {original} -> {sorted_result}\")\n        # 验证原列表未被修改\n        assert test_case == ",
          "time_taken": 134.13376784324646
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def tokenize(self) -> List[Token]:\n        self.position = 0\n        self.tokens = []\n        \n        while self.position < len(self.expression):\n            char = self.expression[self.position]\n            \n            if char.isspace():\n                self.position += 1\n                continue\n                \n            elif char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.position\n                while self.position < len(self.expression) and (\n                    self.expression[self.position].isdigit() or \n                    self.expression[self.position] == '.'\n                ):\n                    self.position += 1\n                value = self.expression[start:self.position]\n                self.tokens.append(Token(\"NUMBER\", float(value)))\n                \n            elif char == '+' or char == '-' or char == '*' or char == '/':\n                # Handle negative numbers\n                if char == '-' and (\n                    self.position == 0 or \n                    self.expression[self.position - 1] == '('\n                ):\n                    # This is a negative sign, not subtraction\n                    start = self.position\n                    self.position += 1\n                    # Look ahead for digits\n                    while self.position < len(self.expression) and (\n                        self.expression[self.position].isdigit() or \n                        self.expression[self.position] == '.'\n                    ):\n                        self.position += 1\n              ",
          "time_taken": 79.39289879798889
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 255, in <module>\n  File \"<string>\", line 203, in shutdown\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 150, in put\n    self._put(item)\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/queue.py\", line 236, in _put\n    heappush(self.queue, item)\nTypeError: '<' not supported between instances of 'NoneType' and 'NoneType'",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom concurrent.futures import Executor\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass TaskPriority(Enum):\n    LOW = 3\n    NORMAL = 2\n    HIGH = 1\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类\"\"\"\n    func: Callable[..., Any]\n    args: Tuple[Any, ...]\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout: Optional[float] = None\n    future: 'Future' = field(default_factory=lambda: Future())\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"实现任务比较，优先级高的先执行\"\"\"\n        if self.priority != other.priority:\n            return self.priority.value < other.priority.value\n        # 如果优先级相同，按提交顺序执行\n        return id(self) < id(other)\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务结果的未来对象，支持超时等待\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: BaseException) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，支持超时等待\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            TimeoutError: 超时异常\n            Exception: 任务执行过程中抛出的异常\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise Time",
          "time_taken": 140.89725303649902
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, data: list[int]) -> dict[str, int]:\n        return {y: x}\n    \n    # 正确调用\n    try:\n        ",
          "time_taken": 35.69857406616211
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Union, Tuple, Any, Type\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n) -> Callable[[Callable], Callable]:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟倍数，每次重试延迟时间会乘以此值\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    \n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logging.warning(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay}s...\")\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logging.error(f\"All {max_retries + 1} attempts failed with {type(e).__name__}: {e}\")\n                        raise\n            raise RuntimeError(\"Unreachable code\")\n        \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logging.warning(f\"Attempt {attempt + 1}",
          "time_taken": 98.73769497871399
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += time.time() - start_time\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return ",
          "time_taken": 23.849353075027466
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 113.3438708782196
        }
      ],
      "elapsed_seconds": 313.8
    },
    {
      "round": 371,
      "timestamp": 1771263639.958008,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 237, in <module>\n  File \"<string>\", line 38, in result\n  File \"<string>\", line 35, in result\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/concurrent/futures/_base.py\", line 447, in result\n    raise TimeoutError()\nconcurrent.futures._base.TimeoutError",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom queue import PriorityQueue\nimport functools\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务执行结果的包装类，支持超时等待和异常处理\n    \"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，支持超时等待\n        \n        Args:\n            timeout: 等待超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的原始异常\n            TimeoutError: 等待超时\n        \"\"\"\n        try:\n            return super().result(timeout)\n        except Exception as e:\n            # 重新抛出原始异常\n            raise e\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现\n    \n    支持提交单个任务、批量任务执行、任务优先级和超时控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self._max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._futures: dict[int, Future] = {}\n        self._task_counter = 0\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数值越小优先级越高）\n            timeo",
          "time_taken": 474.3925549983978
        }
      ],
      "elapsed_seconds": 651.7
    },
    {
      "round": 372,
      "timestamp": 1771263731.976254,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom queue import PriorityQueue\nimport functools\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务执行结果的包装类，支持超时等待和异常处理\n    \"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，支持超时等待\n        \n        Args:\n            timeout: 等待超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的原始异常\n            TimeoutError: 等待超时\n        \"\"\"\n        try:\n            return super().result(timeout)\n        except Exception as e:\n            # 重新抛出原始异常\n            raise e\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现\n    \n    支持提交单个任务、批量任务执行、任务优先级和超时控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self._max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._futures: dict[int, Future] = {}\n        self._task_counter = 0\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数值越小优先级越高）\n            timeo",
          "time_taken": 89.74485492706299
        }
      ],
      "elapsed_seconds": 91.9
    },
    {
      "round": 373,
      "timestamp": 1771263979.95245,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 226, in <module>\n  File \"<string>\", line 60, in result\nTimeoutError: Task timed out",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Any, Callable, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom heapq import heappush, heappop\n\n@dataclass\nclass Task:\n    \"\"\"任务数据类，用于优先级队列比较\"\"\"\n    priority: int\n    task_id: int\n    fn: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float] = None\n    \n    def __lt__(self, other):\n        \"\"\"优先级队列比较方法\"\"\"\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        return self.task_id < other.task_id\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务结果的 Future 对象\"\"\"\n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n\n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行时抛出的异常\n            TimeoutError: 超时\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                # 等待任务完成\n                if timeout is not None:\n                    # 等待直到超时或完成\n                    end_time = time.time() + timeout\n                    while not self._done:\n                        remaining = end_time - time.time()\n                        if remaining <= 0:\n                            raise TimeoutError(\"Task timed out\")\n                        self._condition.wait(timeout=remaining)\n                else:\n                    # 无超时等待\n                    while not self._done:\n                        self._condition.wait()\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n\n    def set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        w",
          "time_taken": 119.04970693588257
        }
      ],
      "elapsed_seconds": 247.9
    },
    {
      "round": 374,
      "timestamp": 1771276327.519457,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=73)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=23)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=6)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=38)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom queue import PriorityQueue\nimport functools\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务执行结果的包装类，支持超时等待和异常处理\n    \"\"\"\n    \n    def __init__(self, task_id: int):\n        super().__init__()\n        self._task_id = task_id\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，支持超时等待\n        \n        Args:\n            timeout: 等待超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的原始异常\n            TimeoutError: 等待超时\n        \"\"\"\n        try:\n            return super().result(timeout)\n        except Exception as e:\n            # 重新抛出原始异常\n            raise e\n\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现\n    \n    支持提交单个任务、批量任务执行、任务优先级和超时控制\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self._max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._futures: dict[int, Future] = {}\n        self._task_counter = 0\n        self._lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交一个任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数值越小优先级越高）\n            timeo",
          "time_taken": 32.57953882217407
        }
      ],
      "elapsed_seconds": 33.1
    },
    {
      "round": 375,
      "timestamp": 1771276459.3314822,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n<=0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理第一个数\n    if n >= 1:\n        result.append(0)\n    \n    # 处理第二个数\n    if n >= 2:\n        result.append(1)\n    \n    # 计算剩余的斐波那契数\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 116.31895399093628
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        >>> merge_sort([])\n        []\n        >>> merge_sort([42])\n        [42]\n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 2, 8, 1],          # 无序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_result = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_result}\")\n        print(f\"",
          "time_taken": 129.43202567100525
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.tokens = []\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.pos = 0\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n                \n            elif char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                value = self.expression[start:self.pos]\n                self.tokens.append(Token('NUMBER', float(value)))\n                \n            elif char == '(':\n                self.tokens.append(Token('LPAREN', char))\n                self.pos += 1\n                \n            elif char == ')':\n                self.tokens.append(Token('RPAREN', char))\n                self.pos += 1\n                \n            elif char == '*':\n                self.tokens.append(Token('MUL', char))\n                self.pos += 1\n                \n            elif char == '/':\n                self.tokens.append(Token('DIV', char))\n                self.pos += 1\n                \n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] == '(':\n                    # This is a negative sign, not subtraction\n                    # Check if next character is a digit or dot\n                    if self.pos + 1 < le",
          "time_taken": 79.55403780937195
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom queue import PriorityQueue\nimport heapq\n\nclass Future:\n    \"\"\"\n    Future 类表示一个异步任务的结果。\n    \"\"\"\n    def __init__(self):\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: BaseException):\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务未完成会阻塞等待。\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 如果任务执行过程中抛出异常\n            TimeoutError: 如果等待超时\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task result retrieval timed out\")\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n    \n    def done(self) -> bool:\n        \"\"\"判断任务是否完成\"\"\"\n        with self._condition:\n            return self._done\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现。\n    \n    Example:\n        pool = TaskPool(max_workers=4)\n        future = pool.submit(lambda x: x*2, 21)\n        result = future.result()  # 返回 42\n        pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise",
          "time_taken": 57.81974220275879
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底情况\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例使用\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(name: str, age: int, hobbies: list[str], info: dict[str, int]) -> str:\n        return f\"{name} is {age} yea",
          "time_taken": 34.930155992507935
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Type, Union, Awaitable\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为同步和异步函数添加自动重试功能。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次尝试）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟倍数增长因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        if asyncio.iscoroutinefunction(func):\n            @functools.wraps(func)\n            async def async_wrapper(*args, **kwargs) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logging.warning(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}\")\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logging.error(f\"All {max_retries + 1} attempts failed with {type(e).__name__}: {e}\")\n                            raise\n                raise last_exception  # This line should never be reached\n            \n            return async_wrapper\n        else:\n            @functools.wraps(func)\n            def sync_wrapper(*args, **kwargs) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return func(*args, **kwargs)\n                    except exceptions as e:\n                        last_ex",
          "time_taken": 90.16451478004456
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create an LRU cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test updating existing key\n    cache.put(\"a\", 10)\n    print(cache.get(\"a\"))  # Should return 10\n",
          "time_taken": 105.92777585983276
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理类，支持添加处理阶段、顺序执行和并发处理。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise e\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, result)\n        return",
          "time_taken": 23.689449071884155
        }
      ],
      "elapsed_seconds": 131.7
    },
    {
      "round": 376,
      "timestamp": 1771277729.5803058,
      "passed": 7,
      "total": 8,
      "avg_score": 8.06,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Execution timed out (60s)",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Iterator\nfrom collections import namedtuple\nimport uuid\n\n# 用于任务优先级排序的元组结构\nTaskItem = namedtuple('TaskItem', ['priority', 'seq', 'payload'])\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务结果的未来值对象\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: BaseException) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"获取任务结果，超时则抛出异常\"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task did not complete within the specified timeout\")\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n\nclass TaskPool:\n    \"\"\"可复用的并发任务池，基于线程实现\"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._seq_counter = 0\n        self._seq_lock = threading.Lock()\n        \n  ",
          "time_taken": 1105.6816601753235
        }
      ],
      "elapsed_seconds": 1270.1
    },
    {
      "round": 377,
      "timestamp": 1771277758.2955148,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom queue import PriorityQueue\n\nclass Future:\n    \"\"\"\n    Future 类表示一个异步任务的结果。\n    \"\"\"\n    def __init__(self):\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: BaseException):\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务未完成会阻塞等待。\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 如果任务执行过程中抛出异常\n            TimeoutError: 如果等待超时\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task result retrieval timed out\")\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n    \n    def done(self) -> bool:\n        \"\"\"判断任务是否完成\"\"\"\n        with self._condition:\n            return self._done\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现。\n    \n    Example:\n        pool = TaskPool(max_workers=4)\n        future = pool.submit(lambda x: x*2, 21)\n        result = future.result()  # 返回 42\n        pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_wor",
          "time_taken": 28.154551029205322
        }
      ],
      "elapsed_seconds": 28.6
    },
    {
      "round": 378,
      "timestamp": 1771277790.007305,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom queue import PriorityQueue\nimport uuid\n\nclass Future:\n    \"\"\"\n    代表一个异步计算的结果。\n    \n    Attributes:\n        _result: 任务的返回值\n        _exception: 任务抛出的异常\n        _done: 任务是否已完成\n        _condition: 用于等待任务完成的条件变量\n    \"\"\"\n    \n    def __init__(self):\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务未完成会阻塞直到完成或超时。\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务的返回值\n            \n        Raises:\n            Exception: 如果任务抛出异常\n            TimeoutError: 如果超时\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n    \n    def exception(self, timeout: Optional[float] = None) -> Optional[Exception]:\n        \"\"\"\n        获取任务异常，如果任务未完成会阻塞直到完成或超时。\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务的异常，如果没有异常则返回 None\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(",
          "time_taken": 31.141303062438965
        }
      ],
      "elapsed_seconds": 31.6
    },
    {
      "round": 379,
      "timestamp": 1771277810.253116,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=74)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=24)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=7)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=39)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom queue import PriorityQueue\nimport heapq\n\nclass Future:\n    \"\"\"\n    代表一个异步任务的结果。\n    \"\"\"\n    def __init__(self):\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: Exception):\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果，如果任务失败则抛出原始异常。\n        \n        Args:\n            timeout: 等待超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n            TimeoutError: 等待超时\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Future result timeout\")\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n    \n    def done(self) -> bool:\n        \"\"\"检查任务是否完成\"\"\"\n        with self._condition:\n            return self._done\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现。\n    \n    Example:\n        pool = TaskPool(max_workers=4)\n        future = pool.submit(lambda x: x*2, 21)\n        result = future.result(5)  # 返回 42\n        pool.shutdown()\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_work",
          "time_taken": 19.661508083343506
        }
      ],
      "elapsed_seconds": 20.1
    },
    {
      "round": 380,
      "timestamp": 1771277979.688712,
      "passed": 8,
      "total": 8,
      "avg_score": 8.75,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 时间复杂度: O(n), 空间复杂度: O(n)\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证性能（大数测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 153.42693614959717
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    实现归并排序算法。\n    \n    归并排序是一种基于分治思想的稳定排序算法。它将数组递归地分成两半，\n    分别排序后合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的整数列表（升序）\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 基础情况：空列表或单元素列表已经有序\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保纯函数特性\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的数组\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        result = merge_sort(test_case)\n        print(f\"测试 {i+1}: {test_case} -> {result}\")\n",
          "time_taken": 167.16939496994019
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type_: str, value: Union[str, float]):\n        self.type = type_\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.tokens = []\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.pos = 0\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                start = self.pos\n                while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                    self.pos += 1\n                value = self.expression[start:self.pos]\n                self.tokens.append(Token(\"NUMBER\", float(value)))\n            elif char == '+':\n                self.tokens.append(Token(\"PLUS\", char))\n                self.pos += 1\n            elif char == '-':\n                # Check if this is a negative sign\n                if self.pos == 0 or self.expression[self.pos - 1] == '(':\n                    # It's a negative sign, so we need to parse the following number\n                    start = self.pos\n                    self.pos += 1\n                    # Look for a number after the minus\n                    while self.pos < len(self.expression) and (self.expression[self.pos].isdigit() or self.expression[self.pos] == '.'):\n                        self.pos += 1\n                    value = self.expression[start:self.pos]\n                    self.tokens.append(Token(\"NUMBER\", float(value)))\n                else:\n                    self.tokens.append(Token(\"MINUS\", char))\n      ",
          "time_taken": 113.18121695518494
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配指定的类型\"\"\"\n    # 处理 None 类型\n    if expected_type is type(None):\n        return value is None\n    \n    # 获取类型参数的原始类型\n    origin = typing.get_origin(expected_type)\n    \n    # 普通类型（如 int, str）\n    if origin is None:\n        return isinstance(value, expected_type)\n    \n    # 获取参数\n    args = typing.get_args(expected_type)\n    \n    # 处理 Union 类型\n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    # 处理 list 类型\n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        # 如果没有参数（如 List），只需要检查是 list 类型\n        if not args:\n            return True\n        # 检查所有元素是否匹配\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    # 处理 dict 类型\n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        # 如果没有参数（如 Dict），只需要检查是 dict 类型\n        if not args:\n            return True\n        # 检查所有键值对是否匹配\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误'",
          "time_taken": 36.07780313491821
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Type, Union, Awaitable\n\n# 设置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次执行）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n        \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. Retrying in {current_delay}s...\")\n                        time.sleep(current_delay)\n                        current_delay *= backoff\n                    else:\n                        logger.info(f\"Attempt {attempt + 1} failed with {type(e).__name__}: {e}. No more retries.\")\n                        raise\n            raise RuntimeError(\"Unreachable code\")\n            \n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs) -> T:\n            current_delay = delay\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries:\n                     ",
          "time_taken": 124.63515973091125
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\nfrom typing import Protocol\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现。\n    \n    该类提供提交单个任务、批量执行任务、优雅关闭等功能。\n    支持任务优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池。\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._executor_lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> \"Future\":\n        \"\"\"\n        提交任务到任务池。\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务结果的 Future 对象\n        \"\"\"\n        future = Future()\n        task = _Task(fn, args, kwargs, future, priority, timeout)\n        self._task_queue.put(task)\n        return future\n    \n    def map(self, fn: Callable, iterable: List[Any], priority: int = 0, timeout: Optional[float] = None) -> List[Any]:\n        \"\"\"\n        批量执行任务。\n        \n        Args:\n            fn: 要执行的函数\n            iterable: 参数列表\n            priority: 任务优先级\n            timeout: 任务超时时间（秒）\n            \n        Returns:\n            List[Any]: 执行结果列表\n        \"\"\"\n        fu",
          "time_taken": 90.88538599014282
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport inspect\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理器，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _execute_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        执行单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_func = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 记录成功统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._execute_stage(stage_name, result)\n        retur",
          "time_taken": 21.77049493789673
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        \"\"\"\n        初始化LRU缓存\n        \n        Args:\n            capacity: 缓存的最大容量\n        \"\"\"\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        \"\"\"\n        获取缓存中的值\n        \n        Args:\n            key: 要获取的键\n            \n        Returns:\n            如果键存在且未过期，返回对应的值；否则返回None\n        \"\"\"\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        \"\"\"\n        向缓存中添加或更新键值对\n        \n        Args:\n            key: 要添加或更新的键\n            value: 要存储的值\n            ttl: 过期时间（秒），如果为None则不过期\n        \"\"\"\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 创建一个容量为3的LRU缓存\n    cache = LRUCache(3)\n    \n    # 测试基本功能\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    cache.put(\"c\", 3)\n    \n    print(\"初始状态:\", cache.get(\"a\"))  # 应该返回1\n    print(\"初始状态:\", cache.get(\"b\"))  # 应该返回2\n    \n    # 测试LRU淘汰机制\n    cache.put(\"d\", 4)  # 应该淘汰\"a\"\n    print(\"淘汰测试:\", cache.get(\"a\"))  # 应该返回None\n    print(\"保留测试:\", cache.get(\"b\"))  # 应该返回2\n    \n    # 测试TTL功能\n    cache.put(\"e\", 5, ttl=1)  # 1秒后过期\n    print(\"TTL测试:\", cache.get(\"e\"))  # 应该返回5\n    time.sleep(1.1)  # 等待过期\n    print(\"TTL过期测试:\", cache.get(\"e\"))  # 应该返回None\n    \n    # 测试更新操作\n    cache.put(\"b\", 22)\n    ",
          "time_taken": 142.9074101448059
        }
      ],
      "elapsed_seconds": 169.3
    },
    {
      "round": 381,
      "timestamp": 1771277980.317792,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 382,
      "timestamp": 1771278253.4660952,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 383,
      "timestamp": 1771278254.0380318,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 384,
      "timestamp": 1771278254.607125,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=75)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=25)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=8)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=40)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 385,
      "timestamp": 1771278941.347649,
      "passed": 7,
      "total": 8,
      "avg_score": 8.12,
      "pass_rate": 0.875,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种分治算法，将数组分成两半，递归地对两半进行排序，\n    然后将排序后的两半合并成一个有序数组。\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，不修改原列表\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n        \n        >>> merge_sort([5, 2, 8, 1])\n        [1, 2, 5, 8]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以确保不修改原列表\n    \n    # 分治：将数组分成两半\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # 递归排序两半\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    # 合并两个已排序的数组\n    return _merge(left_sorted, right_sorted)\n\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 添加剩余的元素\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [3, 1, 4, 1, 5, 9, 2, 6],\n        [],\n        [42],\n        [5, 2, 8, 1],\n        [1, 1, 1, 1],\n        [5, 4, 3, 2, 1]\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        original = test_case.copy()\n        sorted_arr = merge_sort(test_case)\n        print(f\"测试 {i+1}:\")\n        print(f\"  原始: {original}\")\n        print(f\"  排序: {sorted_arr}\")\n        print(f\"  原列表未变: {test_case == original}\")\n        print()\n",
          "time_taken": 222.94447827339172
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 避免了指数级递归的效率问题\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")   # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")   # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")   # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")   # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\") # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
          "time_taken": 208.4824779033661
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union\n\nclass Token:\n    def __init__(self, type: str, value: Union[float, str]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.position = 0\n        self.tokens = []\n    \n    def peek(self) -> str:\n        if self.position < len(self.expression):\n            return self.expression[self.position]\n        return ''\n    \n    def advance(self) -> str:\n        if self.position < len(self.expression):\n            char = self.expression[self.position]\n            self.position += 1\n            return char\n        return ''\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.position = 0\n        \n        while self.position < len(self.expression):\n            char = self.peek()\n            \n            if char.isspace():\n                self.advance()\n                continue\n            \n            if char.isdigit() or char == '.':\n                # Parse number (including floats)\n                num_str = ''\n                while self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                    num_str += self.advance()\n                self.tokens.append(Token('NUMBER', float(num_str)))\n            elif char == '+' or char == '-' or char == '*' or char == '/':\n                # Check for unary minus\n                if char == '-' and (self.position == 0 or self.peek(self.position - 1) == '('):\n                    # This is a unary minus, so parse the following number\n                    num_str = '-'\n                    self.advance()\n                    while self.position < len(self.expression) and (self.peek().isdigit() or self.peek() == '.'):\n                        num_str += self.advance()\n                    self.tokens.append(Token('NUMBER', float(num_str)))\n         ",
          "time_taken": 171.62121295928955
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": false,
          "score": 5.0,
          "error": "Traceback (most recent call last):\n  File \"<string>\", line 234, in <module>\n  File \"<string>\", line 205, in test_task_pool\nAssertionError: submit test failed",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass\nfrom typing import Protocol\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    任务执行结果的 Future 对象\n    \n    该类继承自 concurrent.futures.Future，提供了任务执行结果的获取和超时处理功能。\n    \"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n\n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务执行结果，如果任务失败则抛出原始异常\n        \n        Args:\n            timeout: 等待结果的超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 如果任务执行失败，则抛出原始异常\n            TimeoutError: 如果等待超时\n        \"\"\"\n        if self._exception is not None:\n            raise self._exception\n        return self._result\n\n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务执行结果\"\"\"\n        self._result = result\n        super().set_result(result)\n\n    def set_exception(self, exception: BaseException) -> None:\n        \"\"\"设置任务执行异常\"\"\"\n        self._exception = exception\n        super().set_exception(exception)\n\n@dataclass\nclass Task:\n    \"\"\"任务数据结构\"\"\"\n    priority: int\n    seq: int\n    func: Callable\n    args: tuple\n    kwargs: dict\n    future: Future\n    \n    def __lt__(self, other: 'Task') -> bool:\n        \"\"\"用于优先队列比较\"\"\"\n        if self.priority != other.priority:\n            return self.priority < other.priority\n        return self.seq < other.seq\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    TaskPool 提供了提交任务、批量执行、优雅关闭等功能，支持任务优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n ",
          "time_taken": 467.86832094192505
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配期望的类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    \n    if origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    \n    if origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    \n    # 兜底情况\n    if isinstance(expected_type, type):\n        return isinstance(value, expected_type)\n    return True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        result = func(*args, **kwargs)\n        \n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 示例用法\nif __name__ == \"__main__\":\n    @type_check\n    def example_func(x: int, y: str, items: list[int], mapping: dict[str, int]) -> str:\n        return f\"{x}: {y} - {items} - {mapping}\"\n    \n    # 正确调用\n    try:\n       ",
          "time_taken": 58.88993191719055
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import Type, Callable, Union, Any, Awaitable\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Type[Exception] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，用于自动重试函数调用。\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次调用）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试后失败，抛出原始异常: {e}\")\n                        raise\n                    logger.info(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试失败: {e}，将在 {current_delay} 秒后重试\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            \n        @functools.wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -> Any:\n            current_delay = delay\n            for attempt in range(max_retries + 1):\n                try:\n                    result = await func(*args, **kwargs)\n                    return result\n                except exceptions as e:\n                    if attempt == max_retries:\n                        logger.error(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试后失败，抛出原始异常: {e}\")\n                        raise\n                    logger.info(f\"函数 {func.__name__} 在第 {attempt + 1} 次尝试失败: {e}，将在 {current_delay} 秒后重试\")\n                    await asyncio.sleep(current_delay)\n                    current_delay *= backoff\n   ",
          "time_taken": 182.6428680419922
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, List, Any, Callable, Optional, Union\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步管道处理器，支持顺序执行和并发处理阶段。\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段。\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数，可以是同步或异步函数\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段，记录统计信息。\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_fn = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_fn):\n                result = await stage_fn(data)\n            else:\n                result = stage_fn(data)\n            \n            # 更新统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 更新错误统计\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段。\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_stage(stage_name, ",
          "time_taken": 46.7796311378479
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test basic put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL expiration\n    cache.put(\"c\", 3, ttl=1)  # This entry expires in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)  # Wait for expiration\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity limit)\n    print(cache.get(\"d\"))  # Should return 4\n    print(cache.get(\"a\"))  # Should return 1\n",
          "time_taken": 198.15572309494019
        }
      ],
      "elapsed_seconds": 686.5
    },
    {
      "round": 386,
      "timestamp": 1771278976.0587862,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, field\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现。\n    \n    该类提供提交单个任务、批量执行任务、优雅关闭等功能。\n    支持任务优先级和超时控制。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池。\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self.max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = queue.PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._sequence_counter = 0\n        self._sequence_lock = threading.Lock()\n        \n        # 启动工作线程\n        for i in range(max_workers):\n            worker = threading.Thread(target=self._worker, name=f\"TaskPoolWorker-{i}\")\n            worker.daemon = True\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> \"Future\":\n        \"\"\"\n        提交任务到任务池。\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级，数值越小优先级越高\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务结果的 Future 对象\n        \"\"\"\n        future = Future()\n        with self._sequence_lock:\n            seq = self._sequence_counter\n            self._sequence_counter += 1\n        \n        task = _Task(fn, args, kwargs, future, priority, timeout, seq)\n        self._task_queue.put(task)\n        return future\n    \n    def map(self, fn: Callable, iterable: List[Any], priority: int = 0, timeout: Optional[float] = None) -> List[Any]:\n        \"\"\"\n        批量执行任务。\n        \n        Args:\n            fn: 要执行的函数\n            iterable: 参数列表\n            priori",
          "time_taken": 34.02694392204285
        }
      ],
      "elapsed_seconds": 34.5
    },
    {
      "round": 387,
      "timestamp": 1771279007.4710772,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nimport heapq\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom dataclasses import dataclass, field\nfrom collections import deque\n\n@dataclass\nclass Future:\n    \"\"\"\n    任务执行结果的包装类，用于获取任务执行的结果或异常。\n    \n    Attributes:\n        _result: 任务执行结果\n        _exception: 任务执行异常\n        _done: 任务是否已完成\n        _event: 用于等待任务完成的事件\n    \"\"\"\n    _result: Any = None\n    _exception: Exception = None\n    _done: bool = False\n    _event: threading.Event = field(default_factory=threading.Event)\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务执行结果，如果任务未完成则等待。\n        \n        Args:\n            timeout: 等待超时时间\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n            TimeoutError: 等待超时\n        \"\"\"\n        if not self._event.wait(timeout):\n            raise TimeoutError(\"Task timed out\")\n        \n        if self._exception:\n            raise self._exception\n        return self._result\n    \n    def exception(self, timeout: Optional[float] = None) -> Optional[Exception]:\n        \"\"\"\n        获取任务执行异常，如果任务未完成则等待。\n        \n        Args:\n            timeout: 等待超时时间\n            \n        Returns:\n            任务执行异常，如果没有异常则返回 None\n        \"\"\"\n        if not self._event.wait(timeout):\n            raise TimeoutError(\"Task timed out\")\n        \n        return self._exception\n    \n    def done(self) -> bool:\n        \"\"\"检查任务是否已完成\"\"\"\n        return self._done\n    \n    def set_result(self, result: Any) -> None:\n        \"\"\"设置任务执行结果\"\"\"\n        self._result = result\n        self._done = True\n        self._event.set()\n    \n    def set_exception(self, exception: Exception) -> None:\n        \"\"\"设置任务执行异常\"\"\"\n        self._exception = exception\n        self._done = True\n        self._event.set()\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池，使用线程实现。\n    \n    Args:\n        max_workers: 最大工作线程数，默认为 5\n    ",
          "time_taken": 30.752926111221313
        }
      ],
      "elapsed_seconds": 31.2
    },
    {
      "round": 388,
      "timestamp": 1771279317.365668,
      "passed": 8,
      "total": 8,
      "avg_score": 8.56,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport queue\nimport time\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom typing import Callable, Any, List, Optional, Tuple\nfrom dataclasses import dataclass\nfrom functools import total_ordering\n\n@total_ordering\n@dataclass\nclass Task:\n    \"\"\"任务包装类，支持优先级比较\"\"\"\n    priority: int\n    sequence: int\n    func: Callable\n    args: tuple\n    kwargs: dict\n    timeout: Optional[float]\n    \n    def __lt__(self, other):\n        if self.priority == other.priority:\n            return self.sequence < other.sequence\n        return self.priority < other.priority\n\nclass Future(ConcurrentFuture):\n    \"\"\"任务结果包装类\"\"\"\n    \n    def __init__(self, task: Task):\n        super().__init__()\n        self._task = task\n        \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务执行结果\n            \n        Raises:\n            Exception: 任务执行时抛出的异常\n            TimeoutError: 超时异常\n        \"\"\"\n        return super().result(timeout)\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程实现并发执行任务\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n            \n        self.max_workers = max_workers\n        self._work_queue = queue.PriorityQueue()\n        self._workers: List[threading.Thread] = []\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._sequence_counter = 0\n        self._worker_lock = threading.Lock()\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) ->",
          "time_taken": 308.03013706207275
        }
      ],
      "elapsed_seconds": 309.7
    },
    {
      "round": 389,
      "timestamp": 1771279317.9086132,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=76)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=26)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=9)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=3)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=41)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    },
    {
      "round": 390,
      "timestamp": 1771279445.349698,
      "passed": 8,
      "total": 8,
      "avg_score": 8.62,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率（大数值测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
          "time_taken": 112.36790585517883
        },
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以保证纯函数特性\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        result = merge_sort(test_case)\n        print(f\"测试用例 {i+1}: {test_case} -> {result}\")\n",
          "time_taken": 125.21961188316345
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.tokens = []\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.pos = 0\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char in '+-*/()':\n                if char == '-' and (self.pos == 0 or self.expression[self.pos-1] == '('):\n                    # This is a negative sign, not a minus operator\n                    # Look ahead to parse the number\n                    num_str = ''\n                    self.pos += 1  # Skip the '-'\n                    while self.pos < len(self.expression):\n                        next_char = self.expression[self.pos]\n                        if next_char.isdigit() or next_char == '.':\n                            num_str += next_char\n                            self.pos += 1\n                        else:\n                            break\n                    if num_str:\n                        # Check if it's a valid number\n                        try:\n                            if '.' in num_str:\n                                num_value = float(num_str)\n                            else:\n                                num_value = int(num_str)\n                            self.tokens.append(Token('NUMBER', -num_value))\n                        except ValueError:\n                            raise ValueError(f\"Invalid number: {num_str}\")\n                    else:\n                        # If there's no number after '-', it's an error\n                     ",
          "time_taken": 80.55584597587585
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom queue import PriorityQueue\nimport uuid\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    代表一个异步任务的结果\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: Exception):\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果或抛出异常\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n            TimeoutError: 超时\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行异步任务，支持任务提交、批量执行、超时控制和优先级。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self._max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._wo",
          "time_taken": 55.542521953582764
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果无法识别的类型，尝试使用 isinstance\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    @type_check\n    def test_func(x: int, y: str, z: typing.Optional[typing.List[int]] = None) -> str:\n        return f\"",
          "time_taken": 34.07861089706421
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Type, Union, Awaitable\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次执行）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        if asyncio.iscoroutinefunction(func):\n            @functools.wraps(func)\n            async def async_wrapper(*args, **kwargs) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logging.warning(f\"Attempt {attempt + 1} failed: {e}. Retrying in {current_delay}s...\")\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logging.error(f\"All {max_retries + 1} attempts failed. Last exception: {e}\")\n                            raise\n                raise last_exception\n            return async_wrapper\n        else:\n            @functools.wraps(func)\n            def sync_wrapper(*args, **kwargs) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_ret",
          "time_taken": 90.49714374542236
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 9.0,
          "error": "",
          "code_generated": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序处理和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_func = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage_name",
          "time_taken": 21.515843152999878
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 7.5,
          "error": "",
          "code_generated": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
          "time_taken": 102.11648416519165
        }
      ],
      "elapsed_seconds": 127.3
    },
    {
      "round": 391,
      "timestamp": 1771279445.850807,
      "passed": 8,
      "total": 8,
      "avg_score": 8.5,
      "pass_rate": 1.0,
      "tests_ok": true,
      "results": [
        {
          "task_id": "easy_sort",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=77)",
          "time_taken": 0.0
        },
        {
          "task_id": "easy_fibonacci",
          "difficulty": "easy",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=77)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_lru_cache",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=77)",
          "time_taken": 0.0
        },
        {
          "task_id": "med_decorator_retry",
          "difficulty": "medium",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=27)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_calc_parser",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=10)",
          "time_taken": 0.0
        },
        {
          "task_id": "hard_concurrent_pool",
          "difficulty": "hard",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=4)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_type_checker",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=28)",
          "time_taken": 0.0
        },
        {
          "task_id": "expert_async_pipeline",
          "difficulty": "expert",
          "passed": true,
          "score": 8.5,
          "error": "",
          "code_generated": "(skipped — streak=42)",
          "time_taken": 0.0
        }
      ],
      "elapsed_seconds": 0.4
    }
  ],
  "started_at": 1771008945.015143,
  "task_pass_streaks": {
    "easy_fibonacci": 77,
    "easy_sort": 77,
    "hard_calc_parser": 10,
    "expert_type_checker": 28,
    "expert_async_pipeline": 42,
    "med_lru_cache": 77,
    "med_decorator_retry": 27,
    "hard_concurrent_pool": 4
  },
  "task_best_code": {
    "easy_fibonacci": "from typing import List\n\ndef fibonacci(n: int) -> List[int]:\n    \"\"\"\n    返回前n个斐波那契数。\n    \n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n >= 2)\n    \n    Args:\n        n (int): 要返回的斐波那契数的个数\n        \n    Returns:\n        List[int]: 包含前n个斐波那契数的列表，如果n <= 0则返回空列表\n        \n    Examples:\n        >>> fibonacci(5)\n        [0, 1, 1, 2, 3]\n        >>> fibonacci(0)\n        []\n        >>> fibonacci(1)\n        [0]\n        >>> fibonacci(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    # 处理边界情况\n    if n <= 0:\n        return []\n    \n    # 初始化结果列表\n    result = []\n    \n    # 处理前两个特殊情况\n    if n >= 1:\n        result.append(0)\n    if n >= 2:\n        result.append(1)\n    \n    # 使用迭代方法计算后续的斐波那契数\n    # 避免了指数级递归的低效性\n    for i in range(2, n):\n        next_fib = result[i-1] + result[i-2]\n        result.append(next_fib)\n    \n    return result\n\n# 测试函数\nif __name__ == \"__main__\":\n    # 测试各种情况\n    print(f\"fibonacci(0) = {fibonacci(0)}\")    # []\n    print(f\"fibonacci(1) = {fibonacci(1)}\")    # [0]\n    print(f\"fibonacci(2) = {fibonacci(2)}\")    # [0, 1]\n    print(f\"fibonacci(5) = {fibonacci(5)}\")    # [0, 1, 1, 2, 3]\n    print(f\"fibonacci(10) = {fibonacci(10)}\")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # 验证效率（大数值测试）\n    print(f\"fibonacci(20) = {fibonacci(20)}\")\n",
    "easy_sort": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    对输入的整数列表进行归并排序。\n    \n    归并排序是一种稳定的、基于分治思想的排序算法。\n    时间复杂度：O(n log n)\n    空间复杂度：O(n)\n    \n    Args:\n        arr: 待排序的整数列表\n        \n    Returns:\n        排序后的新列表，原列表不变\n        \n    Examples:\n        >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n        \n        >>> merge_sort([])\n        []\n        \n        >>> merge_sort([42])\n        [42]\n    \"\"\"\n    # 处理边界情况：空列表或单元素列表\n    if len(arr) <= 1:\n        return arr.copy()  # 返回副本以保证纯函数特性\n    \n    # 分治：将列表分成两半\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # 合并两个已排序的列表\n    return _merge(left, right)\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    合并两个已排序的列表。\n    \n    Args:\n        left: 左侧已排序的列表\n        right: 右侧已排序的列表\n        \n    Returns:\n        合并后的已排序列表\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # 比较两个列表的元素，将较小的元素添加到结果中\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # 将剩余元素添加到结果中\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试用例\n    test_cases = [\n        [],                    # 空列表\n        [42],                  # 单元素列表\n        [3, 1, 4, 1, 5, 9, 2, 6],  # 普通列表\n        [5, 4, 3, 2, 1],       # 逆序列表\n        [1, 2, 3, 4, 5],       # 已排序列表\n        [1, 1, 1, 1],          # 重复元素\n    ]\n    \n    for i, test_case in enumerate(test_cases):\n        result = merge_sort(test_case)\n        print(f\"测试用例 {i+1}: {test_case} -> {result}\")\n",
    "expert_type_checker": "import typing\nimport inspect\nimport functools\n\ndef _matches_type(value, expected_type) -> bool:\n    \"\"\"检查值是否匹配预期类型\"\"\"\n    if expected_type is type(None):\n        return value is None\n    \n    origin = typing.get_origin(expected_type)\n    \n    if origin is None:  # 普通类型如int, str\n        return isinstance(value, expected_type)\n    \n    args = typing.get_args(expected_type)\n    \n    if origin is typing.Union:\n        return any(_matches_type(value, a) for a in args)\n    elif origin is list:\n        if not isinstance(value, list):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(v, args[0]) for v in value)\n    elif origin is dict:\n        if not isinstance(value, dict):\n            return False\n        if not args:\n            return True\n        return all(_matches_type(k, args[0]) and _matches_type(v, args[1]) \n                  for k, v in value.items())\n    else:\n        # 兜底：如果无法识别的类型，尝试使用 isinstance\n        return isinstance(value, expected_type) if isinstance(expected_type, type) else True\n\ndef type_check(func):\n    \"\"\"运行时类型检查装饰器\"\"\"\n    hints = typing.get_type_hints(func)\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        \n        # 检查参数类型\n        for param_name, value in bound.arguments.items():\n            if param_name in hints:\n                if not _matches_type(value, hints[param_name]):\n                    raise TypeError(f'参数 {param_name} 类型错误')\n        \n        # 执行函数\n        result = func(*args, **kwargs)\n        \n        # 检查返回值类型\n        if 'return' in hints:\n            if not _matches_type(result, hints['return']):\n                raise TypeError('返回值类型错误')\n        \n        return result\n    \n    return wrapper\n\n# 测试示例\nif __name__ == \"__main__\":\n    @type_check\n    def test_func(x: int, y: str, z: typing.Optional[typing.List[int]] = None) -> str:\n        return f\"x={x}, y={y}, z={z}\"\n    \n    # 正确调用\n    print(test_func(1, \"hello\"))  # 正常运行\n    print(test_func(1, \"hello\", [1, 2, 3]))  # 正常运行\n    \n    # 错误调用 - 类型错误\n    try:\n        test_func(\"not an int\", \"hello\")\n    except TypeError as e:\n        print(f\"捕获到类型错误: {e}\")\n    \n    try:\n        test_func(1, \"hello\", [\"not an int\"])\n    except TypeError as e:\n        print(f\"捕获到类型错误: {e}\")\n    \n    @type_check\n    def test_dict_func(data: typing.Dict[str, int]) -> int:\n        return sum(data.values())\n    \n    # 正确调用\n    print(test_dict_func({\"a\": 1, \"b\": 2}))  # 正常运行\n    \n    # 错误调用\n    try:\n        test_dict_func({\"a\": \"not an int\"})\n    except TypeError as e:\n        print(f\"捕获到类型错误: {e}\")\n",
    "expert_async_pipeline": "import asyncio\nimport time\nfrom typing import Dict, Any, Callable, List, Optional\nfrom collections import defaultdict\nimport functools\n\nclass AsyncPipeline:\n    \"\"\"\n    异步流水线处理类，支持顺序处理和并发处理\n    \"\"\"\n    \n    def __init__(self):\n        self.stages: Dict[str, Callable] = {}\n        self.stats_data = defaultdict(lambda: {\n            'calls': 0,\n            'total_time': 0.0,\n            'errors': 0\n        })\n    \n    def add_stage(self, name: str, fn: Callable) -> None:\n        \"\"\"\n        添加处理阶段\n        \n        Args:\n            name: 阶段名称\n            fn: 处理函数（可以是同步或异步函数）\n        \"\"\"\n        if not callable(fn):\n            raise ValueError(\"函数必须是可调用的\")\n        self.stages[name] = fn\n    \n    async def _process_single_stage(self, stage_name: str, data: Any) -> Any:\n        \"\"\"\n        处理单个阶段\n        \n        Args:\n            stage_name: 阶段名称\n            data: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        stage_func = self.stages[stage_name]\n        start_time = time.time()\n        \n        try:\n            if asyncio.iscoroutinefunction(stage_func):\n                result = await stage_func(data)\n            else:\n                result = stage_func(data)\n            \n            # 记录统计信息\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            \n            return result\n        except Exception as e:\n            # 记录错误\n            self.stats_data[stage_name]['calls'] += 1\n            self.stats_data[stage_name]['total_time'] += (time.time() - start_time)\n            self.stats_data[stage_name]['errors'] += 1\n            raise  # 重新抛出异常\n    \n    async def process(self, data: Any) -> Any:\n        \"\"\"\n        按顺序执行所有阶段\n        \n        Args:\n            data: 输入数据\n            \n        Returns:\n            最终处理结果\n        \"\"\"\n        result = data\n        for stage_name in self.stages:\n            result = await self._process_single_stage(stage_name, result)\n        return result\n    \n    async def process_batch(self, items: List[Any], concurrency: int = 5) -> List[Any]:\n        \"\"\"\n        并发处理一批数据\n        \n        Args:\n            items: 数据列表\n            concurrency: 最大并发数\n            \n        Returns:\n            处理后的数据列表\n        \"\"\"\n        semaphore = asyncio.Semaphore(concurrency)\n        \n        async def process_item(item: Any) -> Any:\n            async with semaphore:\n                return await self.process(item)\n        \n        tasks = [process_item(item) for item in items]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # 处理异常结果\n        final_results = []\n        for result in results:\n            if isinstance(result, Exception):\n                # 如果有异常，可以记录或重新抛出\n                raise result\n            final_results.append(result)\n            \n        return final_results\n    \n    def stats(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        获取处理统计信息\n        \n        Returns:\n            包含每个阶段统计信息的字典\n        \"\"\"\n        result = {}\n        for stage_name, stats in self.stats_data.items():\n            calls = stats['calls']\n            total_time = stats['total_time']\n            errors = stats['errors']\n            \n            avg_time = total_time / calls if calls > 0 else 0.0\n            \n            result[stage_name] = {\n                'calls': calls,\n                'avg_time': avg_time,\n                'errors': errors\n            }\n        return result\n\n\n# 示例使用\nasync def example_usage():\n    \"\"\"示例用法\"\"\"\n    \n    # 创建流水线\n    pipeline = AsyncPipeline()\n    \n    # 添加同步阶段\n    def stage1_sync(data):\n        time.sleep(0.1)  # 模拟同步处理\n        return data * 2\n    \n    # 添加异步阶段\n    async def stage2_async(data):\n        await asyncio.sleep(0.1)  # 模拟异步处理\n        return data + 10\n    \n    # 添加带有错误的阶段\n    def stage3_error(data):\n        if data > 100:\n            raise ValueError(\"数据过大\")\n        return data * 3\n    \n    # 添加阶段\n    pipeline.add_stage('stage1', stage1_sync)\n    pipeline.add_stage('stage2', stage2_async)\n    pipeline.add_stage('stage3', stage3_error)\n    \n    # 测试顺序处理\n    print(\"顺序处理测试:\")\n    result = await pipeline.process(5)\n    print(f\"结果: {result}\")\n    print(f\"统计信息: {pipeline.stats()}\")\n    \n    # 测试批量处理\n    print(\"\\n批量处理测试:\")\n    items = [1, 2, 3, 4, 5]\n    results = await pipeline.process_batch(items, concurrency=2)\n    print(f\"批量结果: {results}\")\n    print(f\"统计信息: {pipeline.stats()}\")\n    \n    # 测试错误处理\n    print(\"\\n错误处理测试:\")\n    try:\n        await pipeline.process(50)\n    except ValueError as e:\n        print(f\"捕获到错误: {e}\")\n    print(f\"统计信息: {pipeline.stats()}\")\n\n\n# 如果直接运行此脚本，执行示例\nif __name__ == \"__main__\":\n    asyncio.run(example_usage())\n",
    "med_lru_cache": "import threading, time\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self._cache = OrderedDict()  # key -> (value, expire_time_or_None)\n        self._capacity = capacity\n        self._lock = threading.Lock()\n    \n    def get(self, key):\n        with self._lock:\n            if key not in self._cache: \n                return None\n            value, expire = self._cache[key]\n            if expire is not None and time.time() > expire:\n                del self._cache[key]\n                return None\n            self._cache.move_to_end(key)\n            return value\n    \n    def put(self, key, value, ttl=None):\n        expire = time.time() + ttl if ttl else None\n        with self._lock:\n            if key in self._cache: \n                self._cache.move_to_end(key)\n            self._cache[key] = (value, expire)\n            if len(self._cache) > self._capacity:\n                self._cache.popitem(last=False)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a cache with capacity 2\n    cache = LRUCache(2)\n    \n    # Test put and get\n    cache.put(\"a\", 1)\n    cache.put(\"b\", 2)\n    print(cache.get(\"a\"))  # Should return 1\n    \n    # Test TTL\n    cache.put(\"c\", 3, ttl=1)  # This entry will expire in 1 second\n    print(cache.get(\"c\"))  # Should return 3\n    time.sleep(1.1)\n    print(cache.get(\"c\"))  # Should return None (expired)\n    \n    # Test capacity limit\n    cache.put(\"d\", 4)\n    print(cache.get(\"b\"))  # Should return None (evicted due to capacity)\n    print(cache.get(\"a\"))  # Should return 1\n    print(cache.get(\"d\"))  # Should return 4\n",
    "med_decorator_retry": "import asyncio\nimport functools\nimport time\nimport logging\nfrom typing import TypeVar, Callable, Type, Union, Awaitable\n\nT = TypeVar('T')\n\ndef auto_retry(\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: Union[Type[Exception], tuple] = (Exception,)\n) -> Callable:\n    \"\"\"\n    装饰器工厂，为函数添加自动重试功能\n    \n    Args:\n        max_retries: 最大重试次数（不包括第一次执行）\n        delay: 初始延迟时间（秒）\n        backoff: 延迟时间的倍数增长因子\n        exceptions: 需要重试的异常类型元组\n    \n    Returns:\n        装饰器函数\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        if asyncio.iscoroutinefunction(func):\n            @functools.wraps(func)\n            async def async_wrapper(*args, **kwargs) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return await func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logging.warning(f\"Attempt {attempt + 1} failed: {e}. Retrying in {current_delay}s...\")\n                            await asyncio.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logging.error(f\"All {max_retries + 1} attempts failed. Last exception: {e}\")\n                            raise\n                raise last_exception\n            return async_wrapper\n        else:\n            @functools.wraps(func)\n            def sync_wrapper(*args, **kwargs) -> T:\n                current_delay = delay\n                last_exception = None\n                \n                for attempt in range(max_retries + 1):\n                    try:\n                        return func(*args, **kwargs)\n                    except exceptions as e:\n                        last_exception = e\n                        if attempt < max_retries:\n                            logging.warning(f\"Attempt {attempt + 1} failed: {e}. Retrying in {current_delay}s...\")\n                            time.sleep(current_delay)\n                            current_delay *= backoff\n                        else:\n                            logging.error(f\"All {max_retries + 1} attempts failed. Last exception: {e}\")\n                            raise\n                raise last_exception\n            return sync_wrapper\n    \n    return decorator\n",
    "hard_calc_parser": "import re\nfrom typing import List, Union, Iterator\n\nclass Token:\n    def __init__(self, type: str, value: Union[str, float]):\n        self.type = type\n        self.value = value\n    \n    def __repr__(self):\n        return f\"Token({self.type}, {self.value})\"\n\nclass Tokenizer:\n    def __init__(self, expression: str):\n        self.expression = expression\n        self.tokens = []\n        self.pos = 0\n    \n    def tokenize(self) -> List[Token]:\n        self.tokens = []\n        self.pos = 0\n        \n        while self.pos < len(self.expression):\n            char = self.expression[self.pos]\n            \n            if char.isspace():\n                self.pos += 1\n                continue\n            \n            if char in '+-*/()':\n                if char == '-' and (self.pos == 0 or self.expression[self.pos-1] == '('):\n                    # This is a negative sign, not a minus operator\n                    # Look ahead to parse the number\n                    num_str = ''\n                    self.pos += 1  # Skip the '-'\n                    while self.pos < len(self.expression):\n                        next_char = self.expression[self.pos]\n                        if next_char.isdigit() or next_char == '.':\n                            num_str += next_char\n                            self.pos += 1\n                        else:\n                            break\n                    if num_str:\n                        # Check if it's a valid number\n                        try:\n                            if '.' in num_str:\n                                num_value = float(num_str)\n                            else:\n                                num_value = int(num_str)\n                            self.tokens.append(Token('NUMBER', -num_value))\n                        except ValueError:\n                            raise ValueError(f\"Invalid number: {num_str}\")\n                    else:\n                        # If there's no number after '-', it's an error\n                        raise ValueError(\"Invalid negative number\")\n                else:\n                    self.tokens.append(Token(char, char))\n                    self.pos += 1\n            elif char.isdigit() or char == '.':\n                # Parse number (including decimals)\n                num_str = ''\n                while self.pos < len(self.expression):\n                    next_char = self.expression[self.pos]\n                    if next_char.isdigit() or next_char == '.':\n                        num_str += next_char\n                        self.pos += 1\n                    else:\n                        break\n                try:\n                    if '.' in num_str:\n                        num_value = float(num_str)\n                    else:\n                        num_value = int(num_str)\n                    self.tokens.append(Token('NUMBER', num_value))\n                except ValueError:\n                    raise ValueError(f\"Invalid number: {num_str}\")\n            else:\n                raise ValueError(f\"Invalid character: {char}\")\n        \n        return self.tokens\n\nclass Parser:\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.pos = 0\n    \n    def peek(self) -> Token:\n        if self.pos < len(self.tokens):\n            return self.tokens[self.pos]\n        return None\n    \n    def consume(self, expected_type: str) -> Token:\n        token = self.peek()\n        if token and token.type == expected_type:\n            self.pos += 1\n            return token\n        raise ValueError(f\"Expected {expected_type}, got {token.type if token else 'EOF'}\")\n    \n    def parse_expression(self) -> float:\n        \"\"\"Parse addition and subtraction (lowest precedence)\"\"\"\n        result = self.parse_term()\n        \n        while self.peek() and self.peek().type in ['+', '-']:\n            op = self.consume(self.peek().type).value\n            right = self.parse_term()\n            if op == '+':\n                result += right\n            else:\n                result -= right\n        \n        return result\n    \n    def parse_term(self) -> float:\n        \"\"\"Parse multiplication and division (medium precedence)\"\"\"\n        result = self.parse_factor()\n        \n        while self.peek() and self.peek().type in ['*', '/']:\n            op = self.consume(self.peek().type).value\n            right = self.parse_factor()\n            if op == '*':\n                result *= right\n            else:\n                if right == 0:\n                    raise ValueError(\"Division by zero\")\n                result /= right\n        \n        return result\n    \n    def parse_factor(self) -> float:\n        \"\"\"Parse parentheses, numbers, and unary minus (highest precedence)\"\"\"\n        token = self.peek()\n        \n        if token.type == 'NUMBER':\n            return self.consume('NUMBER').value\n        elif token.type == '(':\n            self.consume('(')\n            result = self.parse_expression()\n            self.consume(')')\n            return result\n        elif token.type == '-':\n            # Handle unary minus\n            self.consume('-')\n            return -self.parse_factor()\n        else:\n            raise ValueError(f\"Unexpected token: {token}\")\n\ndef evaluate(expression: str) -> float:\n    \"\"\"Evaluate a mathematical expression and return the result as a float.\n    \n    Args:\n        expression: A string containing a valid mathematical expression\n        \n    Returns:\n        The result of evaluating the expression as a float\n        \n    Raises:\n        ValueError: If the expression is invalid\n    \"\"\"\n    if not expression or not expression.strip():\n        raise ValueError(\"Empty expression\")\n    \n    tokenizer = Tokenizer(expression)\n    tokens = tokenizer.tokenize()\n    \n    parser = Parser(tokens)\n    result = parser.parse_expression()\n    \n    # Check if all tokens were consumed\n    if parser.pos < len(tokens):\n        raise ValueError(\"Unexpected tokens in expression\")\n    \n    return result\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test the provided examples\n    test_cases = [\n        ('-5+3', -2.0),\n        ('2-1', 1.0),\n        ('2*(-3+1)', -4.0),\n        ('3.14*2', 6.28)\n    ]\n    \n    for expr, expected in test_cases:\n        try:\n            result = evaluate(expr)\n            print(f\"{expr} = {result} (expected: {expected})\")\n            assert result == expected, f\"Expected {expected}, got {result}\"\n        except Exception as e:\n            print(f\"Error evaluating '{expr}': {e}\")\n    \n    # Additional tests\n    additional_tests = [\n        ('5', 5.0),\n        ('(5)', 5.0),\n        ('2+3*4', 14.0),\n        ('(2+3)*4', 20.0),\n        ('-2.5*4', -10.0),\n        ('10/2', 5.0),\n        ('10/3', 10/3),\n        ('-(-5)', 5.0),\n        ('3.14159', 3.14159),\n    ]\n    \n    print(\"\\nAdditional tests:\")\n    for expr, expected in additional_tests:\n        try:\n            result = evaluate(expr)\n            print(f\"{expr} = {result}\")\n        except Exception as e:\n            print(f\"Error evaluating '{expr}': {e}\")\n",
    "hard_concurrent_pool": "import threading\nimport time\nimport queue\nfrom typing import Callable, Any, List, Optional, Tuple, Union\nfrom concurrent.futures import Future as ConcurrentFuture\nfrom queue import PriorityQueue\nimport uuid\n\nclass Future(ConcurrentFuture):\n    \"\"\"\n    代表一个异步任务的结果\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._result = None\n        self._exception = None\n        self._done = False\n        self._condition = threading.Condition()\n    \n    def set_result(self, result: Any):\n        \"\"\"设置任务结果\"\"\"\n        with self._condition:\n            self._result = result\n            self._done = True\n            self._condition.notify_all()\n    \n    def set_exception(self, exception: Exception):\n        \"\"\"设置任务异常\"\"\"\n        with self._condition:\n            self._exception = exception\n            self._done = True\n            self._condition.notify_all()\n    \n    def result(self, timeout: Optional[float] = None) -> Any:\n        \"\"\"\n        获取任务结果或抛出异常\n        \n        Args:\n            timeout: 超时时间（秒）\n            \n        Returns:\n            任务结果\n            \n        Raises:\n            Exception: 任务执行过程中抛出的异常\n            TimeoutError: 超时\n        \"\"\"\n        with self._condition:\n            if not self._done:\n                if not self._condition.wait(timeout):\n                    raise TimeoutError(\"Task timed out\")\n            \n            if self._exception:\n                raise self._exception\n            return self._result\n\nclass TaskPool:\n    \"\"\"\n    可复用的并发任务池\n    \n    使用线程池执行异步任务，支持任务提交、批量执行、超时控制和优先级。\n    \"\"\"\n    \n    def __init__(self, max_workers: int = 4):\n        \"\"\"\n        初始化任务池\n        \n        Args:\n            max_workers: 最大工作线程数\n        \"\"\"\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be positive\")\n        \n        self._max_workers = max_workers\n        self._workers: List[threading.Thread] = []\n        self._task_queue = PriorityQueue()\n        self._shutdown_event = threading.Event()\n        self._worker_lock = threading.Lock()\n        self._seq_counter = 0\n        \n        # 启动工作线程\n        for _ in range(max_workers):\n            worker = threading.Thread(target=self._worker_loop, daemon=True)\n            worker.start()\n            self._workers.append(worker)\n    \n    def submit(self, fn: Callable, *args, priority: int = 0, timeout: Optional[float] = None, **kwargs) -> Future:\n        \"\"\"\n        提交任务到任务池\n        \n        Args:\n            fn: 要执行的函数\n            *args: 函数参数\n            priority: 任务优先级（数字越小优先级越高）\n            timeout: 任务超时时间（秒）\n            **kwargs: 函数关键字参数\n            \n        Returns:\n            Future: 任务结果的Future对象\n        \"\"\"\n        future = Future()\n        \n        # 构造任务元组 (priority, seq, payload)\n        with self._worker_lock:\n            self._seq_counter += 1\n            task = (priority, self._seq_counter, (fn, args, kwargs, future, timeout))\n            self._task_queue.put(task)\n        \n        return future\n    \n    def map(self, fn: Callable, iterable: List[Any]) -> List[Any]:\n        \"\"\"\n        批量执行任务\n        \n        Args:\n            fn: 要执行的函数\n            iterable: 参数列表\n            \n        Returns:\n            List[Any]: 任务结果列表\n        \"\"\"\n        futures = [self.submit(fn, item) for item in iterable]\n        return [future.result() for future in futures]\n    \n    def shutdown(self, wait: bool = True):\n        \"\"\"\n        关闭任务池\n        \n        Args:\n            wait: 是否等待所有任务完成\n        \"\"\"\n        self._shutdown_event.set()\n        \n        # 发送停止信号给所有工作线程\n        for _ in range(self._max_workers):\n            self._task_queue.put((0, 0, None))\n        \n        if wait:\n            for worker in self._workers:\n                worker.join()\n    \n    def _worker_loop(self):\n        \"\"\"\n        工作线程主循环\n        \"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # 从任务队列获取任务\n                priority, seq, task = self._task_queue.get(timeout=1.0)\n                \n                # 如果收到停止信号\n                if task is None:\n                    break\n                \n                fn, args, kwargs, future, timeout = task\n                \n                try:\n                    # 执行任务\n                    result = fn(*args, **kwargs)\n                    future.set_result(result)\n                except Exception as e:\n                    future.set_exception(e)\n                    \n            except queue.Empty:\n                continue\n            except Exception:\n                # 防止工作线程因异常退出\n                continue\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 测试 submit\n    pool = TaskPool(max_workers=2)\n    \n    # 测试基本功能\n    future = pool.submit(lambda x: x * 2, 21)\n    result = future.result(timeout=5)\n    assert result == 42, f\"Expected 42, got {result}\"\n    print(\"✓ submit test passed\")\n    \n    # 测试异常透传\n    def fail():\n        raise ValueError(\"Test exception\")\n    \n    future = pool.submit(fail)\n    try:\n        future.result(timeout=5)\n        assert False, \"Should have raised exception\"\n    except ValueError as e:\n        assert str(e) == \"Test exception\"\n        print(\"✓ exception pass-through test passed\")\n    \n    # 测试批量执行\n    results = pool.map(lambda x: x * 2, [1, 2, 3, 4])\n    assert results == [2, 4, 6, 8]\n    print(\"✓ map test passed\")\n    \n    # 测试关闭\n    pool.shutdown(wait=True)\n    print(\"✓ shutdown test passed\")\n    \n    print(\"All tests passed!\")\n"
  },
  "pass_rate": 0.7348963029756538,
  "elapsed_minutes": 4508.353331534067
}